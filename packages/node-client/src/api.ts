/**
 * vCloud Director OpenAPI
 * vCloud Director OpenAPI is a new vCloud Director API that is defined using the OpenAPI standards.<br/> This ReSTful API borrows some elements of the legacy vCloud Director API and establishes new patterns for use as described below. <h4>Authentication</h4> Authentication and Authorization schemes are the same as those for the legacy APIs. You can authenticate using the JWT token via the <code>Authorization</code> header or specifying a session using <code>x-vcloud-authorization</code> (The latter form is deprecated). <h4>Operation Patterns</h4> This API follows the following general guidelines to establish a consistent CRUD pattern: <table> <tr>   <th>Operation</th><th>Description</th><th>Response Code</th><th>Response Content</th> </tr><tr>   <td>GET /items<td>Returns a paginated list of items<td>200<td>Response will include Navigational links to the items in the list. </tr><tr>   <td>POST /items<td>Returns newly created item<td>201<td>Content-Location header links to the newly created item </tr><tr>   <td>GET /items/urn<td>Returns an individual item<td>200<td>A single item using same data type as that included in list above </tr><tr>   <td>PUT /items/urn<td>Updates an individual item<td>200<td>Updated view of the item is returned </tr><tr>   <td>DELETE /items/urn<td>Deletes the item<td>204<td>No content is returned. </tr> </table> <h5>Asynchronous operations</h5> Asynchronous operations are determined by the server. In those cases, instead of responding as described above, the server responds with an HTTP Response code 202 and an empty body. The tracking task (which is the same task as all legacy vCD operations use) is linked via the URI provided in the <code>Location</code> header.<br/> All API calls can choose to service a request asynchronously or synchronously as determined by the server upon interpreting the request. Operations that choose to exhibit this dual behavior will have both options documented by specifying both response code(s) below. The caller must be prepared to handle responses to such API calls by inspecting the HTTP Response code. <h5>Error Conditions</h5> <b>All</b> operations report errors using the following vCD error reporting rules: <ul>   <li>400: Bad Request - In event of bad request due to incorrect data or other user error</li>   <li>401: Bad Request - If user is unauthenticated or their session has expired</li>   <li>403: Forbidden - If the user is not authorized or the entity does not exist</li> </ul> <h4>OpenAPI Design Concepts and Principles</h4> <ul>   <li>IDs are full Uniform Resource Names (URNs).</li>   <li>vCloud OpenAPI's <code>Content-Type</code> is always <code>application/json</code></li>   <li>REST links are in the Link header.</li>   <ul>     <li>Multiple relationships for any link are represented by multiple values in a space-separated list.</li>     <li>Links have a custom vCloud Director-specific &quot;model&quot; attribute that hints at the applicable data         type for the links.</li>     <li>title + rel + model attributes evaluates to a unique link.</li>     <li>Links follow Hypermedia as the Engine of Application State (HATEOAS) principles. Links are present if         certain operations are present and permitted for the user&quot;s current role and the state of the         referred entities.</li>   </ul>   <li>APIs follow a flat structure relying on cross-referencing other entities instead of the navigational style       used by the legacy vCloud APIs.</li>   <li>Most endpoints that return a list support filtering and sorting similar to the query service in the legacy       vCloud APIs.</li>   <li>Accept header must be included to specify the API version for the request similar to calls to existing legacy       vCloud APIs.</li>   <li>Each feature has a version in the path element present in its URL.<br/>       <b>Note</b> API URL's without a version in their paths must be considered experimental.</li> </ul> 
 *
 * OpenAPI spec version: 35.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://localhost/cloudapi';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AccessControlGrant {
    /**
    * VcloudId URN identifier for ACL grant 
    */
    'id': string;
    /**
    * Indicates whether this access control grant is based on user memberships or entitlements 
    */
    'grantType': string;
    /**
    * The object that this access control grant applies to 
    */
    'objectId': string;
    /**
    * The ID of the level of access which the subject will be granted. 
    */
    'accessLevelId': string;
}

/**
* A location accessible to this session. 
*/
export class AccessibleLocation {
    'locationId': string;
    'site': EntityReference;
    'org': EntityReference;
    'restApiEndpoint': string;
    'uiEndpoint': string;
    'apiVersion': string;
}

/**
* A message specified by a system administrator org administrator. It is to be displayed to users to alert them to general conditions that may affect them. 
*/
export class Advisory {
    /**
    * A unique identifier for the advisory (read-only).
    */
    'id': string;
    /**
    * The id reference to the target entity this advisory is for.
    */
    'targetId': string;
    /**
    * A localized message for this advisory.
    */
    'message': string;
    /**
    * Priority for an advisory that indicates the level of urgency. These priorities are listed in descending sort order. <ul>   <li>     <em>MANDATORY</em>: Mandatory message that is always displayed;     these advisories cannot be snoozed or dismissed (see documentation     on displayStart and displayEnd)   </li>   <li>     <em>CRITICAL</em>: Equivalent of a \"red\" warning   </li>   <li>     <em>IMPORTANT</em>: Equivalent of a \"yellow\" warning   </li>   <li>     <em>NOTICE</em>: Informational message   </li> </ul> 
    */
    'priority': string;
    /**
    * The ISO-8601 timestamp from which this advisory is applicable. Defaults to the server's current time if unspecified. If permissible, users may update this value to a time in the future to snooze this advisory. 
    */
    'displayStart': Date;
    /**
    * The ISO-8601 timestamp representing when this advisory is no longer applicable. If permissible, users may update this value to a time in the past to dismiss this advisory. The displayEnd timestamp must be >= displayStart. 
    */
    'displayEnd': Date;
    /**
    * Represents where the advisory is being generated from. This is a read-only field. Can be of type USER or INTERNAL. 
    */
    'source': string;
}

/**
* Describes an allocated IP address for a network. IP addresses can be allocated to a vApp VM, an edge gateway interface or may be used in a NAT routed environment. If the address is allocated to an edge gateway, the name of the entity will be 'Edge Gateway'. 
*/
export class AllocatedIpAddress {
    /**
    * Unique identifier for record. This is to support UI operations.
    */
    'id': string;
    /**
    * Id of the entity to which the IP address is allocated such as a VM.
    */
    'entityId': string;
    /**
    * Name of the entity to which the IP address is allocated.
    */
    'entityName': string;
    /**
    * Name of the vApp whose VM is using allocated IP address.
    */
    'vAppName': string;
    /**
    * The allocated IP address.
    */
    'ipAddress': string;
    /**
    * Whether the entity using this IP address is currently deployed.
    */
    'deployed': boolean;
    /**
    * The possible allocation types for allocated network address like VSM allocated, VM allocated or NAT routed.
    */
    'allocationType': AllocatedIpAddressAllocationType;
    /**
    * The vApp network or Org vDC network to which this entity is connected. 
    */
    'networkRef': EntityReference;
    /**
    * The organization that this entity belongs to. 
    */
    'orgRef': EntityReference;
}

/**
* The possible allocation types for allocated network address. VM_ALLOCATED means that the IP address is allocated by a VM, NAT_ROUTED means that the IP address is used in a NAT routed environment and VSM_ALLOCATED means that the IP address is allocated to an NSX edge gateway interface. 
*/
export class AllocatedIpAddressAllocationType {
}

/**
* A set of ports and the protocol supported by a application port profile. 
*/
export class ApplicationPortList {
    /**
    * The display name.
    */
    'name': string;
    /**
    * The protocol this services applies to.
    */
    'protocol': ApplicationPortsProtocolType;
    /**
    * The set of ports on the destination that the profile applies to. Valid values include single ports and a range of ports.
    */
    'destinationPorts': Array<string>;
}

/**
* The definition scope of an Application Port Profile. SYSTEM profiles are available to all tenants. They are default profiles from the backing networking provider. PROVIDER profiles are available to all tenants. They are defined by the provider at a system level. TENANT profiles are available only to the specific tenant organization. They are defined by the tenant or by a provider on behalf of a tenant. 
*/
export class ApplicationPortProfileScopeType {
}

/**
* The supported protocols for an application port profile. 
*/
export class ApplicationPortsProtocolType {
}

export class AssignedQuotaPolicy {
    /**
    * The quota policy reference assigned. 
    */
    'quotaPolicyReference': EntityReference;
}

/**
* Site association information for an entity 
*/
export class Association {
    /**
    * ID of the entity.
    */
    'entityId': string;
    /**
    * ID of the association.
    */
    'associationId': string;
}

/**
* AuditTrailEvent 
*/
export class AuditTrailEvent {
    'eventId': string;
    'description': string;
    'operatingOrg': EntityReference;
    'user': EntityReference;
    'eventEntity': EntityReference;
    'taskId': string;
    'taskCellId': string;
    'cellId': string;
    'eventType': string;
    'serviceNamespace': string;
    'eventStatus': string;
    'timestamp': Date;
    'external': boolean;
    'additionalProperties': any;
}

/**
* Describes an available IP address. 
*/
export class AvailableIpPoolSubnet {
    /**
    * The gateway for the subnet on which IPs are available.
    */
    'gateway': string;
    /**
    * The netmask prefix length of the subnet.
    */
    'prefixLength': number;
    /**
    * Indicates whether the network subnet is currently enabled.
    */
    'enabled': boolean;
    /**
    * Range of IPs which are available for use.
    */
    'ipRanges': IpRanges;
    /**
    * The total number of available IP addresses.
    */
    'totalIpCount': number;
}

/**
* List of available IP addresses. 
*/
export class AvailableIpPoolSubnets {
    'values': Array<AvailableIpPoolSubnet>;
}

/**
* The backing network type. 
*/
export class BackingNetworkType {
}

/**
* Backing Id for an entity not owned by VCD. 
*/
export class BackingRef {
    /**
    * The id/moref of the backing entity.
    */
    'id': string;
    /**
    * The name of backing entity.
    */
    'name': string;
}

/**
* The descriptor of a Defined Entity Behavior 
*/
export class Behavior {
    'name': string;
    /**
    * The Behavior ID is generated and is an output-only property
    */
    'id': string;
    /**
    * The Behavior invocation reference to be used for polymorphic behavior invocations. It is generated and is an output-only property
    */
    'ref': string;
    /**
    * A description specifying the contract of the Behavior
    */
    'description': string;
    /**
    * The Behavior execution mechanism. Can be defined both in an Interface and in a Defined Entity Type as an override.
    */
    'execution': { [key: string]: any; };
}

/**
* A definition of an access control configuration of a Behavior. 
*/
export class BehaviorAccess {
    /**
    * The ID of the Behavior. It can be both a behavior-interface or an overriden behavior-type ID.
    */
    'behaviorId': string;
    /**
    * The ID of an AccessLevel.
    */
    'accessLevelId': string;
}

/**
* An invocation of a Behavior on a Defined Entity instance. Currently the Behavior interfaces are key-value maps specified in the Behavior description. 
*/
export class BehaviorInvocation {
    /**
    * The arguments to be passed to the invoked Behavior
    */
    'arguments': any;
    /**
    * Metadata to be passed to the invoked Behavior
    */
    'metadata': any;
}

/**
* Describes a capability of an entity. 
*/
export class Capability {
    /**
    * The name of the capability.
    */
    'name': string;
    /**
    * Description of the capability as it relates to the entity.
    */
    'description': string;
    /**
    * The value of the capability.
    */
    'value': any;
    /**
    * The type of the value.
    */
    'type': CapabilityValueType;
    /**
    * The category of the capabilities listed.
    */
    'category': CapabilityCategory;
}

/**
* Describes the category of the capability. 
*/
export class CapabilityCategory {
}

/**
* Describes the object type of the capability value. 
*/
export class CapabilityValueType {
}

/**
* A vCloud Director cell. 
*/
export class Cell {
    /**
    * The unique id of the cell.
    */
    'id': string;
    /**
    * The build date for the version of the product installed on this cell.
    */
    'productBuildDate': Date;
    /**
    * Cell active state.
    */
    'isActive': boolean;
    /**
    * The name of the cell.
    */
    'name': string;
    /**
    * The primary ip address of the cell.
    */
    'primaryIP': string;
    /**
    * The product version of the cell.
    */
    'productVersion': string;
}

/**
* A certificate library item.
*/
export class CertificateLibraryItem {
    'id': string;
    'alias': string;
    /**
    * PEM encoded private key. Required if providing a certificate chain
    */
    'privateKey': string;
    /**
    * passphrase for the private key. Required if the private key is encrypted
    */
    'privateKeyPassphrase': string;
    /**
    * PEM encoded certificate
    */
    'certificate': string;
    /**
    * Description of the certificate library item
    */
    'description': string;
}

/**
* Common fields that all Tier-0 or Tier-1 routers have.
*/
export class CommonNsxTRouterFields {
    /**
    * The unique id of the router. Field is sortable.
    */
    'id': string;
    /**
    * The description of the router.
    */
    'description': string;
    /**
    * Name used in NSX-T's logs or GUI. Field is sortable.
    */
    'displayName': string;
}

/**
* Connection to test. 
*/
export class Connection {
    /**
    * The host (or IP address) to connect to.
    */
    'host': string;
    /**
    * The port to use when connecting.
    */
    'port': number;
    /**
    * If the connection should use https.
    */
    'secure': boolean;
    /**
    * Maximum time (in seconds) any step in the test should wait for a response.
    */
    'timeout': number;
    'proxyConnection': ProxyConnection;
}

/**
* This is used by a local endpoint to establish ike connection with the remote site.
*/
export class ConnectorInitiationMode {
}

export class Constraint {
    'constraintType': string;
}

export class CreateCustomEntityTypeAction {
    /**
    * uuid of workflow. 
    */
    'workflowId': string;
    /**
    * Name of input parameter of given workflow to which this custom entity type should be mapped. 
    */
    'workflowInputParameter': string;
}

export class CustomEntities {
    'entities': Array<CustomEntity>;
}

export class CustomEntity {
    /**
    * UUID of custom entity 
    */
    'id': string;
    'name': string;
    /**
    * This refers to UUID of custom entity type 
    */
    'customEntityTypeId': string;
}

export class CustomEntityType {
    /**
    * UUID for custom entity type. This is immutable. 
    */
    'id': string;
    'vroId': string;
    /**
    * This refers to VRO's dynamic type. 
    */
    'vroDynamicType': string;
    /**
    * Display name. 
    */
    'name': string;
    /**
    * This refers to a unique namespace specific string. 
    */
    'nss': string;
    'description': string;
    'tenantScoped': boolean;
    'providerScoped': boolean;
    /**
    * Read-only value indicating publishAll state 
    */
    'publishAll': boolean;
}

export class CustomEntityTypeAction {
    /**
    * Name of workflow 
    */
    'name': string;
    /**
    * UUID of workflow. 
    */
    'workflowId': string;
    /**
    * Name of input parameter of given workflow to which this custom entity type should be mapped. 
    */
    'workflowInputParameter': string;
}

export class CustomEntityTypeActions {
    'actions': Array<CustomEntityTypeAction>;
}

export class Decorator {
    'decoratorType': string;
}

/**
* Describes what a defined entity should look like. 
*/
export class DefinedEntity {
    /**
    * The id of the defined entity in URN format. 
    */
    'id'?: string;
    /**
    * The URN ID of the defined entity type that the entity is an instance of. This is a read-only field. 
    */
    'entityType'?: string;
    /**
    * The name of the defined entity. 
    */
    'name': string;
    /**
    * An external entity's id that this entity may have a relation to. 
    */
    'externalId'?: string;
    /**
    * A JSON value representation. The JSON will be validated against the schema of the entityType that the entity is an instance of. 
    */
    'entity': { [key: string]: any; };
    /**
    * Every entity is created in the \"PRE_CREATED\" state. Once an entity is ready to be validated against its schema, it will transition in another state - RESOLVED, if the entity is valid according to the schema, or RESOLUTION_ERROR otherwise. If an entity in an \"RESOLUTION_ERROR\" state is updated, it will transition to the inital \"PRE_CREATED\" state without performing any validation. If its in the \"RESOLVED\" state, then it will be validated against the entity type schema and throw an exception if its invalid. 
    */
    'state'?: DefinedEntity.StateEnum;
    /**
    * The owner of the defined entity.
    */
    'owner'?: EntityReference;
    /**
    * The organization of the defined entity.
    */
    'org'?: EntityReference;
}

export namespace DefinedEntity {
    export enum StateEnum {
        PRECREATED = <any> 'PRE_CREATED',
        RESOLVED = <any> 'RESOLVED',
        RESOLUTIONERROR = <any> 'RESOLUTION_ERROR'
    }
}
/**
* Describes what a defined entity type should look like. 
*/
export class DefinedEntityType {
    /**
    * The id of the defined entity type in URN format. 
    */
    'id': string;
    /**
    * The name of the defined entity type. 
    */
    'name': string;
    /**
    * Description of the defined entity type. 
    */
    'description': string;
    /**
    * A unique namespace specific string. The combination of nss and version must be unique. 
    */
    'nss': string;
    /**
    * The version of the defined entity type. The combination of nss and version must be unique. The version string must follow semantic versioning rules. 
    */
    'version': string;
    /**
    * An external entity's id that this definition may apply to. 
    */
    'externalId': string;
    /**
    * The JSON-Schema valid definition of the defined entity type. If no JSON Schema version is specified, version 4 will be assumed. 
    */
    'schema': { [key: string]: any; };
    /**
    * The vendor name. 
    */
    'vendor': string;
    /**
    * List of interface ids that this defined entity type is referenced by. 
    */
    'interfaces': Array<string>;
    /**
    * True if the entity type cannot be modified.
    */
    'readonly': boolean;
}

/**
* Interface for a defined entity. The combination of nss+version+vendor should be unique. 
*/
export class DefinedInterface {
    'name': string;
    'id': string;
    /**
    * The interface's version. The version should follow semantic versioning rules.
    */
    'version': string;
    /**
    * The vendor name.
    */
    'vendor': string;
    /**
    * A unique namespace associated with the interface.
    */
    'nss': string;
    /**
    * True if the entity type cannot be modified.
    */
    'readonly': boolean;
}

/**
* Defragmentation Policy helps to handle defragmentation bits present in the inner packet. COPY copies the defragmentation bit from the inner IP packet into the outer packet. CLEAR ignores the defragmentation bit present in the inner packet. 
*/
export class DfPolicyType {
}

/**
* Describes DFW security policies configuration. 
*/
export class DfwPolicies {
    /**
    * A flag indicating whether DFW configuration is enabled or not.
    */
    'enabled': boolean;
    /**
    * The default DFW security policy for the security domain. 
    */
    'defaultPolicy': DfwPolicy;
}

/**
* Describes a DFW security policy.
*/
export class DfwPolicy {
    /**
    * The unique id of this security policy. On updates, the id is required for the policy, while for create a new id will be generated. This id is not a VCD URN. 
    */
    'id': string;
    /**
    * Name for the security policy.
    */
    'name': string;
    /**
    * Description for the security policy.
    */
    'description': string;
    /**
    * Whether this security policy is enabled.
    */
    'enabled': boolean;
    'version': ObjectVersion;
}

/**
* DFW rules.
*/
export class DfwRules {
    /**
    * The ordered list of DFW rules.
    */
    'values': Array<DfwRule>;
}

/**
* The type of Diffie-Helman group. Diffie-Helman groups represent the algorithm used to derive shared keys between the IPSec VPN initiator and responder over an unsecured network. 
*/
export class DhGroupType {
}

/**
* Distributed portgroup. 
*/
export class DistributedPortGroup {
    /**
    * Contains the backing id and name of the distributed portgroup.
    */
    'backingRef': BackingRef;
    /**
    * The entity reference for the vCenter that contains this distributed portgroup.
    */
    'virtualCenter': EntityReference;
    /**
    * The VLAN associated with this distributed portgroup. This can be a single number or a numerical range(1-10).
    */
    'vlan': string;
    /**
    * The distributed virtual switch on which this distributed virtual portgroup was created.
    */
    'dvSwitch': DvSwitch;
}

/**
* Specifies the Dead Peer Detection Profile. This configurations determines the number of seconds to wait in time between probes to detect if an IPSec peer is alive or not. The default value for the DPD probe interval is 60 seconds. 
*/
export class DpdConfig {
    /**
    * The value of the probe interval in seconds. This defines a periodic interval for DPD probes. The minimum is 3 seconds and the maximum is 60 seconds.
    */
    'probeInterval': number;
}

/**
* Distributed virtual switch. 
*/
export class DvSwitch {
    /**
    * Contains the backing id and name of the distributed virtual switch.
    */
    'backingRef': BackingRef;
    /**
    * The entity reference for the vCenter that contains this distributed virtual switch.
    */
    'virtualCenter': EntityReference;
}

/**
* A list of DvpgProperty for all the DVPG's backing a network
*/
export class DvpgProperties {
    /**
    * List of DvpgProperty for each DVPG backing this network
    */
    'dvpgProperties': Array<DvpgProperty>;
}

/**
* A set of properties which can be managed on a DVPG 
*/
export class DvpgProperty {
    /**
    * The VC Moref of the DVPG
    */
    'dvpgMoref': string;
    /**
    * Whether promiscuous mode is currently enabled
    */
    'promiscuousMode': boolean;
    /**
    * Whether forged transmit is currently enabled
    */
    'forgedTransmit': boolean;
    /**
    * The DVSwitch that this DVPG was created on
    */
    'dvSwitch': DvSwitch;
}

/**
* Describes BFD configuration for failure detection. 
*/
export class EdgeBgpBfdConfig {
    /**
    * A flag indicating whether BFD configuration is enabled or not.
    */
    'enabled': boolean;
    /**
    * Specifies the time interval (in milliseconds) between heartbeat packets.
    */
    'bfdInterval': number;
    /**
    * Number of times heartbeat packet is missed before BFD declares that the neighbor is down.
    */
    'declareDeadMultiple': number;
}

/**
* Specifies the Edge Gateway BGP configuration.
*/
export class EdgeBgpConfig {
    /**
    * A flag indicating whether BGP configuration is enabled or not.
    */
    'enabled': boolean;
    /**
    * A flag indicating whether ECMP is enabled or not.
    */
    'ecmp': boolean;
    /**
    * BGP AS number to advertise to BGP peers. BGP AS number can be specified in either ASPLAIN or ASDOT formats, like ASPLAIN format :- '65546', ASDOT format :- '1.10'. Read only if using a VRF-Lite backed external network. 
    */
    'localASNumber': string;
    /**
    * BGP Graceful Restart configuration. Not specifying a value results in default bahavior. Read only if using a VRF-Lite backed external network. 
    */
    'gracefulRestart': EdgeBgpGracefulRestartConfig;
    'version': ObjectVersion;
}

/**
* Describes current graceful restart configuration mode and timer for BGP configuration on an edge gateway. 
*/
export class EdgeBgpGracefulRestartConfig {
    /**
    * Currently configured graceful restart mode. Default is HELPER_ONLY.
    */
    'mode': GracefulRestartModeTypes;
    /**
    * Maximum time taken (in seconds) for a BGP session to be established after a restart. If the session is not re-established within this timer, the receiving speaker will delete all the stale routes from that peer. 
    */
    'restartTimer': number;
    /**
    * Maximum time (in seconds) before stale routes are removed when BGP restarts.
    */
    'staleRouteTimer': number;
}

/**
* A BGP neighbor configuration. 
*/
export class EdgeBgpNeighbor {
    /**
    * The unique id of this BGP neighbor. On updates, the id is required for the object, while for create a new id will be generated. This id is not a VCD URN. 
    */
    'id': string;
    /**
    * The IP address of the BGP neighbor. Both IPv4 and IPv6 formats are supported.
    */
    'neighborAddress': string;
    /**
    * The remote AS number of a BGP neighbor in ASPLAIN format.
    */
    'remoteASNumber': string;
    /**
    * Specifies the time interval (in seconds) between keep alive messages sent to peer.
    */
    'keepAliveTimer': number;
    /**
    * Specifies the time interval (in seconds) before declaring a peer dead.
    */
    'holdDownTimer': number;
    /**
    * Currently configured graceful restart configuration mode. Default is HELPER_ONLY.
    */
    'gracefulRestartMode': GracefulRestartModeTypes;
    /**
    * Specifies the BFD configuration for failure detection. Not specifying a value results in default bahavior. 
    */
    'bfd': EdgeBgpBfdConfig;
    /**
    * A flag indicating whether AllowAS-in is enabled or not. This specifies whether BGP neighbors can receive routes with same AS. 
    */
    'allowASIn': boolean;
    /**
    * Password for BGP neighbor authentication. Empty string (\"\") clears existing password. Not specifying a value will be treated as \"no password\". 
    */
    'neighborPassword': string;
    /**
    * Specifies IP address type based filtering in each direction. Setting the value to 'DISABLED' will disable address family based filtering. 
    */
    'ipAddressTypeFiltering': EdgeBgpNeighbor.IpAddressTypeFilteringEnum;
    /**
    * Specifies route filtering configuration for the BGP neighbor in IN direction. It is the reference to the prefix list, indicating which routes to filter for IN direction. Not specifying a value will be treated as \"no IN route filters\". 
    */
    'inRoutesFilterRef': ExtObjectReference;
    /**
    * Specifies route filtering configuration for the BGP neighbor in OUT direction. It is the reference to the prefix list, indicating which routes to filter for OUT direction. Not specifying a value will be treated as \"no OUT route filters\". 
    */
    'outRoutesFilterRef': ExtObjectReference;
    'version': ObjectVersion;
}

export namespace EdgeBgpNeighbor {
    export enum IpAddressTypeFilteringEnum {
        IPV4 = <any> 'IPV4',
        IPV6 = <any> 'IPV6',
        DISABLED = <any> 'DISABLED'
    }
}
/**
* List of all configured BGP neighbors for an edge gateway. 
*/
export class EdgeBgpNeighbors {
    /**
    * All BGP neighbors for an edge gateway.
    */
    'values': Array<EdgeBgpNeighbor>;
}

/**
* An Edge Cluster object. 
*/
export class EdgeCluster {
    /**
    * The id of the Edge Cluster in URN format.
    */
    'id': string;
    /**
    * The name of the Edge Cluster. Names for Edge Clusters must be unique across the system.
    */
    'name': string;
    'description': string;
    /**
    * The Resource Pool in vCenter where the Edge VM will be deployed.
    */
    'resourcePool': ResourcePool;
    /**
    * Name of the Storage Profile. This will define the set of datastores where the edge vm will be deployed.
    */
    'storageProfileName': string;
}

/**
* Specifies the DNS forwarder configuration for an edge gateway backed by NSX-T.
*/
export class EdgeDnsConfig {
    /**
    * True means that the forwarder is enabled. False means it's disabled.
    */
    'enabled': boolean;
    /**
    * The IP on which the DNS forwarder listens. If the Edge Gateway has a dedicated external network, this can be changed.
    */
    'listenerIp': string;
    /**
    * The default forwarder zone to use if there's no matching domain in the conditional forwarder zone.
    */
    'defaultForwarderZone': NsxtDnsForwarderZoneConfig;
    /**
    * The list of forwarder zones with its matching DNS domains.
    */
    'conditionalForwarderZones': Array<NsxtDnsForwarderZoneConfig>;
    'version': ObjectVersion;
    /**
    * Whether there is an SNAT rule exists for the DNS forwarder or not. In NAT routed environments, an SNAT rule is required for the Edge DNS forwarder to send traffic to an upstream server. In fully routed environments, this is not needed if the listener IP is on an advertised subnet. If the Edge Gateway has a dedicated external network and the listener IP has been changed, there will not be an SNAT rule for the DNS forwarder. In all other cases the SNAT rule will exist. 
    */
    'snatRuleEnabled': boolean;
}

/**
* The backing details of the edge gateway 
*/
export class EdgeGatewayBacking {
    /**
    * The identifier of the edge gateways backing router.
    */
    'backingId': string;
    /**
    * The type of the gateway. Describes if this is an NSX-T edge gateway or an NSX-V edge gateway.
    */
    'gatewayType': EdgeGatewayType;
    /**
    * The backing network provider, either NSX-T or NSX-V.
    */
    'networkProvider': EntityReference;
}

/**
* Describes Load Balancer Service configuration on an Edge Gateway. 
*/
export class EdgeGatewayLoadBalancerConfig {
    /**
    * A flag indicating whether Load Balancer Service is enabled or not.
    */
    'enabled': boolean;
    /**
    * The network definition in Gateway CIDR format which will be used by Load Balancer service on edge. All the load balancer service engines associated with the Service Engine Group will be attached to this network. The subnet prefix length must be 25. If nothing is set, the default is <code>192.168.255.1/25</code>. Default cidr can be configured. This field cannot be updated. 
    */
    'serviceNetworkDefinition': string;
    /**
    * Reference to the Load Balancer Cloud. This cloud is used by Edge Gateway's Load Balancer Virtual Services and Pools.
    */
    'loadBalancerCloudRef': EntityReference;
    /**
    * The license type of the backing Load Balancer Cloud. <ul> <li>BASIC - Basic edition of the NSX Advanced Load Balancer. <li>ENTERPRISE - Full featured edition of the NSX Advanced Load Balancer. </ul> 
    */
    'licenseType': string;
}

/**
* List of Subnets of an edge gateway 
*/
export class EdgeGatewaySubnets {
    'values': Array<EdgeGatewaySubnet>;
}

/**
* The type of the edge gateway. 
*/
export class EdgeGatewayType {
}

/**
* The uplink (i.e. external network) that the edge gateway is connected to. This also contains the external network IPs that are allocated to the edge. 
*/
export class EdgeGatewayUplink {
    /**
    * The identifier of the external network this edge gateway is connected to.
    */
    'uplinkId': string;
    /**
    * The name of the external network this edge gateway is connected to.
    */
    'uplinkName': string;
    /**
    * Set of subnets this edge will have access to. 
    */
    'subnets': EdgeGatewaySubnets;
    /**
    * Whether or not the gateway is connected to this uplink. This value defaults to true if it is not set. When filtering by this field, if the filter is false, all gateways that have 0 connected uplinks will be returned, while if it is true, all gateways with at least one connected uplink will be returned.
    */
    'connected': boolean;
    /**
    * If set on create or update api calls, the specified number of IP addresses will be additionally allocated for this uplink. IPs will be allocated from multiple subnets if needed.
    */
    'quickAddAllocatedIpCount': number;
    /**
    * If set to true, then the associated external network is exclusively used by this edge gateway.
    */
    'dedicated': boolean;
    /**
    * Whether the associated external network is backed by a NSX-T VRF-Lite Tier-0.
    */
    'vrfLiteBacked': boolean;
}

/**
* Specifies the IPSec VPN tunnel configuration.
*/
export class EdgeIpSecVpnTunnel {
    /**
    * The unique id of this IPSec VPN tunnel. On updates, the id is required for the tunnel, while for create a new id will be generated. 
    */
    'id': string;
    /**
    * Name for the tunnel.
    */
    'name': string;
    'description': string;
    /**
    * Described whether the tunnel is enabled or not. The default is true.
    */
    'enabled': boolean;
    /**
    * The Local Endpoint which corresponds to the Edge Gateway the tunnel is being configured on. Local Endpoint requires an IP. That IP must be suballocated to the edge gateway. 
    */
    'localEndpoint': LocalEndpoint;
    /**
    * The Remote Endpoints correspoinds to the device on the remote site terminating the VPN tunnel. 
    */
    'remoteEndpoint': RemoteEndpoint;
    /**
    * The authentication mode this IPSec tunnel will use to authenticate with the peer endpoint. The default is a pre-shared key (PSK). <ul>   <li>PSK - A known key is shared between each site before the tunnel is established.</li>   <li>CERTIFICATE — Incoming connections are required to present an identifying digital certificate, which VCD verifies has been signed by a trusted certificate authority.</li> </ul> 
    */
    'authenticationMode': string;
    /**
    * This is the Pre-shared key used for authentication.
    */
    'preSharedKey': string;
    /**
    * The server certificate which will be used to secure the tunnel's local endpoint.
    */
    'certificateRef': EntityReference;
    /**
    * The CA authority used to verify the remote endpoint’s certificate.
    */
    'caCertificateRef': EntityReference;
    /**
    * This is the mode used by the local endpoint to establish an IKE Connection with the remote site. The default is INITIATOR.
    */
    'connectorInitiationMode': ConnectorInitiationMode;
    /**
    * This is the security type used for the IPSec Tunnel. If nothing is specified, this will be set to 'DEFAULT' in which the default settings in NSX will be used. For custom settings, one should use the connectionProperties endpoint to specify custom settings. The security type will then appropriately reflect itself as 'CUSTOM'. 
    */
    'securityType': string;
    /**
    * Whether logging for the tunnel is enabled or not. The default is false.
    */
    'logging': boolean;
    'version': ObjectVersion;
}

/**
* This specifies the given security profile/connection properties of a given IP Sec VPN Tunnel, such as Dead Probe Interval and IKE settings. If a security type is set to 'CUSTOM', then ike, tunnel, and/or dpd configurations can be specified. Otherwise, those fields are read only and are set to the values based on the specific security type. 
*/
export class EdgeIpSecVpnTunnelConnectionProperties {
    /**
    * This is the security type used for the IPSec Tunnel. If nothing is specified, this will be set to 'DEFAULT' in which the default settings in NSX will be used. If 'CUSTOM' is specified, then ike, tunnel, and dpd configurations can be set. 
    */
    'securityType': string;
    /**
    * The IKE Configuration to be used for the tunnel. If nothing is explictly set, the system defaults will be used. 
    */
    'ikeConfiguration': IkeConfig;
    /**
    * The Tunnel Configuration, which contains parameters such as encryption algorithm to be used. If nothing is explicitly set, the system defaults will be used. 
    */
    'tunnelConfiguration': TunnelConfig;
    /**
    * The Dead Peer Detection configuration. If nothing is explictly set, the system defaults will be used. 
    */
    'dpdConfiguration': DpdConfig;
}

/**
* Specifies the statistics for the given IPSec VPN Tunnel.
*/
export class EdgeIpSecVpnTunnelStatistics {
    /**
    * Local subnet to which a tunnel belongs.
    */
    'localSubnet': string;
    /**
    * Peer subnet to which a tunnel belongs.
    */
    'peerSubnet': string;
    /**
    * Number of packets received.
    */
    'packetsIn': number;
    /**
    * Number of packets sent.
    */
    'packetsOut': number;
    /**
    * Number of bytes received.
    */
    'bytesIn': number;
    /**
    * Number of bytes sent.
    */
    'bytesOut': number;
    /**
    * Number of packets sent with errors.
    */
    'packetsSentError': number;
    /**
    * Number of packets reveived with errors.
    */
    'packetsReceivedError': number;
    /**
    * Number of packets dropped while receiving.
    */
    'packetsInDropped': number;
    /**
    * Number of packets dropped while sending.
    */
    'packetsOutDropped': number;
    /**
    * Number of encryption errors.
    */
    'encryptionErrors': number;
    /**
    * Number of decryption errors.
    */
    'decryptionErrors': number;
    /**
    * Number of errors due to overflow.
    */
    'overflowErrors': number;
    /**
    * Number of replay errors.
    */
    'replayErrors': number;
    /**
    * Number of integrity check errors.
    */
    'integrityErrors': number;
    /**
    * Number of SA mismatch errors while receiving.
    */
    'saMismatchInErrors': number;
    /**
    * Number of SA mismatch errors while sending.
    */
    'saMismatchOutErrors': number;
    /**
    * Number of packets dropped because of no matching policy is available.
    */
    'noMatchingPolicyErrors': number;
}

/**
* This includes the IPSec Tunnel status such as whether the tunnel is up or down and the IKE Session status. 
*/
export class EdgeIpSecVpnTunnelStatus {
    /**
    * Gives the overall IPSec VPN Tunnel Status. If IKE is properly set and the tunnel is up, the tunnel status will be UP.
    */
    'tunnelStatus': TunnelStatus;
    /**
    * Status for the actual IKE Session for the given tunnel.
    */
    'ikeStatus': IkeStatus;
}

/**
* Specifies the L2 VPN tunnel configuration.
*/
export class EdgeL2VpnTunnel {
    /**
    * The unique id of this L2 VPN tunnel. On updates, the id is required for the tunnel, while for create a new id will be generated. This id is not a VCD URN. 
    */
    'id': string;
    /**
    * Name for the tunnel.
    */
    'name': string;
    /**
    * Description for the tunnel.
    */
    'description': string;
    /**
    * The IP address of the local endpoint, which corresponds to the Edge Gateway the tunnel is being configured on. 
    */
    'localEndpointIP': string;
    /**
    * The IP address of the remote endpoint, which corresponds to the device on the remote site terminating the VPN tunnel. 
    */
    'remoteEndpointIP': string;
    /**
    * The network CIDR block over which the session interfaces.
    */
    'tunnelInterface': string;
    /**
    * This is the Pre-shared key used for authentication, no specific format is required.
    */
    'preSharedKey': string;
    /**
    * This is the mode used by the local endpoint to establish an IKE Connection with the remote site. The default is INITIATOR. <ul>   <li>INITIATOR - Local endpoint initiates tunnel setup and will also respond to incoming tunnel setup requests from the peer gateway.</li>   <li>RESPOND_ONLY - Local endpoint shall only respond to incoming tunnel setup requests, it shall not initiate the tunnel setup.</li>   <li>ON_DEMAND - In this mode local endpoint will initiate tunnel creation once first packet matching the policy rule is received, and will also respond to   incoming initiation requests.</li> </ul> 
    */
    'connectorInitiationMode': string;
    /**
    * Described whether the tunnel is enabled or not. The default is true.
    */
    'enabled': boolean;
    /**
    * The current session mode, one of either SERVER or CLIENT. <ul>   <li>SERVER - In which the edge gateway acts as the server side of the L2 VPN tunnel and generates peer codes to distribute to client sessions.</li>   <li>CLIENT - In which the edge gateway receives peer codes from the server side of the L2 VPN tunnel to establish a connection.</li> </ul> 
    */
    'sessionMode': string;
    /**
    * This property is a base64 encoded string of the full configuration for the tunnel, generated by the server-side L2 VPN session. An L2 VPN client session must receive and validate this string in order to successfully establish a tunnel, but be careful sharing or storing this code since it does contain the encoded PSK. Leave this property blank if this call is being used to establish a server-side session. 
    */
    'peerCode': string;
    /**
    * The list of OrgVDC Network entity references which are currently attached to this L2VPN tunnel. 
    */
    'attachedNetworks': Array<EntityReference>;
    /**
    * Whether logging for the tunnel is enabled or not.
    */
    'logging': boolean;
    'version': ObjectVersion;
}

/**
* Specifies the statistics for the given L2 VPN Tunnel.
*/
export class EdgeL2VpnTunnelStatistics {
    /**
    * Broadcast, Unknown unicast, and Multicast (BUM) bytes in.
    */
    'bumBytesIn': number;
    /**
    * Broadcast, Unknown unicast, and Multicast (BUM) bytes out.
    */
    'bumBytesOut': number;
    /**
    * Broadcast, Unknown unicast, and Multicast (BUM) packets in.
    */
    'bumPacketsIn': number;
    /**
    * Broadcast, Unknown unicast, and Multicast (BUM) packets out.
    */
    'bumPacketsOut': number;
    /**
    * Total number of incoming bytes.
    */
    'bytesIn': number;
    /**
    * Total number of outgoing bytes.
    */
    'bytesOut': number;
    /**
    * Total number of incoming packets.
    */
    'packetsIn': number;
    /**
    * Total number of outgoing packets.
    */
    'packetsOut': number;
    /**
    * Total number of incoming packets dropped.
    */
    'packetsReceiveError': number;
    /**
    * Total number of packets dropped while sending for any reason.
    */
    'packetsSentError': number;
    /**
    * Policy path referencing the segment on which stats are gathered.
    */
    'segmentPath': string;
}

/**
* This includes the L2 VPN tunnel status such as whether the tunnel is up or down and the IKE Session status. 
*/
export class EdgeL2VpnTunnelStatus {
    /**
    * Gives the overall L2 VPN Runtime Status (one of either UP or DOWN). <ul>   <li>UP - Indicating that the tunnel connection has been successfully established.</li>   <li>DOWN - Indicating that the tunnel connection has not yet been successfully established.</li> </ul> 
    */
    'runtimeStatus': string;
    /**
    * The error message which led to this tunnel's failure (if applicable).
    */
    'failureReason': string;
}

/**
* A supported metrics.
*/
export class EdgeLoadBalancerAnalyticMetric {
    /**
    * The metric key to be used in report queries.
    */
    'key': string;
    'description': string;
}

/**
* The list of supported metrics.  These metrics can be used for building report queries.
*/
export class EdgeLoadBalancerAnalyticMetrics {
    'metrics': Array<EdgeLoadBalancerAnalyticMetric>;
}

/**
* A Load Balancer Analytic Report. It represents a timeseries of Edge Gateway Load Balancer runtime data. 
*/
export class EdgeLoadBalancerAnalyticReport {
    /**
    * The gateway URN identier.
    */
    'gatewayId': string;
    /**
    * The virtual service or pool URN identifier.
    */
    'componentId': string;
    /**
    * The metric for this specific report.  Supported metrics can be determined by using the supported metrics API.
    */
    'metric': string;
    /**
    * The units for this specific report.  Units may be one of the following <ul> <li>PER_SECOND <li>METRIC_COUNT <li>BITS_PER_SECOND <li>BYTES_PER_SECOND <li>MILLISECONDS <li>PERCENT </ul> Units are derived from the reported metric. 
    */
    'units': string;
    'statistics': EdgeLoadBalancerMetricSummaryStats;
    /**
    * The metric timeseries of data for this report.
    */
    'data': Array<EdgeLoadBalancerMetricData>;
}

/**
* A set of Load Balancer analytic reports.  Each report in the list represents a timeseries of Edge Gateway Load Balancer runtime data. 
*/
export class EdgeLoadBalancerAnalyticReports {
    'values': Array<EdgeLoadBalancerAnalyticReport>;
}

/**
* Specifies the application profile for the virtual service such as whether it's HTTP, HTTPS, or TCP/UDP. 
*/
export class EdgeLoadBalancerApplicationProfile {
    /**
    * Name of the application profile. Name of the system defined monitors are prefixed with System for example 'System-HTTP'.
    */
    'name': string;
    /**
    * The profile type of application that this Virtual Service is configured with. A value of \"-\" represents an unknown type. Such profile can still be removed from the Virtual Service on update but is not valid on create. Values are below. <ul> <li>HTTP - Virtual Service supports HTTP protocol. <li>HTTPS - Virtual Service supports HTTPS protocol. <li>L4 - Virtual Service supports Layer 4 (Transport) using UDP/TCP protocol. <li>L4_TLS - Virtual Service supports Layer 4 (Transport) using UDP/TCP protocol with TLS. </ul> L4_TLS is allowed only with additional licensing. 
    */
    'type': string;
    /**
    * Whether the Application Profile is system defined.
    */
    'systemDefined': boolean;
}

/**
* Specifies the health monitoring configuration for a Load Balancer Pool. Health monitors are used to monitor health of the Load Balancer Pool's member servers. 
*/
export class EdgeLoadBalancerHealthMonitor {
    /**
    * Name of the Health monitor. Name of the system defined monitors are prefixed with System for example 'System-HTTP'.
    */
    'name': string;
    /**
    * Type of the health monitors. A value of \"-\" represents an unknown type. Such monitor can still be removed from the Load Balancer Pool on update but is not valid on create. Supported values are: <ul> <li>HTTP - HTTP request/response is used to validate health. <li>HTTPS - Used against HTTPS encrypted web servers to validate health. <li>TCP - TCP connection is used to validate health. <li>UDP - A UDP datagram is used to validate health. <li>PING - An ICMP ping is used to validate health. </ul> 
    */
    'type': string;
    /**
    * Whether the Health Monitor is system defined.
    */
    'systemDefined': boolean;
}

/**
* A data point in the metric timeseries. 
*/
export class EdgeLoadBalancerMetricData {
    /**
    * Sampled data time.
    */
    'timestamp': string;
    /**
    * Data value for the sampled time.  ISO 8601 format (i.e. 2020-07-24T00:00:00).
    */
    'value': string;
}

/**
* A statistical summary of the data in the report. 
*/
export class EdgeLoadBalancerMetricSummaryStats {
    /**
    * Mean value of sample.
    */
    'mean': number;
    /**
    * Min value of sample.
    */
    'min': number;
    /**
    * Max value of sample.
    */
    'max': number;
    /**
    * Sample trend.
    */
    'trend': number;
    /**
    * Sample size.
    */
    'sampleSize': number;
    /**
    * Start time of data series.  ISO 8601 format (i.e. 2020-07-24T00:00:00).
    */
    'startTime': string;
    /**
    * End time of data series.  ISO 8601 format (i.e. 2020-07-24T00:00:00).
    */
    'endTime': string;
}

/**
* Specifies the Persistence profile for a Load Balancer Pool. Persistence profile will ensure that the same user sticks to the same server for a desired duration of time. If the persistence profile is unmanaged by Cloud Director, updates that leave the values unchanged will continue to use the same unmanaged profile. Any changes made to the persistence profile will cause Cloud Director to switch the pool to a profile managed by Cloud Director. 
*/
export class EdgeLoadBalancerPersistenceProfile {
    /**
    * Name of the Persistence profile. 
    */
    'name': string;
    /**
    * Type of persistence strategy to use. Supported values are: <ul> <li>CLIENT_IP - The client’s IP is used as the identifier and mapped to the server. <li>HTTP_COOKIE - Load Balancer inserts a cookie into HTTP responses. Cookie name must be provided as value. <li>CUSTOM_HTTP_HEADER - Custom, static mappings of header values to specific servers are used. Header name must be provided as value. <li>APP_COOKIE - Load Balancer reads existing server cookies or URI embedded data such as JSessionID. Cookie name must be provided as value. <li>TLS - Information is embedded in the client’s SSL/TLS ticket ID. This will use default system profile \"System-Persistence-TLS\". </ul> 
    */
    'type': string;
    /**
    * Value of attribute based on selected persistence type. This is required for HTTP_COOKIE, CUSTOM_HTTP_HEADER and APP_COOKIE persistence types. HTTP_COOKIE, APP_COOKIE must have cookie name set as the value and CUSTOM_HTTP_HEADER must have header name set as the value. 
    */
    'value': string;
}

/**
* Defines a member (a destination server) in a Load Balancer Pool.
*/
export class EdgeLoadBalancerPoolMember {
    /**
    * The ip address of the Load Balancer Pool member.
    */
    'ipAddress': string;
    /**
    * The port number of the Load Balancer Pool member. If unset, the port that the client used to connect will be used.
    */
    'port': number;
    /**
    * The ratio of selecting eligible servers in the pool.
    */
    'ratio': number;
    /**
    * Whether the Load Balancer Pool member is enabled or not.
    */
    'enabled': boolean;
    /**
    * The current health status of the pool member. Possible values are: <ul> <li> UP - The member is operational. <li> DOWN - The member is down. <li> DISABLED - The member is disabled <li> UNKNOWN - The state is unknown. </ul> 
    */
    'healthStatus': string;
    /**
    * When the member is DOWN, the value gives the names of the health monitors that marked the member as down. If a monitor cannot be determined, the value will be UNKNOWN. 
    */
    'markedDownBy': Array<string>;
    /**
    * The non-localized detailed message on the health of the pool member. 
    */
    'detailedHealthMessage': string;
}

/**
* A Virtual Service port configuration. 
*/
export class EdgeLoadBalancerServicePort {
    /**
    * Specifies the TCP/UDP profile for the service ports such as TCP_PROXY or TCP_FAST_PATH. If unset, a profile using the system-defined type of TCP_PROXY is used. This is valid for all Application Profiles. For L4 application profile type, user can set the profile to a different type such as TCP_FAST_PATH. For any other application profile type, the TCP/UDP profile type must be TCP_PROXY. 
    */
    'tcpUdpProfile': EdgeLoadBalancerTcpUdpProfile;
    /**
    * The starting port number in the port range of the Virtual Service. If a single port is desired, only this field needs to be specified. An example is that HTTP uses port 80. 
    */
    'portStart': number;
    /**
    * The ending port number in the port range of the Virtual Service.  This is not required if a single port is desired.
    */
    'portEnd': number;
    /**
    * A flag indicating whether SSL termination is enabled at the port or not. This can only be enabled if HTTPS and L4_TLS Application Profile types are used. For HTTPS, if SSL is disabled for a specific port, traffic from that port will be redirected to the first SSL port specified. This allows for automatic HTTP to HTTPS redirects. Disabling SSL for HTTPS and L4_TLS is allowed only with additional licensing. 
    */
    'sslEnabled': boolean;
}

/**
* Specifies the TCP/UDP profile for the service ports such as TCP_PROXY or TCP_FAST_PATH. 
*/
export class EdgeLoadBalancerTcpUdpProfile {
    /**
    * Name of the TCP/UDP profile. Name of the system defined monitors are prefixed with System for example 'System-TCP-Proxy'.
    */
    'name': string;
    /**
    * This property specifies the different ways in which TCP/UDP packets are sent to the destination server. A value of \"-\" represents an unknown type. Such profile can still be removed from the Virtual Service on update but is not valid on create. <ul> <li>TCP_PROXY - TCP connection is terminated at the Virtual Service and a new TCP connection is made to the destination server. <li>TCP_FAST_PATH - TCP packets are directly forwarded to the destination server. <li>UDP_FAST_PATH - UDP packets are directly forwarded to the destination server. </ul> 
    */
    'type': string;
    /**
    * Whether the TCP/UDP profile is system defined.
    */
    'systemDefined': boolean;
}

/**
* The configuration for a given NAT Rule.
*/
export class EdgeNatRule {
    /**
    * The unique id of the NAT Rule. This must be supplied when updating a given NAT Rule. On creation, an unique id is generated for the NAT Rule. 
    */
    'id': string;
    /**
    * User friendly name for the NAT Rule. Name must be provided.
    */
    'name': string;
    'description': string;
    /**
    * A flag indicating whether the individual nat rule is enabled or not. The default is true.
    */
    'enabled': boolean;
    /**
    * Represents the type of NAT Rule. SNAT translates an internal IP to an external IP and is used for outbound traffic. DNAT translates the external IP to an internal IP and is used for inbound traffic. 
    */
    'ruleType': NatRuleType;
    /**
    * Represents the application ports on which the NAT Rule will be applied. An application port profile id in the form of URN format must be provided. If not provided then the port will be considered as \"ANY\". For a DNAT Rule, the source port on the application port profile represents the port from which the traffic is originating from. For a DNAT rule, the destination port on the application port profile represents the internal port on the workloads where the traffic is terminating. For a SNAT rule, the source port on the application port profile represents the internal port on the workloads where the traffic is originating from. For a SNAT rule, the destination port application port profile represents the port where the traffic is terminating. 
    */
    'applicationPortProfile': EntityReference;
    /**
    * The external addresses for the NAT Rule. This must be supplied as a single IP or Network CIDR. For a DNAT rule, this is the external facing IP Address for incoming traffic. For an SNAT rule, this is the external facing IP Address for outgoing traffic. These ips are typically allocated/suballocated IP Addresses on the Edge Gateway. 
    */
    'externalAddresses': string;
    /**
    * The internal addresses for the NAT Rule. This must be supplied as a single IP or Network CIDR. For a DNAT rule, this is the internal IP Address for incoming traffic. For an SNAT rule, this is the internal IP Address for outgoing traffic. These ips are typically the Private IPs that are allocated to workloads. 
    */
    'internalAddresses': string;
    /**
    * Port number or port range for incoming network traffic. If Any Traffic is selected for the Service, the default internal port is \"ANY\". Note that this field has been deprecated. Please use dnatExternalPort to set port forwarding for DNAT rules. This typically should not be set for SNAT rules as the rule would not be able to support IP Translation with multiple ports. 
    */
    'internalPort': string;
    /**
    * This represents the external port number or port range when doing DNAT port forwarding from external to internal. The default dnatExternalPort is \"ANY\" meaning traffic on any port for the given IPs selected will be translated. 
    */
    'dnatExternalPort': string;
    /**
    * A flag indicating whether logging for the individual nat rule is enabled or not. The default is false.
    */
    'logging': boolean;
    /**
    * A flag indicating whether this NAT rule is managed by the system. This is not user editable
    */
    'systemRule': boolean;
    /**
    * The destination addresses to match in the SNAT Rule. This must be supplied as a single IP or Network CIDR. Providing no value for this field results in match with ANY destination network. These IPs are typically the Private IPs that are allocated to destination workloads. 
    */
    'snatDestinationAddresses': string;
    'version': ObjectVersion;
}

/**
* A list of prefixes for routing purposes. Prefix list contains one or more ordered entries which are processed sequentially. 
*/
export class EdgePrefixList {
    /**
    * The unique id of this prefix list. On updates, the id is required for the list, while for create a new id will be generated. This id is not a VCD URN. 
    */
    'id': string;
    /**
    * Name for the prefix list.
    */
    'name': string;
    /**
    * Description for this prefix list.
    */
    'description': string;
    /**
    * List of network prefixes.
    */
    'prefixes': Array<EdgePrefixListEntry>;
    'version': ObjectVersion;
}

/**
* A network prefix entry used for routing purposes. 
*/
export class EdgePrefixListEntry {
    /**
    * The network prefix in CIDR format. If the value is not specified, it will be treated as \"ANY\" which means match all networks. Both IPv4 and IPv6 formats are supported. 
    */
    'network': string;
    /**
    * Action for the prefix list. This specifies whether the packet from specified network is advertised or not for routing purposes. 
    */
    'action': EdgePrefixListEntry.ActionEnum;
    /**
    * The value which the prefix length must be greater than or equal to. Must be less than or equal to 'lessThanEqualTo'
    */
    'greaterThanEqualTo': number;
    /**
    * The value which the prefix length must be less than or equal to. Must be greater than or equal to 'greaterThanEqualTo'
    */
    'lessThanEqualTo': number;
}

export namespace EdgePrefixListEntry {
    export enum ActionEnum {
        PERMIT = <any> 'PERMIT',
        DENY = <any> 'DENY'
    }
}
/**
* List of all configured Prefix lists for an edge gateway. 
*/
export class EdgePrefixLists {
    /**
    * All Prefix lists.
    */
    'values': Array<EdgePrefixList>;
}

/**
* An Egress Point. 
*/
export class EgressPoint {
    /**
    * The unique ID for the Universal Egress Point (read-only).
    */
    'id': string;
    /**
    * The Org vDC the Universal Egress Point belongs to.
    */
    'vdcRef': EntityReference;
    /**
    * The Edge Gateway the Egress Point is referring to.
    */
    'gatewayRef': EntityReference;
    /**
    * Read-only field that specifies the network provider scope of the Universal Egress Point (inherited from the Org vDC).
    */
    'networkProviderScope': string;
    /**
    * Specifies whether the egress point is being used for Universal Routing. This is a read-only field.
    */
    'isUsedForRouting': boolean;
    /**
    * The status of the Universal Egress Point.
    */
    'status': VdcGroupEntityStatus;
    'errorMessage': string;
}

/**
* An EgressPoint reference object for use in universal routing. 
*/
export class EgressPointReference {
    /**
    * The id of the Universal Egress Point reference.
    */
    'egressPointId': string;
    /**
    * The Org vDC of the Universal Egress Point reference.
    */
    'vdcRef': EntityReference;
    /**
    * The Edge Gateway of the Universal Egress Point reference.
    */
    'gatewayRef': EntityReference;
}

/**
* List of Egress Points. 
*/
export class EgressPoints {
    /**
    * The list of Universal Egress Points.
    */
    'values': Array<EgressPoint>;
}

/**
* Email related settings for a system 
*/
export class EmailSettings {
    /**
    * Flag indicating if the smtp server settings are system default (true) or a particular organization (false) 
    */
    'defaultSmtpServer': boolean;
    /**
    * Flag indicating if the email settings are system default (true) or for a particular organization (false) 
    */
    'defaultOrgEmail': boolean;
    'smtpServer': SmtpServerSpec;
    /**
    * Sender email address in an email notification or alert 
    */
    'senderEmailAddress': string;
    /**
    * The prefix used in the email subject line for all email notifications and alerts from the system 
    */
    'defaultEmailSubjectPrefix': string;
    /**
    * A flag to indicate the choice between sending alert emails to all system administrators in the system and designated list of email recipients 
    */
    'alertEmailToAllAdmins': boolean;
    /**
    * A comma separated email addresses to send all alert messages to 
    */
    'alertEmailTo': string;
}

/**
* Entity reference used to describe VCD entities 
*/
export class EntityReference {
    'name': string;
    'id': string;
}

/**
* Describes what the current state of the entity is. 
*/
export class EntityState {
    /**
    * The id of the defined entity in URN format. 
    */
    'id': string;
    /**
    * A JSON entity. This entity will be validated against the provided entityType. 
    */
    'entity': { [key: string]: any; };
    /**
    * The current state of the entity 
    */
    'state': EntityState.StateEnum;
    /**
    * The error message(s), if the entity could not be resolved. 
    */
    'message': string;
}

export namespace EntityState {
    export enum StateEnum {
        RESOLVED = <any> 'RESOLVED',
        RESOLUTIONERROR = <any> 'RESOLUTION_ERROR'
    }
}
export class ExecutionContext {
    'parameters': Array<WsParameter>;
}

export class ExecutionState {
}

export class ExecutionSummary {
    'id': string;
    'name': string;
    'startDate': string;
    'endDate': string;
    'startedBy': string;
    'state': ExecutionState;
}

/**
* Reference for entities which are external to VCD and do not have a VCD URN identifier. 
*/
export class ExtObjectReference {
    /**
    * The id of the entity.
    */
    'id': string;
    /**
    * The name of entity.
    */
    'name': string;
}

/**
* Extension Point of a UI Plugin
*/
export class ExtensionPoint {
    'extensionPointId': string;
    'pluginId': string;
    'name': string;
    'enabled': boolean;
}

/**
* A map of extension Points and an ordered list of items registered with that extension point
*/
export class ExtensionPointSummary {
    'extensionPointRegistrations': { [key: string]: Array<ExtensionPoint>; };
}

/**
* Information about an external network backing. 
*/
export class ExternalNetworkBacking {
    /**
    * Unique identifier for the network backing in NSX/vCenter.
    */
    'backingId': string;
    /**
    * Type of network backing. This is deprecated in favor of string based enums going forward.
    */
    'backingType': ExternalNetworkBackingType;
    /**
    * Backing type for the network. Can be PORTGROUP, DV_PORTGROUP, NSXT_TIER0, NSXT_VRF_TIER0 or UNKNOWN.
    */
    'backingTypeValue': string;
    /**
    * The Network Provider for the backing, either a vCenter Server or NSX-T Manager.
    */
    'networkProvider': EntityReference;
    /**
    * The name of this external network backing, if it exists.
    */
    'name': string;
    /**
    * If this external network is backed by a NSX-T VRF-Lite Tier0, then this field is set to be the parent Tier0 Router.  Otherwise, field is unset.
    */
    'parentTier0Ref': ExtObjectReference;
}

/**
* The type of the external network backing. 
*/
export class ExternalNetworkBackingType {
}

/**
* List of External Network backings. 
*/
export class ExternalNetworkBackings {
    'values': Array<ExternalNetworkBacking>;
}

/**
* The central concept in vCD API extensibility framework. It serves as a namespace for all other objects and holds top level settings like - enable/disable and API filters. 
*/
export class ExternalService {
    /**
    * The name of the external service.
    */
    'name': string;
    /**
    * The unique id of the external service.
    */
    'id': string;
    /**
    * The extension's version. The version should follow semantic versioning rules. The combination of vendor-namespace-version must be unique. 
    */
    'version': string;
    /**
    * The vendor name. The combination of vendor-namespace-version must be unique. 
    */
    'vendor': string;
    /**
    * Extension service priority. An integer between 0-100. A value of 50 denotes a neutral priority. 
    */
    'priority': number;
    /**
    * Whether the extension is enabled or not.
    */
    'enabled': boolean;
    /**
    * Whether authorization is enabled for the service.
    */
    'authorizationEnabled': boolean;
    'description': string;
    /**
    * The map of MQTT topics this extension will communicate through. 
    */
    'mqttTopics': { [key: string]: string; };
}

/**
* Represents an associated virtual machine. Contains the VM name and parent vApp name.
*/
export class FirewallGroupAssociatedVM {
    /**
    * Reference to the vm associated with this firewall group. 
    */
    'vmRef': EntityReference;
    /**
    * Reference to the vApp of the associated vm. 
    */
    'vappRef': EntityReference;
    /**
    * Reference to the vDC of the associated vm. 
    */
    'vdcRef': EntityReference;
    /**
    * Reference to the organization of the associated vm. 
    */
    'orgRef': EntityReference;
}

/**
* Describes the scope and relationship that this firewall group has with other VCD entities.
*/
export class FirewallGroupScope {
    /**
    * The organization that this firewall group belongs to. This property is read-only and cannot be updated. 
    */
    'orgRef': EntityReference;
    /**
    * The edge gateway that this firewall group is scoped to. This means that this firewall group can be used when configuring firewall rules for the edge gateway. This property is now deprecated. ownerRef should be used instead 
    */
    'edgeGatewayRef': EntityReference;
    /**
    * The vDC Group or Edge Gateway that this firewall group is scoped to. This group can be used for configuring rules for either an Edge Gateway or vDC Group. If an Edge Gateway is specified that belongs to a vDC Group, the the firewall group will be scoped to the vDC Group. 
    */
    'ownerRef': EntityReference;
    /**
    * The network provider scope that this object belongs to. This is a read-only property and is determined by the input context entity ID during object creation. 
    */
    'networkProviderScope': string;
}

/**
* Defines the type of Firewall Group. These groups can be used in Firewall Rules to define rules that are scoped to the IP Addresses/Members defined in a Firewall Group. <ul>   <li> <code> IP_SET </code> should be used when using particular IP Addresses of VMs, Networks, etc.   <li> <code> SECURITY_GROUP </code> should be used when specifying exact members such as a particular Org vDC Network. </ul> The default is IP_SET. 
*/
export class FirewallGroupType {
}

/**
* Describes a Firewall rule.
*/
export class FirewallRule {
    /**
    * The unique id of this firewall rule. If a rule with the ruleId is not already present, a new rule will be created. If it already exists, the rule will be updated. 
    */
    'id': string;
    /**
    * Name for the rule.
    */
    'name': string;
    'description': string;
    /**
    * List of source groups for firewall rule. It specifies the sources of network traffic for the firewall rule. Null value or an empty list will be treated as \"ANY\" which means traffic from any source. 
    */
    'sourceFirewallGroups': Array<EntityReference>;
    /**
    * List of source groups for firewall rule. It specifies the destinations of network traffic for the firewall rule. Null value or an empty list will be treated as \"ANY\" which means traffic to any destination. 
    */
    'destinationFirewallGroups': Array<EntityReference>;
    /**
    * The list of application ports where this firewall rule is applicable. Null value or an empty list will be treated as \"ANY\" which means rule applies to all ports. 
    */
    'applicationPortProfiles': Array<EntityReference>;
    /**
    * Type of IP packet that should be matched while enforcing the rule. Default value is IPV4_IPV6. 
    */
    'ipProtocol': FirewallRuleIpProtocol;
    /**
    * The action to be applied to all the traffic that meets the firewall rule criteria. It determines if the rule permits or blocks traffic. 
    */
    'action': FirewallRuleAction;
    /**
    * Specifies the direction of the network traffic. Default value is IN_OUT. 
    */
    'direction': FirewallRuleDirection;
    /**
    * Whether packet logging is enabled for firewall rule.
    */
    'logging': boolean;
    /**
    * The list of layer 7 network context profiles where this firewall rule is applicable. Null value or an empty list will be treated as \"ANY\" which means rule applies to all applications and domains. 
    */
    'networkContextProfiles': Array<EntityReference>;
    /**
    * Whether the firewall rule is enabled.
    */
    'enabled': boolean;
    'version': ObjectVersion;
}

/**
* Defines the firewall rule action to be applied. 
*/
export class FirewallRuleAction {
}

/**
* Defines direction of traffic for firewall rule. 
*/
export class FirewallRuleDirection {
}

/**
* Specifies the IP protocol for the network packet that should be matched while enforcing the rule. IPV4_IPV6 means both IPV4 and IPV6 packet type. 
*/
export class FirewallRuleIpProtocol {
}

/**
* Represents the Edge Cluster Configuration for a given Edge Gateway. 
*/
export class GatewayEdgeClusterConfig {
    /**
    * This represents the Primary Edge Cluster used for the gateway. For NSX-T Edges, this means the Edge Cluster the Tier 1 SR resides on. The user should specify the ID of the NSX-T edge cluster as the value of primaryEdgeCluster's backingId. For NSX-V Edges, this means the primary appliance for the gateway. 
    */
    'primaryEdgeCluster': GatewayEdgeClusterReference;
    /**
    * This represents the Secondary Edge Cluster used for the gateway. It is only applicable for NSX-V Edges when High Availability is enabled. If HA is enabled and no secondary edge cluster is specified, both appliances will be deployed on the primary edge cluster. If there is a specific secondary edge cluster, the standby/secondary appliance will be deployed on the secondary edge cluster. For NSX-T Edges, the value of secondaryEdgeCluster should be set to NULL. 
    */
    'secondaryEdgeCluster': GatewayEdgeClusterReference;
}

/**
* This represents the reference to an Edge Cluster used for the gateway. 
*/
export class GatewayEdgeClusterReference {
    /**
    * The reference to VCD Edge Cluster.
    */
    'edgeClusterRef': EntityReference;
    /**
    * The Id of the edge cluster in NSX-T manager. The user should specify the id of NSX-T edge cluster during edge gateway create/update. VCD will automatically create a corresponding VCD Edge cluster object referencing the specified NSX-T edge cluster. For NSX-V Edges, this is set to NULL. 
    */
    'backingId': string;
}

/**
* Describes an IP address currently be used by the edge gateway. The IP belongs to the IPs allocated to the edge. 
*/
export class GatewayUsedIpAddress {
    /**
    * The external network that this IP Address belongs to.
    */
    'networkRef': EntityReference;
    /**
    * The IP address in used.
    */
    'ipAddress': string;
    /**
    * The catagory that an IP can be used for.
    */
    'category': GatewayUsedIpAddressCategory;
}

/**
* The categories that an IP can be used for. 
*/
export class GatewayUsedIpAddressCategory {
}

/**
* Describes Graceful Restart configuration Modes for BGP configuration on an edge gateway. HELPER_ONLY mode is the ability for a BGP speaker to indicate its ability to preserve forwarding state during BGP restart. GRACEFUL_RESTART mode is the ability of a BGP speaker to advertise its restart to its peers. <ul>   <li> DISABLE - Both graceful restart and helper modes are disabled.   <li> HELPER_ONLY - Only helper mode is enabled.   <li> GRACEFUL_AND_HELPER - Both graceful restart and helper modes are enabled. </ul> 
*/
export class GracefulRestartModeTypes {
}

/**
* Set of supported ESXi virtual hardware versions.
*/
export class HardwareVersions {
    'versions': Array<string>;
}

/**
* This configuration captures the IKE and phase one negotiation parameters. This configuration can be set for peering properly with remote peers. 
*/
export class IkeConfig {
    /**
    * IKE Protocol Version to use. The default is IKE_V2.
    */
    'ikeVersion': IkeVersionType;
    /**
    * The list of Diffie-Helman groups to be used is PFS is enabled. Default is GROUP14.
    */
    'dhGroups': Array<DhGroupType>;
    /**
    * The list of Digest algorithms for IKE. This is used during IKE negotiation. Default is SHA2_256.
    */
    'digestAlgorithms': Array<IkeDigestAlgorithmType>;
    /**
    * The list of Encryption algorithms for IKE. This is used during IKE negotiation. Default is AES_128.
    */
    'encryptionAlgorithms': Array<IkeEncryptionAlgorithmType>;
    /**
    * The Security Association life time in seconds. Default is 86400 seconds (1 day).
    */
    'saLifeTime': number;
}

/**
* Digest Algorithms are used to verify message integrity during IKE negotiation. 
*/
export class IkeDigestAlgorithmType {
}

/**
* Encryption algorithms are used to ensure confidentiality of messages exchanged during IKE negotiations. 
*/
export class IkeEncryptionAlgorithmType {
}

/**
* The service status for the IKE Session.
*/
export class IkeServiceStatus {
}

/**
* The status for the IPSec VPN IKE Session/Tunnel. The values are UP, DOWN, and NEGOTIATING. A fail reason is also provided if the Service Status is down. 
*/
export class IkeStatus {
    /**
    * The overall IKE Session service status.
    */
    'ikeServiceStatus': IkeServiceStatus;
    /**
    * The reason for the IKE Session establishment failure. This will only be set if the status is DOWN.
    */
    'failReason': string;
}

/**
* The IKE Protocol version type.
*/
export class IkeVersionType {
}

/**
* An IpRange 
*/
export class IpRange {
    /**
    * Starting IP address in the range.
    */
    'startAddress': string;
    /**
    * Ending IP address in the range.
    */
    'endAddress': string;
}

/**
* List of IpRange 
*/
export class IpRanges {
    'values': Array<IpRange>;
}

/**
* Provides LDAP connection test results 
*/
export class LdapConnectionTestResult {
    /**
    * Flag for whether connection test was successful
    */
    'successful': boolean;
    'error': ModelError;
}

/**
* Defines how a group is imported from LDAP. 
*/
export class LdapGroupAttributesType {
    'objectClass': string;
    'objectIdentifier': string;
    'groupName': string;
    'membership': string;
    'membershipIdentifier': string;
    'backLinkIdentifier': string;
}

/**
* LDAP Settings Specification 
*/
export class LdapSettings {
    'hostName': string;
    'port': number;
    'isSsl': boolean;
    'isSslAcceptAll': boolean;
    'realm': string;
    'pagedSearchDisabled': boolean;
    'pageSize': number;
    'maxResults': number;
    'maxUserGroups': number;
    'searchBase': string;
    'userName': string;
    'password': string;
    'authenticationMechanism': LdapSettings.AuthenticationMechanismEnum;
    'groupSearchBase': string;
    'isGroupSearchBaseEnabled': boolean;
    'connectorType': LdapSettings.ConnectorTypeEnum;
    'userAttributes': LdapUserAttributesType;
    'groupAttributes': LdapGroupAttributesType;
    'useExternalKerberos': boolean;
}

export namespace LdapSettings {
    export enum AuthenticationMechanismEnum {
        SIMPLE = <any> 'SIMPLE',
        KERBEROS = <any> 'KERBEROS',
        M5DIGEST = <any> 'M5DIGEST',
        NTLM = <any> 'NTLM'
    }
    export enum ConnectorTypeEnum {
        ACTIVEDIRECTORY = <any> 'ACTIVE_DIRECTORY',
        OPENLDAP = <any> 'OPEN_LDAP'
    }
}
/**
* Provides test attribute, result, and success boolean 
*/
export class LdapSettingsTestResult {
    /**
    * LDAP attribute being tested
    */
    'attribute': LdapSettingsTestResult.AttributeEnum;
    /**
    * Value of LDAP user attribute being tested
    */
    'attributeValue': string;
    /**
    * Result of LADP user attribute being tested (what LDAP server returned)
    */
    'result': string;
    /**
    * Flag to indicate if the attribute is successful or not
    */
    'successful': boolean;
}

export namespace LdapSettingsTestResult {
    export enum AttributeEnum {
        USEROBJECTIDENTIFIER = <any> 'USER_OBJECT_IDENTIFIER',
        USERNAME = <any> 'USERNAME',
        USEREMAIL = <any> 'USER_EMAIL',
        USERDISPLAYNAME = <any> 'USER_DISPLAY_NAME',
        USERGIVENNAME = <any> 'USER_GIVEN_NAME',
        USERSURNAME = <any> 'USER_SURNAME',
        USERTELEPHONE = <any> 'USER_TELEPHONE',
        GROUPNAME = <any> 'GROUP_NAME',
        GROUPOBJECTIDENTIFIER = <any> 'GROUP_OBJECT_IDENTIFIER'
    }
}
/**
* Provides LDAP connection and settings test results 
*/
export class LdapTestResult {
    'connectionTest': LdapConnectionTestResult;
    'settingsTest': Array<LdapSettingsTestResult>;
}

/**
* Defines how LDAP attributes are used when importing a user. 
*/
export class LdapUserAttributesType {
    'objectClass': string;
    'objectIdentifier': string;
    'userName': string;
    'email': string;
    'fullName': string;
    'givenName': string;
    'surname': string;
    'telephone': string;
    'groupMembershipIdentifier': string;
    'groupBackLinkIdentifier': string;
}

export class Link {
    'attributes': Array<WsAttribute>;
    'href': string;
    'rel': string;
    'type': string;
    'name': string;
}

/**
* A Load Balancer Cloud Backing. 
*/
export class LoadBalancerCloudBacking {
    /**
    * The unique identifier of the Load Balancer Cloud.
    */
    'backingId': string;
    /**
    * The type of Load Balancer Cloud.  Valid values are NSXALB_NSXT.
    */
    'backingType': string;
    /**
    * The managing Load Balancer Controller.
    */
    'loadBalancerControllerRef': EntityReference;
}

/**
* A Load Balancer Controller. 
*/
export class LoadBalancerController {
    /**
    * The id of the Load Balancer Controller in URN format.
    */
    'id': string;
    /**
    * The name of the Load Balancer Controller. Names for Load Balancer Controllers must be unique across the system.
    */
    'name': string;
    /**
    * Description for the registered Load Balancer Controller.
    */
    'description': string;
    /**
    * The URL of the Load Balancer Controller. URLs for Load Balancer Controllers must be unique across the system.
    */
    'url': string;
    /**
    * Username to connect to the Load Balancer Controller.
    */
    'username': string;
    /**
    * Cleartext password to connect to the Load Balancer Controller.
    */
    'password': string;
    /**
    * True if the Load Balancer Controller is enabled for use with vCloud Director.
    */
    'isEnabled': boolean;
    /**
    * The license type of the Load Balancer Controller. <ul> <li>BASIC - Basic edition of the NSX Advanced Load Balancer. <li>ENTERPRISE - Full featured edition of the NSX Advanced Load Balancer. </ul> 
    */
    'licenseType': string;
    /**
    * The version of the load balancer controller.
    */
    'version': string;
}

/**
* An assignment of a Load Balancer Service Engine Group to an Edge Gateway
*/
export class LoadBalancerServiceEngineGroupAssignment {
    /**
    * The identifier of the Load Balancer Service Engine Groups in URN format.
    */
    'id': string;
    /**
    * The maximum number of virtual services the Edge Gateway is allowed to use. This is required if the Load Balancer Service Engine Group has reservation type 'SHARED'. This must be unset if the Load Balancer Service Engine Group has reservation type 'DEDICATED'. 
    */
    'maxVirtualServices': number;
    /**
    * The number of guaranteed virtual services available to the Edge Gateway. This is required if the Load Balancer Service Engine Group has reservation type 'SHARED'. This must be unset if the Load Balancer Service Engine Group has reservation type 'DEDICATED'. 
    */
    'minVirtualServices': number;
    /**
    * The current number of deployed virutal services. 
    */
    'numDeployedVirtualServices': number;
    /**
    * The associated Load Balancer Service Engine Group.
    */
    'serviceEngineGroupRef': EntityReference;
    /**
    * The associated Edge Gateway.
    */
    'gatewayRef': EntityReference;
    /**
    * The owner of the associated Edge Gateway. This can be a vDC or vDC Group.
    */
    'gatewayOwnerRef': EntityReference;
    /**
    * The organization of the associated Edge Gateway.
    */
    'gatewayOrgRef': EntityReference;
}

/**
* A Load Balancer Service Engine Group Backing. 
*/
export class LoadBalancerServiceEngineGroupBacking {
    /**
    * The unique backing identifier of the Load Balancer Service Engine Group.
    */
    'backingId': string;
    /**
    * The associated Load Balancer Cloud.
    */
    'loadBalancerCloudRef': EntityReference;
}

/**
* This represents the endpoint/IP Address on the Edge Gateway where the tunnel needs to be terminated. 
*/
export class LocalEndpoint {
    /**
    * The local identifier for the endpoint.
    */
    'localId': string;
    /**
    * The IPV4 Address for the endpoint. This has to be a suballocated IP on the Edge Gateway. This is required.
    */
    'localAddress': string;
    /**
    * List of local networks. These must be specified in normal Network CIDR format. Specifying no value is interpreted as 0.0.0.0/0.
    */
    'localNetworks': Array<string>;
}

export class LogicalVmGroup {
    /**
    * UUID for LogicalVmGroup. This is immutable. 
    */
    'id': string;
    'description': string;
    /**
    * Display name. 
    */
    'name': string;
    /**
    * List of named vm groups associated with logical vm group. 
    */
    'namedVmGroupReferences': Array<EntityReference>;
    /**
    * URN for Provider vDC. 
    */
    'pvdcId': string;
}

/**
* Error type format displayed to users for exceptions emerging from openapi endpoints. 
*/
export class ModelError {
    'minorErrorCode': string;
    'message': string;
    'stackTrace': string;
}

/**
* The Nat Rule Type for a given NAT rule. 
*/
export class NatRuleType {
}

/**
* A network Object. 
*/
export class Network {
    /**
    * The unique ID for the network. This field is read-only.
    */
    'id': string;
    /**
    * The name of the network.
    */
    'name': string;
    /**
    * The description of the network.
    */
    'description': string;
    /**
    * List of subnets configured for the network.
    */
    'subnets': Subnets;
}

/**
* Describes an attribute of a networking context profile. An attribute is defined as a type and its associated values for some layer 7 App Id or Domain names. 
*/
export class NetworkContextProfileAttribute {
    /**
    * This describes the type of attribute value. <ul>   <li> APP_ID - Values represents layer 7 App Ids. For example: ACTIVDIR   <li> DOMAIN_NAME - Values represents Domain names (FQDN). For example: *.live.com </ul> 
    */
    'type': NetworkContextProfileAttribute.TypeEnum;
    /**
    * Values for attribute.
    */
    'values': Array<string>;
    /**
    * List of sub attributes for an attribute. These are specified with the attributes such as SSL or CIFS, which can have different cipher suites or TLS versions as values. 
    */
    'subAttributes': Array<NetworkContextProfileSubAttribute>;
}

export namespace NetworkContextProfileAttribute {
    export enum TypeEnum {
        APPID = <any> 'APP_ID',
        DOMAINNAME = <any> 'DOMAIN_NAME'
    }
}
/**
* A wrapper object for an array of network context profile attributes. 
*/
export class NetworkContextProfileAttributes {
    /**
    * Array of network context profile attributes.
    */
    'attributes': Array<NetworkContextProfileAttribute>;
}

/**
* The scope of a network context profile. <ul> <li><code>SYSTEM</code> profiles are available to all tenants. They are default profiles from the backing networking provider. <li><code>PROVIDER</code> profiles are available to all tenants. They are defined by the provider at a system level. <li><code>TENANT</code> profiles are available only to the specific tenant organization. They are defined by the tenant or by a provider on behalf of a tenant. </ul> 
*/
export class NetworkContextProfileScopeType {
}

/**
* Describes a sub attribute of a networking context profile attribute. 
*/
export class NetworkContextProfileSubAttribute {
    /**
    * This describes the type of sub attribute's values.
    */
    'type': NetworkContextProfileSubAttribute.TypeEnum;
    /**
    * Values for sub attribute.
    */
    'values': Array<string>;
}

export namespace NetworkContextProfileSubAttribute {
    export enum TypeEnum {
        TLSCIPHERSUITE = <any> 'TLS_CIPHER_SUITE',
        TLSVERSION = <any> 'TLS_VERSION',
        CIFSSMBVERSION = <any> 'CIFS_SMB_VERSION'
    }
}
/**
* Describes the backing information for a network pool. A network pool is backed by vSphere network resources such as VLAN Ids, portgroups, Transport Zones, etc. 
*/
export class NetworkPoolBacking {
    /**
    * The range of backing VLAN Id's. This information is available only for VLAN backed network pools. 
    */
    'vlanIdRanges': VlanIdRanges;
    /**
    * The information about virtual distributed switches. This information is available only for VLAN, VXLAN and Universal VXLAN backed network pools. 
    */
    'vdsRefs': Array<BackingRef>;
    /**
    * All the vSphere port groups that will be used by this network pool. This information is available only for Portgroup backed network pools. 
    */
    'portGroupRefs': Array<BackingRef>;
    /**
    * The Id of the backing transport zone in NSX. 
    */
    'transportZoneRef': BackingRef;
    /**
    * The Id of vCenter server or the NSX-T manager that owns this backing entity.
    */
    'providerRef': EntityReference;
}

/**
* Represents the network pool's backing type. 
*/
export class NetworkPoolBackingType {
}

/**
* Describes the network provider context of the network object.
*/
export class NetworkProviderContext {
    /**
    * The organization that this object belongs to. This property is required during creation and cannot be updated. 
    */
    'orgRef': EntityReference;
    /**
    * The context under which this object is created. The context can the id of the organization vDC, vDC Group, or network provider. This field is required on object creation and is unset on object reads. This same context ID can be used in the context filter field when querying for the list of objects. 
    */
    'contextEntityId': string;
    /**
    * The network provider scope that this object belongs to. This is a read-only property and is determined by the input context entity ID during object creation. 
    */
    'networkProviderScope': string;
}

/**
* A candidate vDC that can be added to a vDC Group. 
*/
export class NetworkingCandidateVdc {
    /**
    * The id of the candidate vDC.
    */
    'id': string;
    /**
    * The name of the candidate vDC.
    */
    'name': string;
    /**
    * The reference to the organization this vDC is in.
    */
    'orgRef': EntityReference;
    /**
    * The site ID that this vDC belongs to.
    */
    'siteRef': EntityReference;
    /**
    * The network provider scope of the vDC.
    */
    'networkProviderScope': string;
    /**
    * Represents the fault domain of a given organization vDC. For NSX_V backed organization vDCs, this is the network provider scope. For NSX_T backed organization vDCs, this can vary (for example name of the provider vDC or compute provider scope). 
    */
    'faultDomainTag': string;
}

/**
* Represents status of a networking entity. 
*/
export class NetworkingObjectStatus {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
}

/**
* Represents status type of a networking entity. <ul>   <li> PENDING - Desired entity configuration has been received by system and is pending realization.   <li> CONFIGURING - The system is in process of realizing the entity.   <li> REALIZED - The entity is successfully realized in the system.   <li> REALIZATION_FAILED - There are some issues and the system is not able to realize the entity.   <li> UNKNOWN - Current state of entity is unknown. </ul> 
*/
export class NetworkingObjectStatusType {
}

/**
* An NSX-ALB Controller's Cloud. 
*/
export class NsxAlbCloud {
    /**
    * The unique id of the cloud.
    */
    'id': string;
    /**
    * Name of the Cloud used in NSX-ALB Controller's logs or GUI.
    */
    'displayName': string;
    /**
    * True if the Cloud is already imported. Cloud cannot be imported again.
    */
    'alreadyImported': boolean;
    /**
    * The Network Pool associated with this Cloud. If unset, this Cloud cannot be imported.
    */
    'networkPoolRef': EntityReference;
    /**
    * Name of the transport zone in NSX-T associated with the NSX-ALB Cloud. If unset, the tranport zone associated with the Load Balancer Cloud is not found in NSX-T. 
    */
    'transportZoneName': string;
}

/**
* An NSX-ALB Cloud's Service Engine Group 
*/
export class NsxAlbServiceEngineGroup {
    /**
    * The unique id of the service engine group.
    */
    'id': string;
    /**
    * Name of the service engine group used in NSX-ALB Controller's logs or GUI.
    */
    'displayName': string;
    /**
    * The service engine group's High Availability Mode. ELASTIC_N_PLUS_M_BUFFER - Service Engines will scale out to N active nodes with M nodes as buffer. ELASTIC_ACTIVE_ACTIVE - Active-Active with scale out. LEGACY_ACTIVE_STANDBY - Traditional single Active-Standby configuration 
    */
    'haMode': string;
}

/**
* List of NSX-ALB Cloud's Service Engine Groups 
*/
export class NsxAlbServiceEngineGroups {
    'values': Array<NsxAlbServiceEngineGroup>;
}

/**
* Information about a configured edge cluster on an NSX-T manager. An Edge cluster is a group of edge transport nodes. 
*/
export class NsxTEdgeCluster {
    /**
    * The unique id of the edge cluster on the NSX-T manager.
    */
    'id': string;
    /**
    * Name of edge cluster.
    */
    'name': string;
    /**
    * Description of the edge cluster.
    */
    'description': string;
    /**
    * Number of edge transport nodes in the edge cluster.
    */
    'nodeCount': number;
    /**
    * Type of transport nodes in the edge cluster. All the nodes in the edge cluster are of same type. 
    */
    'nodeType': NsxTEdgeClusterNodeType;
    /**
    * Deployment type for transport nodes in the edge cluster. The nodes in the edge cluster may have different deployment types. 
    */
    'deploymentType': NsxTEdgeClusterDeploymentType;
}

/**
* Represents the deployment type for an edge cluster. This is derived from the deplyment type of the nodes in an edge cluster. If all the edge nodes are of same type then that type is returned, otherwise if the cluster contains nodes with different deployment types then HYBRID is returned. 
*/
export class NsxTEdgeClusterDeploymentType {
}

/**
* Represents the type of transport nodes in an edge cluster. All of the transport nodes in an edge cluster must belong to the same type. 
*/
export class NsxTEdgeClusterNodeType {
}

/**
* List of edge clusters configured on an NSX-T manager. 
*/
export class NsxTEdgeClusters {
    'values': Array<NsxTEdgeCluster>;
}

/**
* Information about a configured transport zone on an NSX-T manager. NSX uses transport zones to provide connectivity between hypervisors. 
*/
export class NsxTTransportZone {
    /**
    * The unique id of the transport zone on the NSX-T manager.
    */
    'id': string;
    /**
    * Name of Transport Zone in NSX-T Manager.
    */
    'name': string;
    /**
    * Type of a transport zone.
    */
    'type': NsxTTransportZoneType;
}

/**
* Represents an NSX-T transport zone's traffic type. 
*/
export class NsxTTransportZoneType {
}

/**
* List of transport zones configured on an NSX-T manager. 
*/
export class NsxTTransportZones {
    'values': Array<NsxTTransportZone>;
}

/**
* An object representing an NSX-V server. 
*/
export class NsxVManager {
    /**
    * User name to connect to the NSX-V server.
    */
    'username': string;
    /**
    * Cleartext password to connect to the NSX-V server.
    */
    'password': string;
    /**
    * URL of the server.
    */
    'url': string;
    /**
    * Version of the NSX-V Manager
    */
    'softwareVersion': string;
}

/**
* An object representing networking configuration of a vCenter server. 
*/
export class NsxVManagerSettings {
    /**
    * URN of the associated vCenter server.
    */
    'vcId': string;
    /**
    * Public label of this NSX server visible to all tenants.
    */
    'networkProviderScope': string;
    /**
    * Path to the resource pool to use for creating Control VM for Cross-VDC Networking.
    */
    'controlVmResourcePoolVcPath': string;
    /**
    * Name of the Datastore to use for creating Control VM for Cross-VDC Networking.
    */
    'controlVmDatastoreName': string;
    /**
    * Name of the management interface to use for creating Control VM for Cross-VDC Networking.
    */
    'controlVmManagementInterfaceName': string;
}

/**
* Information about a configured transport zone on an NSX-V manager. NSX uses transport zones to provide connectivity between hypervisors. 
*/
export class NsxVTransportZone {
    /**
    * The unique id of the transport zone on the NSX manager.
    */
    'id': string;
    /**
    * Name of Transport Zone in NSX Manager.
    */
    'name': string;
    /**
    * Type of a transport zone.
    */
    'type': NsxVTransportZoneType;
}

/**
* Represents an NSX-V transport zone's traffic type. 
*/
export class NsxVTransportZoneType {
}

/**
* List of transport zones configured on an NSX-V manager. 
*/
export class NsxVTransportZones {
    'values': Array<NsxVTransportZone>;
}

/**
* Specifies the list of domains and the DNS servers that handle those domains.
*/
export class NsxtDnsForwarderZoneConfig {
    /**
    * The unique id of the DNS forwarder zone. If value is unset, a new zone is created. If value is set, an update is done on the zone. 
    */
    'id': string;
    /**
    * User friendly name for the zone.
    */
    'displayName': string;
    /**
    * List of domain names on which conditional forwarding is based. This field is required if the DNS Zone is being used for a conditional forwarder. This field will also be used for conditional reverse lookup. This field should not be set if the zone is used as default forwarder zone. 
    */
    'dnsDomainNames': Array<string>;
    /**
    * DNS servers to which the DNS request needs to be forwarded.
    */
    'upstreamServers': Array<string>;
}

/**
* This property describes the current version of the entity. To prevent clients from overwriting each other's changes, update operations must include the version which can be obtained by issuing a GET operation. If the version number on an update call is missing, the operation will be rejected. This is only needed on update calls. 
*/
export class ObjectVersion {
    /**
    * version number for the given entity.
    */
    'version': number;
}

/**
* An Organization. 
*/
export class Org {
    /**
    * A unique identifier for the organization.
    */
    'id': string;
    /**
    * Name of the organization.
    */
    'name': string;
    /**
    * Full display name of the organization.
    */
    'displayName': string;
    /**
    * Description of the organization.
    */
    'description': string;
    /**
    * Whether the organization is enabled or not.
    */
    'isEnabled': boolean;
}

/**
* An object representing an Organization Virtual Datacenter in VCD.
*/
export class OrgVdc {
    /**
    * A unique identifier for the vdc.
    */
    'id': string;
    /**
    * The name of the vdc.
    */
    'name': string;
    /**
    * The description of the vdc.
    */
    'description': string;
    /**
    * The allocation type of the vdc, one of:   ALLOCATION_VAPP,   ALLOCATION_POOL,   RESERVATION_POOL,   FLEX 
    */
    'allocationType': string;
    /**
    * The reference to the organization that the VDC belongs to
    */
    'org': EntityReference;
}

/**
* Represents status of a Org Vdc network. This value will be PENDING if the network has been recorded by VCD but has not been fully configured, CONFIGURING if the network is in transition, REALIZED if the existing state of the network has been fully realized, or REALIZED_FAILED if there was an error creating the network. 
*/
export class OrgVdcNetworkStatus {
}

/**
* Overall status of the entity
*/
export class OverallStatus {
}

/**
* Collection of paging-related metadata to be included by composition via allOf. This type should be included in pageable responses to avoid duplicating these common properties. It is intended to be included by composition rather than inheritance. Because of this, it has no discriminator and should be embedded via allOf. See QueryResults for a reference usage. 
*/
export class Page {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
}

export class Parameter {
    'inputType': string;
}

export class ParameterTypes {
    'sdkObject': SdkObject;
    'string': StringParam;
    'secureString': SecureString;
    'number': NumberParam;
    'mimeAttachment': MimeAttachment;
    'properties': Properties;
    'date': DateParam;
    'boolean': BooleanParam;
    'composite': CompositeType;
    'regex': Regex;
    'encryptedString': EncryptedString;
    'keyValuePair': KeyValuePair;
    'compositeValue': CompositeValue;
    'array': ArrayParam;
}

/**
* A participating vDC 
*/
export class ParticipatingVdcReference {
    /**
    * The reference to the vDC that is part of this a vDC group.
    */
    'vdcRef': EntityReference;
    /**
    * Read-only field that specifies what organization this vDC is in.
    */
    'orgRef': EntityReference;
    /**
    * The site ID that this vDC belongs to. Required for universal vDC groups.
    */
    'siteRef': EntityReference;
    /**
    * Read-only field that specifies the network provider scope of the vDC.
    */
    'networkProviderScope': string;
    /**
    * Represents the fault domain of a given organization vDC. For NSX_V backed organization vDCs, this is the network provider scope. For NSX_T backed organization vDCs, this can vary (for example name of the provider vDC or compute provider scope). 
    */
    'faultDomainTag': string;
    /**
    * Read-only field that specifies whether the vDC is local to this VCD site.
    */
    'remoteOrg': boolean;
    /**
    * The status that the vDC can be in. An example is if the vDC has been deleted from the system but is still part of the group.
    */
    'status': VdcGroupEntityStatus;
}

/**
* Standard portgroup. 
*/
export class PortGroup {
    /**
    * Contains the backing id and name of the standard portgroup.
    */
    'backingRef': BackingRef;
    /**
    * The entity reference for the vCenter that contains this portgroup.
    */
    'virtualCenter': EntityReference;
}

export class Preference {
    /**
    * unique indetifier for this preference definition. It will be of type <scope>:<name>. e.g vrops:myworkflow. This is immutable 
    */
    'classifier': string;
    /**
    * Display name. This is same as preference definition name and is immutable. 
    */
    'name': string;
    'value': string;
}

/**
* The Preference Definition is immutable. 
*/
export class PreferenceDefinition {
    /**
    * UUID for preference definition. This is immutable. 
    */
    'id': string;
    /**
    * Display name. 
    */
    'name': string;
    /**
    * Description for user preference 
    */
    'description': string;
    /**
    * unique indetifier for this preference definition. It should be of type <scope>:<name>. e.g vrops:myworkflow. This is immutable. 
    */
    'classifier': string;
    /**
    * user preference value data type. This is immutable. 
    */
    'dataType': PreferenceDefinition.DataTypeEnum;
    /**
    * true if user preference is selected from list of values (dataType should be number or string), false otherwise. This is immutable. 
    */
    'constrained': boolean;
    /**
    * minimum value for user preference. Only valid if user preference type is number. This is immutable. 
    */
    'minValue': number;
    /**
    * maximum value for user preference. Only valid if user preference type is number. This is immutable. 
    */
    'maxValue': number;
    'defaultValue': string;
    /**
    * array of allowed values to select from when constrained is true.. This is immutable after creation.
    */
    'allowedValues': Array<string>;
}

export namespace PreferenceDefinition {
    export enum DataTypeEnum {
        BOOLEAN = <any> 'BOOLEAN',
        INTEGER = <any> 'INTEGER',
        STRING = <any> 'STRING'
    }
}
export class Presentation {
    'description': string;
    'id': string;
    'vroId': string;
    'inputParameters': Array<WsParameter>;
    'name': string;
    'outputParameters': Array<WsParameter>;
    'steps': Array<StepInfo>;
}

export class PresentationElement {
    'elementType': string;
    'description': string;
    'displayName': string;
    'hidden': boolean;
    'id': string;
    'messages': Array<PresentationMessageInfo>;
}

export class PresentationExecution {
    'description': string;
    'id': string;
    'name': string;
    'objectId': string;
    'parameters': Array<WsParameter>;
    'startDate': Date;
    'startedBy': string;
    'steps': Array<StepInfo>;
    'valid': boolean;
}

export class PresentationExecutionsList {
    'total': number;
    'executions': Array<ExecutionSummary>;
    'start': number;
}

export class PresentationMessageInfo {
    'code': string;
    'details': string;
    'severity': PresentationMessageInfo.SeverityEnum;
    'summary': string;
}

export namespace PresentationMessageInfo {
    export enum SeverityEnum {
        INFO = <any> 'INFO',
        WARNING = <any> 'WARNING',
        ERROR = <any> 'ERROR'
    }
}
/**
* Results of a connection test to a specific endpoint. 
*/
export class ProbeResult {
    /**
    * Localized message describing the connection result stating success or an error message with a brief summary.
    */
    'result': string;
    /**
    * The IP address the host was resolved to.
    */
    'resolvedIp': string;
    /**
    * If vCD can establish a connection on the specified port.
    */
    'canConnect': boolean;
    /**
    * If an SSL Handshake succeeded (secure requests only).
    */
    'sslHandshake': boolean;
    /**
    * The SSL certificate chain presented by the server if a secure connection was made.
    */
    'certificateChain': string;
}

/**
* A provider vdc. 
*/
export class ProviderVdc {
    /**
    * A unique identifier for the pvdc.
    */
    'id': string;
    /**
    * The name of the pvdc.
    */
    'name': string;
    /**
    * The description of the pvdc.
    */
    'description': string;
    /**
    * Whether the pvdc is enabled or not.
    */
    'isEnabled': boolean;
    /**
    * The maximum hardware version this pvdc supports.
    */
    'maxSupportedHwVersion': string;
    /**
    * The NSX-T manager of the pvdc, if any.
    */
    'nsxTManager': EntityReference;
    /**
    * The vCenter server the pvdc belongs to.
    */
    'vimServer': EntityReference;
}

/**
* proxy configuration. This configures the vCD proxying capability for one specific server within the vSphere/NSX/ESX estate known to vCD. 
*/
export class Proxy {
    'name': string;
    'id': string;
    /**
    * The EntityReference of the parent entity (e.g. vCenter Server, SDDC) . This is not editable once the proxy has been created.
    */
    'parent': EntityReference;
    'proxyType': Proxy.ProxyTypeEnum;
    /**
    * True if the proxy is enabled. Proxy can only be enabled/disabled by privileged users. A disabled proxy cannot be activated and thus, cannot be used. When a proxy is disabled, all active sessions are terminated. 
    */
    'enabled': boolean;
    /**
    * Whether this proxy has been published to tenants.
    */
    'tenantVisible': boolean;
    /**
    * True if the proxy is currently active for the user session associated with the request made to get the proxy. An inactive proxy cannot be used. 
    */
    'active': boolean;
    /**
    * The generated read-only token that should be used as the password when using this proxy. To generate a new token, activate the proxy. The token is tied to the user session that activated the proxy. If the proxy is inactive, this value will be null. 
    */
    'token': string;
    /**
    * The EntityReference of the parent proxy. If a proxy has a parent, the proxy is activated along with its parent and shares the token with its parent. Each proxy may only have one parent. A parent proxy cannot have a parent of its own. 
    */
    'parentProxy': EntityReference;
    /**
    * IP address or FQDN of the host being proxied. This is not editable once the proxy has been created.
    */
    'targetHost': string;
    /**
    * The URL of the proxied component's UI endpoint. This is the URL that the browser tab  will be pointed to when the proxy is launched via the H5 UI of VCD. 
    */
    'uiUrl': string;
}

export namespace Proxy {
    export enum ProxyTypeEnum {
        VC = <any> 'VC',
        SSO = <any> 'SSO',
        NSX = <any> 'NSX',
        ESX = <any> 'ESX',
        GENERIC = <any> 'GENERIC'
    }
}
/**
* A Proxy Configuration. This configuration object declares a backend proxy that sits between vCD and the vSphere/NSX/ESX estate. 
*/
export class ProxyConfiguration {
    'name': string;
    'id': string;
    /**
    * Optional description.
    */
    'description': string;
    'authType': ProxyConfiguration.AuthTypeEnum;
    /**
    * username to connect to the proxy server.
    */
    'username': string;
    /**
    * password to connect to the proxy server, when auth type is Basic.
    */
    'password': string;
    /**
    * authentication token to connect to the proxy server, when auth type is Bearer.
    */
    'token': string;
    /**
    * hostname of the proxy server.
    */
    'host': string;
    /**
    * port of the proxy server.
    */
    'port': number;
}

export namespace ProxyConfiguration {
    export enum AuthTypeEnum {
        BASIC = <any> 'BASIC',
        BEARER = <any> 'BEARER'
    }
}
/**
* Proxy connection to use for test. If none is specified, then no proxy is used to test the connection. 
*/
export class ProxyConnection {
    /**
    * The host (or IP address) of the proxy.
    */
    'proxyHost': string;
    /**
    * The port to use when connecting to the proxy.
    */
    'proxyPort': number;
    /**
    * Username to authenticate to the proxy.
    */
    'proxyUsername': string;
    /**
    * Password to authenticate to the proxy.
    */
    'proxyPassword': string;
    /**
    * If the connection to the proxy should use https.
    */
    'proxySecure': boolean;
}

export class PvdcComputePolicy {
    /**
    * UUID for pVDC compute policy. This is immutable. 
    */
    'id': string;
    /**
    * Display name. 
    */
    'name': string;
    'description': string;
    /**
    * URN for Provider VDC. If not provided, then this policy is considered Global. 
    */
    'pvdcId': string;
    /**
    * This field cannot be updated and is a read-only field in the client after creation. Deprecated in Api 33.0, this property will be removed in future release. 
    */
    'namedVmGroupReferences': Array<EntityReference>;
    /**
    * List of list of vmGroups grouped together in a meaningful manner. A group of vmGroups would consist of one functionally equal vmGroup picked from each cluster of the pvdc. 
    */
    'namedVmGroups': Array<Array<EntityReference>>;
    /**
    * This field cannot be updated and is a read-only field after creation. 
    */
    'logicalVmGroupReferences': Array<EntityReference>;
}

/**
* Pvdc compute policy that contains PVDC specific configuration for workloads. (Version 2.0.0) 
*/
export class PvdcComputePolicy2 {
    /**
    * UUID for pVDC compute policy. This is immutable. 
    */
    'id': string;
    /**
    * Display name. 
    */
    'name': string;
    /**
    * The discriminator type is used to differentiate among various sub policy types. 
    */
    'policyType': string;
    'description': string;
    /**
    * URN for Provider vDC. If not provided, then this policy is considered Global. 
    */
    'pvdcId': string;
}

export class QuotaPolicy {
    /**
    * URN for quota policy. This is immutable. 
    */
    'id': string;
    'description': string;
    /**
    * Display name for the quota policy. 
    */
    'name': string;
    /**
    * URN of org in which this policy is created. This is immutable 
    */
    'orgId': string;
    /**
    * A list of quota pool definitions.
    */
    'quotaPoolDefinitions': Array<QuotaPoolDefinition>;
    /**
    * This field cannot be updated and is a read-only field in the client. It defines if the quota policy is auto-generated. 
    */
    'isAutoGenerated': boolean;
}

export class QuotaPoolDefinition {
    /**
    * The localized name of quota resource type. 
    */
    'quotaResourceName': string;
    /**
    * The quota resource type such as memory, cpu, vm etc. Available resource types: memory, cpu, storage, urn:vcloud:legacy:vm, urn:vcloud:type:vmware.tkgcluster:1.0.0 
    */
    'resourceType': string;
    /**
    * The unit of quota defined for quota resource type. Available quota units for resource types: memory - MB cpu - MHz storage - MB urn:vcloud:legacy:vm - count 
    */
    'quotaResourceUnit': string;
    /**
    * The quota amount for this resource. 
    */
    'quota': number;
    /**
    * The qualifiers for quota resource type, such as vm.guestOs == Windows. This is optional. Qualifiers just helps in narrowing down quota resource based on values of one or more of its properties. If vm is a quota resource, from the above example, only VMs with Windows guest OS will be considered for quota eligibility. If more than one qualifier is provided, system will use AND operator to process them. 
    */
    'qualifiers': Array<string>;
}

/**
* A list of quota pools. 
*/
export class Quotas {
    'quotaPools': Array<QuotasQuotaPools>;
}

export class QuotasQuotaPools {
    /**
    * The quota policy that enforced this quota. 
    */
    'enforcingQuotaPolicy': EnforcingQuotaPolicy;
    /**
    * The quota pool definition used for the consumed quota resource. 
    */
    'quotaPoolDefinition': QuotaPoolDefinition;
    /**
    * The quota amount consumed for this resource. This field is conditional and for group quotas it is not returned. 
    */
    'quotaConsumed': number;
}

export class Relations {
    'total': number;
    'link': Array<Link>;
    'start': number;
}

/**
* This represents the remote endpoint i.e. the endpoint which the tunnel from the Edge Gateway will connect to. 
*/
export class RemoteEndpoint {
    /**
    * This Remote ID is needed to uniquely identify the peer site. If this tunnel is using PSK authentication, the Remote ID is the public IP Address of the remote device terminating the VPN Tunnel. When NAT is configured on the Remote ID, enter the private IP Address of the Remote Site. If the remote ID is not set, VCD will set the remote id to the remote address. If this tunnel is using certificate authentication, enter the distinguished name of the certificate used to secure the remote endpoint (for example, C=US,ST=Massachusetts,O=VMware,OU=VCD,CN=Edge1). The remote id must be provided in this case. 
    */
    'remoteId': string;
    /**
    * IPV4 Address of the remote endpoint on the remote site. This is the Public IPv4 Address of the remote device terminating the VPN connection.
    */
    'remoteAddress': string;
    /**
    * List of remote networks. These must be specified in normal Network CIDR format. Specifying no value is interpreted as 0.0.0.0/0
    */
    'remoteNetworks': Array<string>;
}

/**
* A vCenter Resource Pool. 
*/
export class ResourcePool {
    /**
    * The vCenter Id of the Resource Pool. It must be in the format (resgroup-#).
    */
    'moref': string;
    /**
    * The name of the Resource Pool.
    */
    'name': string;
    /**
    * The vCenter the Resource Pool belongs to.
    */
    'vcId': string;
    /**
    * Used in resource pool tree navigation. Indicates whether the resource pool is eligible or not. 
    */
    'eligible': boolean;
    /**
    * Indicates whether the resource pool's cluster is enabled for vSphere Kubernetes. 
    */
    'kubernetesEnabled': boolean;
}

/**
* Kubernetes configuration for a resource pool backed by kubernetes enabled cluster. 
*/
export class ResourcePoolKubernetesConfig {
    /**
    * Endpoint for the kubernetes enabled cluster backed by this Resource Pool. 
    */
    'controlPlaneEndpoint': string;
}

/**
* Right 
*/
export class Right {
    'name': string;
    'id': string;
    'description': string;
    'bundleKey': string;
    'category': string;
    'serviceNamespace': string;
    'rightType': Right.RightTypeEnum;
    /**
    * The set of implied rights.
    */
    'impliedRights': Array<EntityReference>;
}

export namespace Right {
    export enum RightTypeEnum {
        VIEW = <any> 'VIEW',
        MODIFY = <any> 'MODIFY'
    }
}
/**
* RightsCategoryNode 
*/
export class RightsCategoryNode {
    'name': string;
    'id': string;
    'bundleKey': string;
    'parent': string;
    'rightsCount': RightsCount;
    'subCategories': Array<string>;
}

/**
* RightsCount - A count of rights in a given category by type 
*/
export class RightsCount {
    'view': number;
    'modify': number;
}

/**
* RightsMapping 
*/
export class RightsMapping {
    'name': string;
    'id': string;
    'description': string;
    'bundleKey': string;
    'readOnly': boolean;
}

/**
* List of subnets that will be advertised so that the Edge Gateway can route out to the connected external network. 
*/
export class RouteAdvertisement {
    /**
    * True means that the subnets will be advertised. The default is true.
    */
    'enable': boolean;
    /**
    * List of subnets that will be advertised so that the Edge Gateway can route out to the connected external network. Each value is in CIDR format. Note that the CIDR value will automatically be converted to its network definition based on the prefix length. 
    */
    'subnets': Array<string>;
}

/**
* A ComponentHealth object 
*/
export class RouterComponentHealth {
    'component': string;
    'status': RouterComponentStatus;
    'message': string;
    'action': string;
    'code': number;
}

/**
* Status of a router component. 
*/
export class RouterComponentStatus {
}

/**
* Describes the connection between a routed network and an edge gateway. This must be set if converting from an isolated to a routed network. 
*/
export class RouterConnection {
    /**
    * The edge gateway that this network is attached to.
    */
    'routerRef': EntityReference;
    /**
    * How the network is connected to the edge gateway. This field is updatable to allow conversions between different types. If owner is a VDC group that is backed by a NSX-V network provider, this field does not need to be set. The organization VDC network will be automatically connected to the distributed router associated with the VDC group. 
    */
    'connectionType': VdcNetworkConnectionType;
    /**
    * Whether network is marked as connected in NSX.
    */
    'connected': boolean;
}

/**
* A RouterDnsConfig object 
*/
export class RouterDnsConfig {
    'enabled': boolean;
    'nameServers': Array<string>;
}

/**
* Health Report of a Router 
*/
export class RouterHealthReport {
    /**
    * Status of all the nsx managers spanned by the universal router. 
    */
    'nsxManagersHealth': Array<RouterComponentHealth>;
    /**
    * Status of all the universal router control VMs within each network provider scope. This also includes status of egress points and routes configured for the universal router. 
    */
    'controlVmHealth': Array<RouterComponentHealth>;
    /**
    * Status of the nsx controller cluster associated with the nsx managers. 
    */
    'controlPlaneHealth': RouterComponentHealth;
    /**
    * Reachability status for local and remote participating vDC's of referenced vDC group. States whether a vDC is reachable from this local site. 
    */
    'vdcReachabilityStatus': Array<RouterComponentHealth>;
}

/**
* The DNS settings for this SLAAC profile.
*/
export class SLAACDnsConfig {
    /**
    * The list of domain names used as nameservers to configure on virtual machines connected to the gateway this profile is associated with. 
    */
    'domainNames': Array<string>;
    /**
    * The IP addresses of the DNS servers to be configured on virtual machines connected to the network using this profile. They must be valid IPv6 addresses. 
    */
    'dnsServerIpv6Addresses': Array<string>;
}

/**
* The SLAAC profile containing the mode, the DNS configuration settings, and whether or not it is enabled. Only NSX-T edge gateways support a SLAAC profile.
*/
export class SLAACProfile {
    /**
    * A flag indicating whether or not this profile is enabled.
    */
    'enabled': boolean;
    /**
    * Represents the various modes with which to configure SLAAC with. Supported values are SLAAC and DHCPv6. 
    */
    'mode': string;
    'dnsConfig': SLAACDnsConfig;
}

/**
* Software-defined data center 
*/
export class Sddc {
    'name': string;
    'id': string;
    'description': string;
    'enabled': boolean;
    /**
    * URN of the associated vCenter. This is not editable once the SDDC has been created.
    */
    'vcId': string;
    /**
    * Version of the associated vCenter. This is not editable.
    */
    'version': string;
    /**
    * Overall status of the associated vCenter. This is not editable.
    */
    'overallStatus': OverallStatus;
    /**
    * Associated read-only statistics.
    */
    'stats': SddcStats;
    /**
    * Default proxy for the SDDC. This field is read-only. To set a new default, edit the proxy you wish to make the new default by modifying its defaultProxy flag. Deprecated in Api 34.0. 
    */
    'defaultProxy': SddcProxy;
    /**
    * Default endpoint for the SDDC. There is an endpoint available for an SDDC even if there are no proxies configured for the SDDC. This indicates that an endpoint is available that doesn't require proxying, either because it is publicly accessible or because it assumes an established VPM connection. The field is read-only. 
    */
    'defaultEndpoint': SddcEndpoint;
}

/**
* An available network connections exposed by the SDDC
*/
export class SddcEndpoint {
    'name': string;
    'id': string;
    /**
    * A network endpoint that the SDDC exposes for communication.Deprecated in Api 35.0.
    */
    'endpoint': string;
    /**
    * The URL target of the SDDC endpoint. This is the URL that the browser tab  will be pointed to when the endpoint is launched via the H5 UI of VCD. 
    */
    'targetUrl': string;
    /**
    * A reference to an optional Proxy that can be used to establish a connection to the endpoint
    */
    'proxy': EntityReference;
    /**
    * The EntityReference of the parent SDDC entity. This is not editable once the endpoint has been created.
    */
    'sddc': EntityReference;
    /**
    * True if this is the default endpoint for the parent SDDC. An endpoint being the default for the SDDC means that this endpoint's target will be launched when the SDDC tile is clicked in the H5 Tenant UI of VCD. 
    */
    'isDefault': boolean;
}

/**
* SDDC proxy configuration 
*/
export class SddcProxy {
    'name': string;
    'id': string;
    /**
    * URN of the parent SDDC. This is not editable once the proxy has been created.
    */
    'sddcId': string;
    /**
    * True if the proxy is enabled. Proxy can only be enabled/disabled by privileged users. A disabled proxy cannot be activated and thus, cannot be used. When a proxy is disabled, all active sessions are terminated. 
    */
    'enabled': boolean;
    /**
    * Whether this proxy has been published to tenants.
    */
    'tenantVisible': boolean;
    /**
    * IP address or FQDN of the host being proxied. This is not editable once the proxy has been created.
    */
    'targetHost': string;
    /**
    * True if the proxy is currently active for the user session associated with the request made to get the proxy. An inactive proxy cannot be used. 
    */
    'active': boolean;
    /**
    * The generated read-only token that should be used as the password when using this proxy. To generate a new token, activate the proxy. The token is tied to the user session that activated the proxy. If the proxy is inactive, this value will be null. 
    */
    'token': string;
    /**
    * True if this is the default proxy for the parent SDDC. A proxy being the default for the SDDC means that this proxy's UI will be launched when the SDDC tile is clicked in the H5 Tenant UI of VCD. If no default proxy is set, clicking the SDDC tile will be a no-op. 
    */
    'defaultProxy': boolean;
    /**
    * The URN of the parent proxy. If a proxy has a parent, the proxy is activated along with its parent and shares the token with its parent. Each proxy may only have one parent. A parent proxy cannot have a parent of its own. 
    */
    'parentProxyId': string;
    /**
    * The URL of the proxied component's UI endpoint. This is the URL that the browser tab  will be pointed to when the proxy is launched via the H5 UI of VCD. 
    */
    'uiUrl': string;
}

/**
* A collection of measurements for the SDDC resource 
*/
export class SddcStat {
    /**
    * Total resource allocation.
    */
    'numTotal': number;
    /**
    * Used resource allocation.
    */
    'numUsed': number;
    /**
    * Reserved resource allocation.
    */
    'numReserved': number;
}

/**
* A read-only list of resource allocations for the associated SDDC 
*/
export class SddcStats {
    /**
    * Number of VMs within the SDDC.
    */
    'totalVMs': number;
    /**
    * Number of powered on VMs within the SDDC.
    */
    'poweredOnVMs': number;
    /**
    * CPUs statistics of the SDDC (values in MHz).
    */
    'cpu': SddcStat;
    /**
    * Memory statistics of the SDDC (values in MB).
    */
    'memory': SddcStat;
    /**
    * Storage statistics of the SDDC (values in MB).
    */
    'storage': SddcStat;
}

export class Service {
    'name': string;
    'description': string;
    'iconMimeType': string;
    'iconData': string;
    'id': string;
}

/**
* A VMware service application 
*/
export class ServiceApp {
    /**
    * The unique ID for the service application. This field is read-only.
    */
    'id': string;
    /**
    * The name of the service application
    */
    'name': string;
    /**
    * The client ID
    */
    'clientId': string;
    /**
    * The client secret
    */
    'clientSecret': string;
    /**
    * The external organization id of the service application
    */
    'orgId': string;
    /**
    * The scope of the service application
    */
    'serviceScope': ServiceAppScope;
    /**
    * The read-only time-to-live of the access token in seconds.
    */
    'accessTokenTTL': number;
    /**
    * The read-only expiration date of the access token.
    */
    'accessTokenExpiration': Date;
    /**
    * Whether the application is currently enabled.
    */
    'enabled': boolean;
}

/**
* Describes the type of service application. VMC_REFRESH_TOKEN: The application authtenticates to VMC via a refresh token VMC_CLIENT_CREDENTIAL: The application authenticates to VMC using client credentials VMC: Deprecated. Defaults to VMC_REFRESH_TOKEN. 
*/
export class ServiceAppScope {
}

export class ServiceItem {
    'id': string;
    'name': string;
    'serviceItemType': string;
    'description': string;
    'canExecute': boolean;
    'serviceName': string;
    'serviceId': string;
    'iconMimeType': string;
    'iconData': string;
    'tenantScoped': boolean;
    'providerScoped': boolean;
    /**
    * Read-only value indicating publishAll state 
    */
    'publishAll': boolean;
}

/**
* This represents the Edge Cluster to be used for network services. This can only be used to represent Edge Clusters managed by NSX-T. 
*/
export class ServicesEdgeCluster {
    /**
    * The reference to VCD Edge Cluster, if it exists.
    */
    'edgeClusterRef': EntityReference;
    /**
    * The Id of the Edge Cluster in the NSX-T manager. If the user provides the id of NSX-T edge cluster during update, VCD will automatically create a corresponding VCD Edge cluster object referencing the specified NSX-T edge cluster. For NSX-V Edges, this is set to NULL. 
    */
    'backingId': string;
}

/**
* Session 
*/
export class Session {
    /**
    * ID of session
    */
    'id': string;
    /**
    * User of this session
    */
    'user': EntityReference;
    /**
    * Organization user is logged into for this session
    */
    'org': EntityReference;
    /**
    * The accessible location this session is valid for
    */
    'location': string;
    /**
    * User's roles for this session
    */
    'roles': Array<string>;
    /**
    * References to user's roles
    */
    'roleRefs': Array<EntityReference>;
    /**
    * The session idle timeout in minutes
    */
    'sessionIdleTimeoutMinutes': number;
}

/**
* Represent the settings of an SMTP Server which the system uses to send email notifications and alerts 
*/
export class SmtpServerSpec {
    /**
    * A flag to indicate if the SMTP requires login authentication. If this flag is set to true, caller must provide user name and password 
    */
    'useAuthentication': boolean;
    /**
    * Security mode used to connect to the SMTP server 
    */
    'secureMode': SmtpServerSpec.SecureModeEnum;
    'url': Url;
    /**
    * The custom ssl trust certs if ssl is enabled 
    */
    'sslTrustStore': string;
    /**
    * Username to login to server 
    */
    'userName': string;
    /**
    * Password to login to the server 
    */
    'password': string;
    /**
    * A human readable description of the entity 
    */
    'description': string;
    /**
    * A human readable name of the entity
    */
    'name': string;
}

export namespace SmtpServerSpec {
    export enum SecureModeEnum {
        NONE = <any> 'NONE',
        STARTTLS = <any> 'START_TLS',
        SSL = <any> 'SSL'
    }
}
/**
* The VCD SSL settings
*/
export class SslSettings {
    /**
    * SSL protocols
    */
    'enabledSslProtocols': Array<string>;
    /**
    * SSL ciphers
    */
    'enabledSslCiphers': Array<string>;
    /**
    * Size of keys generated
    */
    'keySize': number;
    /**
    * Number of days generated certificates are valid for
    */
    'certificateValidityDays': number;
    /**
    * Algorithm used to sign generated certificates
    */
    'certificateSignatureAlgorithm': string;
}

/**
* Various settings for a storage policy. 
*/
export class StoragePolicySettings {
    /**
    * Max IOPS for any disk associated with this storage policy.
    */
    'diskIopsMax': number;
    /**
    * Default IOPS to apply to any disk associated with the storage policy. If set to zero, diskIopsPerGbMax is used as the default IOPS to be assigned to any disk associated with this storage policy. 
    */
    'diskIopsDefault': number;
    /**
    * Maximum IOPS that can be assigned to any disk associated with this storage policy based on the size of the disk (in GB). This is also the value used for any disk associated with this policy if diskIopsDefault is set to 0. 
    */
    'diskIopsPerGbMax': number;
    /**
    * The sum of IOPS across all disks associated with this policy will be limited to this value. 
    */
    'storagePolicyIopsLimit': number;
    /**
    * Whether IOPS limiting is enabled.
    */
    'isIopsLimitingEnabled': boolean;
    /**
    * Whether VCD IOPS placement should be ignored for disks using this policy.
    */
    'ignoreIopsPlacement': boolean;
}

/**
* A Storage Profile. 
*/
export class StorageProfile {
    /**
    * The Moref of the Storage Profile.
    */
    'moref': string;
    /**
    * The name of the Storage Profile.
    */
    'name': string;
}

/**
* A network subnet defined by its gateway, 
*/
export class Subnet {
    /**
    * The gateway for the subnet.
    */
    'gateway': string;
    /**
    * The prefix length of the subnet.
    */
    'prefixLength': number;
    /**
    * The DNS suffix that VMs attached to this network will use.
    */
    'dnsSuffix': string;
    /**
    * The first DNS server that VMs attached to this network will use.
    */
    'dnsServer1': string;
    /**
    * The second DNS server that VMs attached to this network will use.
    */
    'dnsServer2': string;
    /**
    * Range of IPs within the subnet that can be used in this network. A VM attached to this network is assigned one of these IPs.
    */
    'ipRanges': IpRanges;
    /**
    * Indicates whether the external network subnet is currently enabled.
    */
    'enabled': boolean;
    /**
    * The number of IP addresses defined by the static IP ranges.
    */
    'totalIpCount': number;
    /**
    * The number of IP address used from the static IP ranges.
    */
    'usedIpCount': number;
}

/**
* List of Subnets of a network 
*/
export class Subnets {
    'values': Array<Subnet>;
}

export class SupportedConstraints {
    'constraint': Constraint;
    'mandatory': Mandatory;
    'restrictDuplicates': RestrictDuplicates;
    'customValidator': CustomValidator;
    'numberRange': NumberRange;
    'regexp': Regexp;
    'numberFormat': NumberFormat;
}

export class SupportedDecorators {
    'decorator': Decorator;
    'refreshOnChange': RefreshOnChange;
    'multiLine': MultiLine;
    'chooser': Chooser;
    'dropDown': DropDown;
}

export class SupportedPresentationElements {
    'presentationElement': PresentationElement;
    'stepInfo': StepInfo;
    'group': Group;
    'field': Field;
    'primaryField': PrimaryField;
}

export class TestEmailRequest {
    'emailSettings': EmailSettings;
    'destination': string;
}

/**
* Results of a connection test. 
*/
export class TestResult {
    'targetProbe': ProbeResult;
    'proxyProbe': ProbeResult;
}

/**
* Specifies a SSL certificate thumbprint and the algorithm used for calculation. 
*/
export class ThumbprintAndAlgorithm {
    /**
    * The SDDC Proxy SSL certificate thumbprint.
    */
    'thumbprint': string;
    /**
    * Algorithm used for the thumbprint calculation.
    */
    'algorithm': string;
}

/**
* List of NSX-T's Tier-0 routers. 
*/
export class Tier0Routers {
    'values': Array<Tier0Router>;
}

/**
* Specifies a user, the user's organization, and the user assigned token that can be used to  access proxies as well as the expiration timestamp of the token (in UTC). Parameters cannot  be edited once a token is created. 
*/
export class Token {
    /**
    * ID of this token. Sorting on this field is not supported.
    */
    'id': string;
    /**
    * Name of the token
    */
    'name': string;
    /**
    * User specific token that can be used to access proxies. Sorting on this field is not supported.
    */
    'token': string;
    /**
    * Time stamp representing when the token will expire (in UTC).
    */
    'expirationTimeUtc': Date;
    /**
    * Owner of the token. Either a user or an extension
    */
    'owner': EntityReference;
    /**
    * Name of the user that this token is assigned to.
    */
    'username': string;
    /**
    * ID of the user that this token is assigned to. Sorting on this field is not supported.  Can not be updated. 
    */
    'userId': string;
    /**
    * Name of the organization that the assigned user belongs to. Sorting and filtering on this field is not supported.
    */
    'orgName': string;
    'org': EntityReference;
    /**
    * Type of the token. Can be of type PROXY or EXTENSION
    */
    'type': string;
}

/**
* Information for the token to be created. Required for API v35.0+ 
*/
export class TokenParameters {
    /**
    * Name of the token to create
    */
    'name': string;
    /**
    * The type of token to be created. Valid types are [\"PROXY\", \"EXTENSION\"]
    */
    'type': string;
    /**
    * The urn id of the extension to get a token for
    */
    'extensionId': string;
}

/**
* SSL certificate in PEM format. 
*/
export class TrustedCertificate {
    'id': string;
    'alias': string;
    /**
    * PEM encoded certificate
    */
    'certificate': string;
}

/**
* This configuration captures phase two negotiation parameters and tunnel properties. 
*/
export class TunnelConfig {
    /**
    * If true, perfect forward secrecy is enabled. The default value is true.
    */
    'perfectForwardSecrecyEnabled': boolean;
    /**
    * Policy for handling degragmentation bit. The default is COPY.
    */
    'dfPolicy': DfPolicyType;
    /**
    * The list of Diffie-Helman groups to be used is PFS is enabled. Default is GROUP14.
    */
    'dhGroups': Array<DhGroupType>;
    /**
    * The list of Digest algorithms to be used for message digest. The default digest algorithm is implictly covered by default encrpyption algorithm AES_GCM_128. 
    */
    'digestAlgorithms': Array<TunnelDigestAlgorithmType>;
    /**
    * The list of Encryption algorithms to use in IPSec tunnel establishment. Default is AES_GCM_128. NO_ENCRYPTION_AUTH_AES_GMAC_* enables authentication on input data without encryption. If one of these options is used, digest algorithm should be empty. 
    */
    'encryptionAlgorithms': Array<TunnelEncryptionAlgorithmType>;
    /**
    * The Security Association life time in seconds. Default is 3600 seconds.
    */
    'saLifeTime': number;
}

/**
* This is the algorithm used to verify message integruty during tunnel establishment.
*/
export class TunnelDigestAlgorithmType {
}

/**
* Encryption algorithm to use in IPSec tunnel establishment.
*/
export class TunnelEncryptionAlgorithmType {
}

/**
* The overall tunnel status which is consolidated using the Tunnel Status and IKE Status. If the tunnel is up, the status is UP. If the tunnel is down, the status is DOWN. The tunnel may also be in a DEGRADED state due to other issues. 
*/
export class TunnelStatus {
}

/**
* A branding object with the portal name, portal color, selected theme and custom URLs. 
*/
export class UiBranding {
    'portalName': string;
    /**
    * A custom color defined by the administrator and used to theme the site. The color should be in rgb hex color format such as \"FFFFFF\" all capitalized. Can be set to an empty string to use the selected theme's default colors. 
    */
    'portalColor': string;
    'selectedTheme': UiTheme;
    'customLinks': Array<UiBrandingMenuItem>;
}

/**
* An ordered list of menu items which can be customized and used in the application. Can be defined as a link, override (well known links that can be overridden, Default values are About, Help, VMRC), section, separator(section without a name) of the drop down menu. 
*/
export class UiBrandingMenuItem {
    'name': string;
    'menuItemType': UiBrandingMenuItem.MenuItemTypeEnum;
    'url': string;
}

export namespace UiBrandingMenuItem {
    export enum MenuItemTypeEnum {
        Link = <any> 'link',
        Section = <any> 'section',
        Override = <any> 'override',
        Separator = <any> 'separator'
    }
}
/**
* Meta information about a UI Plugin 
*/
export class UiPluginMetadata {
    'pluginName': string;
    'vendor': string;
    'description': string;
    'version': string;
    'license': string;
    'link': string;
    'tenantScoped': boolean;
    'providerScoped': boolean;
    'enabled': boolean;
}

/**
* A theme supported by vCloud Director. 
*/
export class UiTheme {
    'themeType': string;
    'name': string;
}

/**
* Object consisting of Egress Points and Universal Routes for a Universal Router. 
*/
export class UniversalEgressRoutes {
    /**
    * The list of Egress Points for routing configuration. This is read-only.
    */
    'egressPoints': EgressPoints;
    /**
    * The list of Universal Routes for routing configuration. 
    */
    'universalRoutes': UniversalRoutes;
}

/**
* A Route for a Universal Router. 
*/
export class UniversalRoute {
    /**
    * For a given route, routing by default will go through the default egress point. Every valid/configured route will have a default egress point.
    */
    'defaultEgress': EgressPointReference;
    /**
    * A standby egress point can be configured for failover of routes in case there is an issue routign to the default egress point.
    */
    'standbyEgress': EgressPointReference;
    /**
    * The network provider scope for the given route. There can only be one route per fault domain for a Universal Route.
    */
    'networkProviderScope': string;
    /**
    * The status of the route (whether it's realized, failed, etc.).
    */
    'status': UniversalRoutingStatus;
    'errorMessage': string;
}

/**
* A UniversalRouter object 
*/
export class UniversalRouter {
    'id': string;
    'name': string;
    'description': string;
    'vdcGroupRef': EntityReference;
    'localEgress': boolean;
    'status': VdcGroupEntityStatus;
    'errorMessage': string;
}

/**
* A UniversalRouterDhcpConfig object. 
*/
export class UniversalRouterDhcpConfig {
    'enabled': boolean;
    'servers': Array<UniversalRouterDhcpServer>;
}

/**
* List of Dhcp servers for universal router. Either egressRef or serverAddress is required to identify Dhcp server. 
*/
export class UniversalRouterDhcpServer {
    'egressRef': EntityReference;
    'serverAddress': string;
}

/**
* List of Universal Routers 
*/
export class UniversalRouters {
    'values': Array<UniversalRouter>;
}

/**
* List of routes associated with a Universal Router. 
*/
export class UniversalRoutes {
    /**
    * The Keep Alive Timer is the frequency (in seconds) at which the Universal Router seeds Keep Alive messages to its egress peers.
    */
    'keepAliveTimer': number;
    /**
    * The list of Universal Routes.
    */
    'values': Array<UniversalRoute>;
    /**
    * The list network provider scopes whose route will be unconfigure forcefully. This means that a route that is in state that normally shouldn't be unconfigurable (i.e. NSX or remote vCD site is down) will still be unconfigured. Errors may be ignored. Note that this force option also affects any route update where a network provider's egress point is modified/changed. vCD will first unconfigure any existing egress point before configuring the new egress point. 
    */
    'providerScopesToForceUnconfigure': Array<string>;
}

/**
* Represents status of given routing configuration, such as realized, universal router routing configuration failed, egress routing configuration failed, etc. 
*/
export class UniversalRoutingStatus {
}

/**
* An unmanaged Virtual Machine is a Virtual Machine that is not managed by Cloud Director but is present in vCenter. 
*/
export class UnmanagedVirtualMachine {
    /**
    * The name of the virtual machine.
    */
    'name': string;
    /**
    * The total memory (in MB) of the virtual machine.
    */
    'memory': number;
    /**
    * The total number of CPUs of the virtual machine.
    */
    'cpuCount': number;
    /**
    * The total storage (in KB) of the virtual machine.
    */
    'storage': number;
    /**
    * The absolute path of the virtual machine in the vCenter's datastore.
    */
    'path': string;
    /**
    * The virtual hardware version of the virtual machine.
    */
    'virtualHardwareVersion': number;
    /**
    * The following strings are valid states of the virtual machine. <ul> <li>INVALID</li> <li>OFF</li> <li>ON</li> <li>SUSPENDED</li> <li>UNKNOWN</li> <li>STUCK</li> </ul>
    */
    'state': string;
    /**
    * The vSphere Managed Object Reference.
    */
    'moRef': string;
}

/**
* Description of an upload (in progress or complete) 
*/
export class UploadMetadataResponse {
    'id': string;
    'pluginStatus': UploadMetadataResponse.PluginStatusEnum;
    'resourcePath': string;
}

export namespace UploadMetadataResponse {
    export enum PluginStatusEnum {
        Unavailable = <any> 'unavailable',
        Ready = <any> 'ready'
    }
}
/**
* Information about upload 
*/
export class UploadSpec {
    'fileName': string;
    'size': number;
    'checksum': string;
    'checksumAlgo': UploadSpec.ChecksumAlgoEnum;
}

export namespace UploadSpec {
    export enum ChecksumAlgoEnum {
        Sha1 = <any> 'sha1',
        Sha256 = <any> 'sha256'
    }
}
export class Url {
    'host': string;
    'port': number;
    'ssl': boolean;
}

/**
* Describes a used IP address for a network. 
*/
export class UsedIpAddress {
    /**
    * Id of the entity using the IP address, such as a VM.
    */
    'entityId': string;
    /**
    * Name of the entity using the IP address.
    */
    'entityName': string;
    /**
    * Name of the vApp whose VM is using this IP address.
    */
    'vAppName': string;
    /**
    * The IP address in use.
    */
    'ipAddress': string;
    /**
    * Whether the entity using this IP address is currently deployed.
    */
    'deployed': boolean;
    /**
    * The possible allocation types for network address like VSM allocated, VM allocated or NAT routed.
    */
    'allocationType': UsedIpAddressAllocationType;
    /**
    * The vApp network or Org vDC network to which this entity is connected. 
    */
    'networkRef': EntityReference;
    /**
    * The organization that this entity belongs to. 
    */
    'orgRef': EntityReference;
}

/**
* The possible allocation types for allocated network IP address. VM_ALLOCATED means that the IP address is used by a VM, EDGE means that the IP address is in use by an NSX edge gateway interface. 
*/
export class UsedIpAddressAllocationType {
}

/**
* LDAP User Spec object. 
*/
export class User {
    'username': string;
    'description': string;
    'orgEntityRef': EntityReference;
    'fullname': string;
    'email': string;
    'phoneNumber': string;
    'im': string;
    'external': boolean;
    'nameInSource': string;
    'sourceEntityRef': EntityReference;
    'enabled': boolean;
    'locked': boolean;
    'alertEmailPrefix': string;
    'alertEmail': string;
    'roleEntityRef': EntityReference;
    'roleInherited': boolean;
    'delayAfterPowerOnSeconds': number;
    /**
    * The stored VM quota for this user. Defaults to 0 which means unlimited. This property is deprecated in 35.0. Use user quotas API.
    */
    'storedVMQuota': number;
    /**
    * The deployed VM quota for this user. Defaults to 0 which means unlimited. This property is deprecated in 35.0. Use user quotas API.
    */
    'deployedVMQuota': number;
    'inSync': boolean;
}

/**
* Group Spec object. 
*/
export class UserGroup {
    'name': string;
    'id': string;
    'description': string;
    'orgEntityRef': EntityReference;
    'sourceEntityRef': EntityReference;
    'roleEntityRef': EntityReference;
    'nameInSource': string;
    'providerType': string;
}

/**
* An object representing a vCenter server. 
*/
export class VCenterServer {
    /**
    * URN of the associated vCenter server.
    */
    'vcId': string;
    /**
    * The name of the vCenter server.
    */
    'name': string;
    /**
    * Optional description.
    */
    'description': string;
    /**
    * User name to connect to the server.
    */
    'username': string;
    /**
    * Cleartext password to connect to the server.
    */
    'password': string;
    /**
    * URL of the server.
    */
    'url': string;
    /**
    * True if the vCenter server is enabled for use with vCloud Director.
    */
    'isEnabled': boolean;
    /**
    * The URL of vCenter web client server.
    */
    'vsphereWebClientServerUrl': string;
    /**
    * When present, indicates that a proxy exists within vCloud Director that proxies this vCenter server for access by authorized end-users. Setting this field to true when registering a vCenter server will result in a proxy being created for the vCenter server, and another for the corresponding SSO endpoint (if different from the vCenter server's endpoint). This field is immutable after the vCenter Server is registered, and will be updated by the system when/if the proxy is removed.
    */
    'hasProxy': boolean;
    /**
    * vCenter root folder in which the vCloud Director system folder will be created. This parameter only takes the folder name and not directory structure.
    */
    'rootFolder': string;
    /**
    * Network in Vcenter to be used as 'NONE' network by vCD.
    */
    'vcNoneNetwork': string;
    /**
    * Public label of this vCenter server visible to all tenants.
    */
    'tenantVisibleName': string;
    /**
    * True if the vCenter server is connected.
    */
    'isConnected': boolean;
    /**
    * The vcenter mode. One of <ul> <li>NONE - undetermined</li> <li>IAAS - provider scoped</li> <li>SDDC - tenant scoped</li> <li>MIXED</li> </ul> IAAS indicates this vCenter server is scoped to the provider. SDDC indicates that this vCenter server is scoped to tenants, while MIXED indicates mixed mode, where both uses are allowed in this vCenter server.
    */
    'mode': VCenterServer.ModeEnum;
    /**
    * The vcenter listener state. One of <ul> <li>INITIAL</li> <li>INVALID_SETTINGS</li> <li>UNSUPPORTED</li> <li>DISCONNECTED</li> <li>CONNECTING</li> <li>CONNECTED_SYNCING</li> <li>CONNECTED</li> <li>STOP_REQ</li> <li>STOP_AND_PURGE_REQ</li> <li>STOP_ACK</li> </ul>
    */
    'listenerState': string;
    /**
    * The overall health status of clusters in this vCenter server. One of <ul> <li>GRAY</li> <li>RED</li> <li>YELLOW</li> <li>GREEN</li> </ul>
    */
    'clusterHealthStatus': VCenterServer.ClusterHealthStatusEnum;
    /**
    * The version of the VIM server.
    */
    'vcVersion': string;
    /**
    * The instance UUID property of the vCenter server.
    */
    'uuid': string;
    /**
    * the NSX-V attached to this Virtual Center server, when present.
    */
    'nsxVManager': NsxVManager;
    'proxyConfigurationUrn': string;
}

export namespace VCenterServer {
    export enum ModeEnum {
        NONE = <any> 'NONE',
        IAAS = <any> 'IAAS',
        SDDC = <any> 'SDDC',
        MIXED = <any> 'MIXED'
    }
    export enum ClusterHealthStatusEnum {
        GRAY = <any> 'GRAY',
        RED = <any> 'RED',
        YELLOW = <any> 'YELLOW',
        GREEN = <any> 'GREEN'
    }
}
/**
* An object representing metrics of a vCenter server. 
*/
export class VCenterServerMetrics {
    /**
    * URN of the associated vCenter server.
    */
    'vcId': string;
    /**
    * The number of clusters in this vCenter server.
    */
    'clustersCount': number;
    /**
    * The number of VMs in this vCenter server.
    */
    'totalVmCount': number;
    /**
    * The number of powered-on VMs in this vCenter server.
    */
    'poweredOnVmCount': number;
    /**
    * The total memory (in MB) in this vCenter server.
    */
    'totalMemMb': number;
    /**
    * The reserved memory (in MB) in this vCenter server.
    */
    'reservedMemMb': number;
    /**
    * The demanded memory (in MB) in this vCenter server.
    */
    'demandedMemMb': number;
    /**
    * The total CPU (in MHz) in this vCenter server.
    */
    'totalCpuMhz': number;
    /**
    * The reserved CPU (in MHz) in this vCenter server.
    */
    'reservedCpuMhz': number;
    /**
    * The demanded CPU (in MHz) in this vCenter server.
    */
    'demandedCpuMhz': number;
    /**
    * The size (in MB) of all datastores in this vCenter server.
    */
    'totalStorageMb': number;
    /**
    * The size of free storage (in MB) of all datastores in this vCenter server.
    */
    'freeStorageMb': number;
    /**
    * The size of uncommitted storage (in MB) of all datastores in this vCenter server.
    */
    'uncommittedStorageMb': number;
}

/**
* Response type with meta information about a vRealize Orchestrator Service 
*/
export class VROServiceInfo {
    /**
    * This is a read-only field in the client. Values set on this field will be ignored by the server. 
    */
    'id': string;
    'name': string;
    'description': string;
    'vroEndpoint': string;
    'username': string;
    /**
    * The password is hidden using a Password Mask represented by a series of 6 asterisks (\"******\") in the response. The Password Mask is not an acceptable password during VRO Server registration. During an update, the Password Mask set for the 'password' field is interpreted as no change to the field and is ignored. 
    */
    'password': string;
    'version': string;
    /**
    * SSL Certificate chain for the VRO endpoint (deprecated)
    */
    'trustAnchor': string;
    /**
    * Reference to the associated vCenter server.
    */
    'vcId': EntityReference;
}

/**
* User Spec object. 
*/
export class VcdUser {
    /**
    * Immutable user name of the user.
    */
    'username': string;
    /**
    * Full name (display name) of the user.
    */
    'fullName': string;
    /**
    * Description of the user.
    */
    'description': string;
    /**
    * Unique id for the user.
    */
    'id': string;
    /**
    * The role(s) of the user. If isGroupRole is true, this user inherits their role(s) from group membership(s)
    */
    'roleEntityRefs': Array<EntityReference>;
    /**
    * Organization that the user belongs to.
    */
    'orgEntityRef': EntityReference;
    /**
    * Password for the user. Must be null for external users.
    */
    'password': string;
    /**
    * The deployed VM quota for this user. Defaults to 0 which means unlimited. This property is deprecated in 35.0. Use user quotas API.
    */
    'deployedVmQuota': number;
    /**
    * The stored VM quota for this user. Defaults to 0 which means unlimited. This property is deprecated in 35.0. Use user quotas API.
    */
    'storedVmQuota': number;
    /**
    * A user's email address. Based on org email preferences, notifications can be sent to the user via email.
    */
    'email': string;
    /**
    * Name of the user in its source.
    */
    'nameInSource': string;
    /**
    * Enabled state of the user. Defaults to true.
    */
    'enabled': boolean;
    /**
    * Determines if this user's role is inherited from a group. Defaults to false.
    */
    'isGroupRole': boolean;
    /**
    * Provider type of the user. It is immutable and must be one of: LOCAL, LDAP, SAML, OAUTH.
    */
    'providerType': string;
}

export class VdcComputePolicy {
    /**
    * UUID for vDC compute policy. This is immutable. 
    */
    'id': string;
    'description': string;
    /**
    * Display name. 
    */
    'name': string;
    /**
    * The CPU speed in MHz of this VM. This is optional. When provided, VMs with this policy cannot have more than CPU speed defined by this field. 
    */
    'cpuSpeed': number;
    /**
    * The maximum memory in MB allowed for a VM. This is optional. When provided, VMs with this policy cannot have configured memory more than defined by this field. 
    */
    'memory': number;
    /**
    * The maximum number of CPUs allowed for a VM. This is optional. When provided, VMs with this policy cannot have more than number of CPUs defined by this field. 
    */
    'cpuCount': number;
    /**
    * The cores per socket to be configured for the VM where this policy is applied. 
    */
    'coresPerSocket': number;
    /**
    * The factor of the configured memory reserved for the VM on which this policy is applied. 
    */
    'memoryReservationGuarantee': number;
    /**
    * The factor of the configured CPU reserved for the VM on which this policy is applied. 
    */
    'cpuReservationGuarantee': number;
    /**
    * The limit of CPU in MHz for the VM on which this policy is applied. -1 means unlimited. This is optional. If not provided, limit would be equal to the vCPUSpeed multiplied by numCPU. 
    */
    'cpuLimit': number;
    /**
    * The limit of memory in MB for the VM on which this policy is applied. -1 means unlimited. This is optional. If not provided, limit would be equal to the configured memory of the VM. 
    */
    'memoryLimit': number;
    /**
    * The number of CPU shares for the VM on which this policy is applied. This is optional. If not provided, Normal shares would be applied to the VM. 
    */
    'cpuShares': number;
    /**
    * The number of memory shares for the VM on which this policy is applied. This is optional. If not provided, Normal shares would be applied to the VM. 
    */
    'memoryShares': number;
    /**
    * Map of extra configs to be set on the VM with this policy. 
    */
    'extraConfigs': { [key: string]: string; };
    /**
    * Deprecated in Api 32.0, this property will be removed in future release. 
    */
    'pvdcComputePolicyRef': EntityReference;
    /**
    * This field cannot be updated and is a read-only field in the client after creation. 
    */
    'pvdcComputePolicy': EntityReference;
    /**
    * A list of read-only compatible vDC types for this policy.
    */
    'compatibleVdcTypes': Array<string>;
    /**
    * This field cannot be updated and is a read-only field in the client after creation. It defines whether the policy is SIZING_ONLY or if it also contains affinity information. 
    */
    'isSizingOnly': boolean;
    /**
    * URN for Provider VDC. 
    */
    'pvdcId': string;
    /**
    * List of list of vmGroups grouped together in a meaningful manner. A group of vmGroups would consist of one functionally equal vmGroup picked from each cluster of the pvdc. 
    */
    'namedVmGroups': Array<Array<EntityReference>>;
    /**
    * List of logical vm group references. This value is set at creation time and cannot be edited later. 
    */
    'logicalVmGroupReferences': Array<EntityReference>;
    /**
    * This field cannot be updated and is a read-only field in the client. It defines if the policy is auto-generated. 
    */
    'isAutoGenerated': boolean;
}

/**
* vDC compute policy that contains vDC specific configuration for workloads. (Version 2.0.0) 
*/
export class VdcComputePolicy2 {
    /**
    * UUID for vDC compute policy. This is immutable. 
    */
    'id': string;
    'description': string;
    /**
    * The discriminator type is used to differentiate among various sub policy types. 
    */
    'policyType': string;
    /**
    * Display name. 
    */
    'name': string;
    /**
    * This field cannot be updated and is a read-only field in the client after creation. 
    */
    'pvdcComputePolicy': EntityReference;
    /**
    * A list of read-only compatible vDC types for this policy.
    */
    'compatibleVdcTypes': Array<string>;
    /**
    * This field cannot be updated and is a read-only field in the client after creation. It defines whether the policy is SIZING_ONLY or if it also contains affinity information. 
    */
    'isSizingOnly': boolean;
    /**
    * URN for Provider vDC. 
    */
    'pvdcId': string;
    /**
    * It is a read-only field. It indicates whether the policy is auto-generated. 
    */
    'isAutoGenerated': boolean;
}

/**
* Metrics for Vdc compute policy 
*/
export class VdcComputePolicyMetrics {
    /**
    * The discriminator type is used to differentiate among various sub policy type metrics. 
    */
    'policyMetricsType': string;
}

/**
* A vDC Group holds a list of vDCs that can have a network be stretched across the vDCs. 
*/
export class VdcGroup {
    /**
    * The unique ID for the vDC Group (read-only).
    */
    'id': string;
    /**
    * The organization that this group belongs to.
    */
    'orgId': string;
    /**
    * The name of this group. The name must be unique.
    */
    'name': string;
    /**
    * The description of this group.
    */
    'description': string;
    /**
    * Determines whether local egress is enabled for a universal router belonging to a universal vDC group. This value is used on create if universalNetworkingEnabled is set to true. This cannot be updated. This value is always false for local vDC groups. 
    */
    'localEgress': boolean;
    /**
    * The list of organization vDCs that are participating in this group.
    */
    'participatingOrgVdcs': Array<ParticipatingVdcReference>;
    /**
    * True means that a vDC group router has been created. If set to true for vdc group creation, a universal router will also be created.
    */
    'universalNetworkingEnabled': boolean;
    /**
    * The network provider's universal id that is backing the universal network pool. This field is read-only and is derived from the list of participating vDCs if a universal vDC group is created. For universal vDC groups, each participating vDC should have a universal network pool that is backed by this same id. 
    */
    'networkPoolUniversalId': string;
    /**
    * ID of network pool to use if creating a local vDC group router. Must be set if creating a local group. Ignored if creating a universal group. 
    */
    'networkPoolId': string;
    /**
    * The status that the group can be in.
    */
    'status': VdcGroupEntityStatus;
    /**
    * Defines the group as LOCAL or UNIVERSAL. This cannot be changed. Local vDC Groups can have networks stretched across multiple vDCs in a single Cloud Director instance. Local vDC Groups share the same broadcast domain/transport zone and network provider scope. Universal vDC groups can have networks stretched across multiple vDCs in a single or multiple Cloud Director instance(s). Universal vDC groups are backed by a broadcast domain/transport zone that strectches across a single or multiple Cloud Director instance(s). Local vDC groups are supported for both NSX-V and NSX-T Network Provider Types. Universal vDC Groups are supported for only NSX_V Network Provider Type. 
    */
    'type': VdcGroup.TypeEnum;
    /**
    * The values currently supported are NSX_V and NSX_T. Defines the networking provider backing the vDC Group. This is used on create. If not specified, NSX_V value will be used. NSX_V is used for existing vDC Groups and vDC Groups where Cross-VC NSX is used for the underlying technology. NSX_T is used when the networking provider type for the Organization vDCs in the group is NSX-T. NSX_T only supports groups of type LOCAL (single site). 
    */
    'networkProviderType': string;
    /**
    * Whether Distributed Firewall is enabled for this vDC Group. Only applicable for NSX_T vDC Groups.
    */
    'dfwEnabled': boolean;
    /**
    * If the group has an error status, a more detailed error message is set here.
    */
    'errorMessage': string;
}

export namespace VdcGroup {
    export enum TypeEnum {
        LOCAL = <any> 'LOCAL',
        UNIVERSAL = <any> 'UNIVERSAL'
    }
}
/**
* Represents status of vDC group components such as participating vdc's configured routing, egress points, etc. 
*/
export class VdcGroupEntityStatus {
}

/**
* Defines the global settings for all vDC Groups in the system. These can be changed by the provider only. 
*/
export class VdcGroupSettings {
    /**
    * <ul> Defines the fault domain tag that will be shown for participating/candidate Organization vDCs during creation or update of a vDC Group whose networkProviderType is NSX_T. The options a provider can choose from are COMPUTE_PROVIDER_SCOPE and NETWORK_PROVIDER_SCOPE. This should be selected based on the provider's compute or networking infrastructure. The default value is COMPUTE_PROVIDER_SCOPE.  <li> NETWORK_PROVIDER_SCOPE: This represents the tenant-facing name of the backing network provider for the organization vDC (NSX-V/NSX-T manager). This should be used when the fault domains in the provider infrastructure are separated by network provider. </li> <li> COMPUTE_PROVIDER_SCOPE: This represents the tenant-facing name of the backing compute provider for the organization vDC (Provider VDC). This should be used when the fault domains in the provider infrastructure are separated by compute provider. </li> </ul> 
    */
    'nsxTVdcGroupFaultDomainTagType': string;
}

/**
* Describes how a network is connected to a gateway. 
*/
export class VdcNetworkConnectionType {
}

/**
* Configuration for the DHCP service that runs for the network. In order to use DHCPv6 in NSX-T, the network must be configured in EDGE mode, the network must be attached to a router, and the router must have a SLAAC profile configured with DHCPv6 mode. 
*/
export class VdcNetworkDhcpConfig {
    /**
    * Whether the DHCP service is currently enabled on network.
    */
    'enabled': boolean;
    /**
    * The amount of time in milliseconds of how long a DHCP IP will be leased out for. The minimum is 60ms while the maximum is 4294967295ms, which is roughly 49 days. 
    */
    'leaseTime': number;
    /**
    * Range of DHCP IP addresses
    */
    'dhcpPools': Array<VdcNetworkDhcpPool>;
    /**
    * This value describes how the DHCP service is configured for this network. Once a DHCP service has been created, the mode attribute cannot be changed. The mode field will default to 'EDGE' if it is not provided. This field only applies to networks backed by an NSX-T network provider. <ul> <li>The supported values are EDGE and NETWORK.</li> <li>If EDGE is specified, the DHCP service of the edge is used to obtain DHCP IPs.</li> <li>If NETWORK is specified, a DHCP server is created for use by this network.</li> </ul> In order to use DHCP for IPV6, NETWORK mode must be used. Routed networks which are using NETWORK DHCP services can be disconnected from the edge gateway and still retain their DHCP configuration, however network using EDGE DHCP cannot be disconnected from the gateway until DHCP has been disabled. 
    */
    'mode': string;
    /**
    * The IP address of the DHCP service. This is required upon create if using NETWORK mode. This field only applies to networks backed by an NSX-T network provider. 
    */
    'ipAddress': string;
}

/**
* A range of DHCP ip addresses and its lease time configuration. 
*/
export class VdcNetworkDhcpPool {
    /**
    * Whether the DHCP address pool is currently enabled
    */
    'enabled': boolean;
    'ipRange': IpRange;
    /**
    * Max lease time in seconds
    */
    'maxLeaseTime': number;
    /**
    * Default lease time in seconds
    */
    'defaultLeaseTime': number;
}

/**
* The network type. 
*/
export class VdcNetworkFenceType {
}

/**
* A vDC Network Profile object. 
*/
export class VdcNetworkProfile {
    /**
    * The Edge Cluster where the primary appliance for an NSX-V Edge Gateway will be deployed.
    */
    'primaryEdgeCluster': EntityReference;
    /**
    * The Edge Cluster where the secondary appliance for an NSX-V Edge Gateway will be deployed if HA is enabled on the Edge.
    */
    'secondaryEdgeCluster': EntityReference;
    /**
    * The Edge Cluster where the DHCP server profile will be stored for NSX-T networks using NETWORK mode DHCP.
    */
    'servicesEdgeCluster': ServicesEdgeCluster;
}

/**
* In a Tanzu Kubernetes cluster Virtual Machine Classes reserve a set of resources for the VM including cpu, memory, and storage. 
*/
export class VirtualMachineClass {
    /**
    * Name of the Virtual Machine Class. 
    */
    'name': string;
    /**
    * CPU in MHz that a node reserves when this VirtualMachineClass is applied to the node of a Kubernetes cluster. 
    */
    'cpuReservationRequestedMHz': number;
    /**
    * Memory in MB that a node reserves when this VirtualMachineClass is applied to the node of a Kubernetes cluster. 
    */
    'memoryReservationRequestedMB': number;
    /**
    * Number of CPUs that a node gets when this VirtualMachineClass is applied to the node of a Kubernetes cluster. 
    */
    'cpuCount': number;
    /**
    * Memory in MB that a node gets when this VirtualMachineClass is applied to the node of a Kubernetes cluster. 
    */
    'memoryMB': number;
    /**
    * This read-only field conveys whether CPU and memory resources are fully reserved or not when this VirtualMachineClass is applied to the node of the Kubernetes cluster. 
    */
    'isFullyReserved': boolean;
}

/**
* An object representing VLAN Id range. 
*/
export class VlanIdRange {
    /**
    * Starting VLAN Id in the range.
    */
    'startId': number;
    /**
    * Ending VLAN Id in the range.
    */
    'endId': number;
}

/**
* List of IpRange 
*/
export class VlanIdRanges {
    'values': Array<VlanIdRange>;
}

/**
* A VMware Cloud on AWS SDDC 
*/
export class VmcSddc {
    /**
    * The unique ID for the VMC SDDC.
    */
    'id': string;
    /**
    * The name of the VMC SDDC. This field is read-only.
    */
    'name': string;
    /**
    * The username for the account to use to register Virtual Center, if not using the VMC default.
    */
    'vcUsername': string;
    /**
    * The password for the account to use to register Virtual Center, if not using the VMC default.
    */
    'vcPassword': string;
    /**
    * The URN for the proxy configuration to use for connecting to Virtual Center.
    */
    'proxyConfigUrn': string;
}

/**
* Meta information about an inventory item on a vRealize Orchestrator server 
*/
export class VroRemoteInventoryItem {
    'href': string;
    'attributes': Array<WsAttribute>;
    'relations': Relations;
}

/**
* Information about various objects in vRealize Orchestrator server 
*/
export class VroRemoteItem {
    'name': string;
    'description': string;
    'id': string;
    'vroServerId': string;
    'dunesId': string;
    'type': string;
    'selectable': boolean;
    'canHaveChildren': boolean;
    'href': string;
    'rel': string;
}

/**
* A list of objects in vRealize orchestrator server 
*/
export class VroRemoteItems {
    'remoteItems': Array<VroRemoteItem>;
    'resultTotal': number;
    'pageCount': number;
}

/**
* A plugin namespaces for whom type information can be retrieved 
*/
export class VroRemotePluginItem {
    'name': string;
    'typeHref': string;
    'selectable': boolean;
    'canHaveChildren': boolean;
}

/**
* List of plugin namespaces 
*/
export class VroRemotePluginItems {
    'items': Array<VroRemotePluginItem>;
}

/**
* Type definition for a plugin namespace 
*/
export class VroRemotePluginType {
    'name': string;
    'selectable': boolean;
    'canHaveChildren': boolean;
}

/**
* A list of defined types for a particular plugin namespace 
*/
export class VroRemotePluginTypes {
    'types': Array<VroRemotePluginType>;
    'namespace': string;
}

/**
* Meta information about a workflow on a vRealize Orchestrator server 
*/
export class VroRemoteWorkflowItem {
    'name': string;
    'description': string;
    'categoryName': string;
    'canExecute': boolean;
    'id': string;
    'vroServerId': string;
}

export class WsAttribute {
    'displayValue': string;
    'name': string;
    'value': string;
}

export class WsParameter {
    'description': string;
    'encryptValue': boolean;
    'name': string;
    'scope': WsParameter.ScopeEnum;
    'type': string;
    'updated': boolean;
    'value': Parameter;
}

export namespace WsParameter {
    export enum ScopeEnum {
        Local = <any> 'local',
        Token = <any> 'token'
    }
}
export class WsWorkflowExecution {
    'businessState': string;
    'contentException': string;
    'currentItemDisplayName': string;
    'endDate': Date;
    'id': string;
    'inputParameters': Array<WsParameter>;
    'name': string;
    'outputParameters': Array<WsParameter>;
    'relations': Relations;
    'startDate': Date;
    'startedBy': string;
    'state': ExecutionState;
}

/**
* A pageable list of access-control grants. 
*/
export class AccessControlGrants {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of access-control entries.
    */
    'values': Array<AccessControlGrant>;
}

export class AccessLevel {
    'name': string;
    'id': string;
    'description': string;
    'bundleKey': string;
    'readOnly': boolean;
}

export class AccessLevels {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * All access levels.
    */
    'values': Array<AccessLevel>;
}

/**
* A list of locations accessible to this session. 
*/
export class AccessibleLocations {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of accessible locations.
    */
    'values': Array<AccessibleLocation>;
}

/**
* A list of Advisories. 
*/
export class Advisories {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of advisories.
    */
    'values': Array<Advisory>;
}

export class AdvisoryDefinition {
    /**
    * A unique identifier for the advisory (read-only).
    */
    'id': string;
    /**
    * The id reference to the target entity this advisory is for.
    */
    'targetId': string;
    /**
    * A localized message for this advisory.
    */
    'message': string;
    /**
    * Priority for an advisory that indicates the level of urgency. These priorities are listed in descending sort order. <ul>   <li>     <em>MANDATORY</em>: Mandatory message that is always displayed;     these advisories cannot be snoozed or dismissed (see documentation     on displayStart and displayEnd)   </li>   <li>     <em>CRITICAL</em>: Equivalent of a \"red\" warning   </li>   <li>     <em>IMPORTANT</em>: Equivalent of a \"yellow\" warning   </li>   <li>     <em>NOTICE</em>: Informational message   </li> </ul> 
    */
    'priority': string;
    /**
    * The ISO-8601 timestamp from which this advisory is applicable. Defaults to the server's current time if unspecified. If permissible, users may update this value to a time in the future to snooze this advisory. 
    */
    'displayStart': Date;
    /**
    * The ISO-8601 timestamp representing when this advisory is no longer applicable. If permissible, users may update this value to a time in the past to dismiss this advisory. The displayEnd timestamp must be >= displayStart. 
    */
    'displayEnd': Date;
    /**
    * Represents where the advisory is being generated from. This is a read-only field. Can be of type USER or INTERNAL. 
    */
    'source': string;
}

/**
* A list of Advisories definitions. 
*/
export class AdvisoryDefinitions {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of advisory definitions.
    */
    'values': Array<AdvisoryDefinition>;
}

/**
* List of allocated IP addresses. 
*/
export class AllocatedIpAddresses {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<AllocatedIpAddress>;
}

/**
* An Application Port Profile object. The application port profile represents a set of ports and protocols that can be used when defining network service rules. 
*/
export class ApplicationPortProfile {
    /**
    * The organization that this object belongs to. This property is required during creation and cannot be updated. 
    */
    'orgRef': EntityReference;
    /**
    * The context under which this object is created. The context can the id of the organization vDC, vDC Group, or network provider. This field is required on object creation and is unset on object reads. This same context ID can be used in the context filter field when querying for the list of objects. 
    */
    'contextEntityId': string;
    /**
    * The network provider scope that this object belongs to. This is a read-only property and is determined by the input context entity ID during object creation. 
    */
    'networkProviderScope': string;
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The id of the Application Port Profile in URN format.
    */
    'id': string;
    /**
    * The name of the Application Port Profile.
    */
    'name': string;
    'description': string;
    /**
    * The scope of the application port profile definition.
    */
    'scope': ApplicationPortProfileScopeType;
    /**
    * A list of protocol and ports supported by this application port profile.
    */
    'applicationPorts': Array<ApplicationPortList>;
    /**
    * True means that the port profile can be used for NAT configuration.  A port profile can be used for NAT if there is only 1 application port with at most 1 destination port. 
    */
    'usableForNAT': boolean;
}

/**
* List of Application Port Profiles. 
*/
export class ApplicationPortProfiles {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<ApplicationPortProfile>;
}

export class ArrayParam extends Parameter {
    'value': Array<Parameter>;
}

/**
* A list of audit trail events. 
*/
export class AuditTrailEvents {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of audit trail events.
    */
    'values': Array<AuditTrailEvent>;
}

/**
* The access control configuration of all Defined Enitty Type's Behaviors. 
*/
export class BehaviorAccesses {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of behavior access entries
    */
    'values': Array<BehaviorAccess>;
}

/**
* An array ofs Defined Entity Behaviors 
*/
export class Behaviors {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<Behavior>;
}

export class BooleanParam extends Parameter {
    'value': boolean;
}

/**
* List of read-only capabilities. 
*/
export class Capabilities {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<Capability>;
}

/**
* A paginated list of vCloud Director cells. 
*/
export class Cells {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<Cell>;
}

/**
* A list of certificate library items. 
*/
export class CertificateLibraryItems {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of certificate library items.
    */
    'values': Array<CertificateLibraryItem>;
}

/**
* A list of certificates. 
*/
export class Certificates {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of certificates.
    */
    'values': Array<TrustedCertificate>;
}

export class Chooser extends Decorator {
    'sdkObject': SdkObject;
    'type': string;
}

export class CompositeType extends Parameter {
    'property': Array<CompositeValue>;
    'type': string;
}

export class CompositeValue extends Parameter {
    'id': string;
    'property': Parameter;
}

/**
* A CrossVdcNetwork object 
*/
export class CrossVdcNetwork {
    /**
    * The unique ID for the network. This field is read-only.
    */
    'id': string;
    /**
    * The name of the network.
    */
    'name': string;
    /**
    * The description of the network.
    */
    'description': string;
    /**
    * List of subnets configured for the network.
    */
    'subnets': Subnets;
    /**
    * The vDC group that this network belongs to.
    */
    'vdcGroupRef': EntityReference;
    /**
    * The router that this network is attached to.
    */
    'routerRef': EntityReference;
    /**
    * The status of the network.
    */
    'status': VdcGroupEntityStatus;
    /**
    * If the network has an error status, a more detailed error message is set here.
    */
    'errorMessage': string;
}

/**
* List of cross vDC networks 
*/
export class CrossVdcNetworks {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<CrossVdcNetwork>;
}

/**
* A list of custom entity types. 
*/
export class CustomEntityTypes {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of custom entity types.
    */
    'values': Array<CustomEntityType>;
}

export class CustomValidator extends Constraint {
}

export class DateParam extends Parameter {
    'value': Date;
}

/**
* A list of defined entities. 
*/
export class DefinedEntities {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of defined entities.
    */
    'values': Array<DefinedEntity>;
}

/**
* A list of defined entity types. 
*/
export class DefinedEntityTypes {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of defined entity types.
    */
    'values': Array<DefinedEntityType>;
}

/**
* A paginated list of defined interfaces. 
*/
export class DefinedInterfaces {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<DefinedInterface>;
}

/**
* Describes a DFW rule.
*/
export class DfwRule {
    /**
    * The unique id of this firewall rule. If a rule with the ruleId is not already present, a new rule will be created. If it already exists, the rule will be updated. 
    */
    'id': string;
    /**
    * Name for the rule.
    */
    'name': string;
    'description': string;
    /**
    * List of source groups for firewall rule. It specifies the sources of network traffic for the firewall rule. Null value or an empty list will be treated as \"ANY\" which means traffic from any source. 
    */
    'sourceFirewallGroups': Array<EntityReference>;
    /**
    * List of source groups for firewall rule. It specifies the destinations of network traffic for the firewall rule. Null value or an empty list will be treated as \"ANY\" which means traffic to any destination. 
    */
    'destinationFirewallGroups': Array<EntityReference>;
    /**
    * The list of application ports where this firewall rule is applicable. Null value or an empty list will be treated as \"ANY\" which means rule applies to all ports. 
    */
    'applicationPortProfiles': Array<EntityReference>;
    /**
    * Type of IP packet that should be matched while enforcing the rule. Default value is IPV4_IPV6. 
    */
    'ipProtocol': FirewallRuleIpProtocol;
    /**
    * The action to be applied to all the traffic that meets the firewall rule criteria. It determines if the rule permits or blocks traffic. 
    */
    'action': FirewallRuleAction;
    /**
    * Specifies the direction of the network traffic. Default value is IN_OUT. 
    */
    'direction': FirewallRuleDirection;
    /**
    * Whether packet logging is enabled for firewall rule.
    */
    'logging': boolean;
    /**
    * The list of layer 7 network context profiles where this firewall rule is applicable. Null value or an empty list will be treated as \"ANY\" which means rule applies to all applications and domains. 
    */
    'networkContextProfiles': Array<EntityReference>;
    /**
    * Whether the firewall rule is enabled.
    */
    'enabled': boolean;
    'version': ObjectVersion;
}

/**
* List of distributed portgroups. 
*/
export class DistributedPortGroups {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<DistributedPortGroup>;
}

export class DropDown extends Decorator {
    'array': ArrayParam;
}

/**
* List of distributed virtual switches. 
*/
export class DvSwitches {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<DvSwitch>;
}

/**
* List of Edge Clusters. 
*/
export class EdgeClusters {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<EdgeCluster>;
}

/**
* Describes a Firewall rule for an edge gateway backed by NSX-T.
*/
export class EdgeFirewallRule {
    /**
    * The unique id of this firewall rule. If a rule with the ruleId is not already present, a new rule will be created. If it already exists, the rule will be updated. 
    */
    'id': string;
    /**
    * Name for the rule.
    */
    'name': string;
    'description': string;
    /**
    * List of source groups for firewall rule. It specifies the sources of network traffic for the firewall rule. Null value or an empty list will be treated as \"ANY\" which means traffic from any source. 
    */
    'sourceFirewallGroups': Array<EntityReference>;
    /**
    * List of source groups for firewall rule. It specifies the destinations of network traffic for the firewall rule. Null value or an empty list will be treated as \"ANY\" which means traffic to any destination. 
    */
    'destinationFirewallGroups': Array<EntityReference>;
    /**
    * The list of application ports where this firewall rule is applicable. Null value or an empty list will be treated as \"ANY\" which means rule applies to all ports. 
    */
    'applicationPortProfiles': Array<EntityReference>;
    /**
    * Type of IP packet that should be matched while enforcing the rule. Default value is IPV4_IPV6. 
    */
    'ipProtocol': FirewallRuleIpProtocol;
    /**
    * The action to be applied to all the traffic that meets the firewall rule criteria. It determines if the rule permits or blocks traffic. 
    */
    'action': FirewallRuleAction;
    /**
    * Specifies the direction of the network traffic. Default value is IN_OUT. 
    */
    'direction': FirewallRuleDirection;
    /**
    * Whether packet logging is enabled for firewall rule.
    */
    'logging': boolean;
    /**
    * The list of layer 7 network context profiles where this firewall rule is applicable. Null value or an empty list will be treated as \"ANY\" which means rule applies to all applications and domains. 
    */
    'networkContextProfiles': Array<EntityReference>;
    /**
    * Whether the firewall rule is enabled.
    */
    'enabled': boolean;
    'version': ObjectVersion;
}

/**
* Firewall rules for an edge gateway. This contains an ordered list of system, user defined and default firewall rules. All the rules are returned in the order of type and precedence. 
*/
export class EdgeFirewallRules {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The ordered list of system defined edge firewall rules. System rules are applied before user defined rules in the order in which they are returned. 
    */
    'systemRules': Array<EdgeFirewallRule>;
    /**
    * The ordered list of user defined edge firewall rules. Users are allowed to add/modify/delete rules only to this list. 
    */
    'userDefinedRules': Array<EdgeFirewallRule>;
    /**
    * The ordered list of default edge firewall rules. Default rules are applied after the user defined rules in the order in which they are returned. 
    */
    'defaultRules': Array<EdgeFirewallRule>;
}

/**
* An edge gateway object 
*/
export class EdgeGateway {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The unique identifier of the edge gateway.
    */
    'id': string;
    /**
    * The name of the edge gateway.
    */
    'name': string;
    /**
    * The description of the edge gateway(optional).
    */
    'description': string;
    /**
    * The uplink connections for the edge gateway.
    */
    'edgeGatewayUplinks': Array<EdgeGatewayUplink>;
    /**
    * A flag indicating whether distributed routing is enabled or not. The default is false.
    */
    'distributedRoutingEnabled': boolean;
    /**
    * The number of Org vDC networks connected to the gateway.
    */
    'orgVdcNetworkCount': number;
    /**
    * The backing details of the edge gateway; only required if importing an NSX-T router.
    */
    'gatewayBacking': EdgeGatewayBacking;
    /**
    * The organization vDC which the gateway belongs to. Property is deprecated. Please use ownerRef. 
    */
    'orgVdc': EntityReference;
    /**
    * The organization vDC or vDC Group that this edge gateway belongs to. If the ownerRef is set to a vDC Group, this gateway will be available across all the participating Organization vDCs in the vDC Group. 
    */
    'ownerRef': EntityReference;
    /**
    * The organization to which the gateway belongs.
    */
    'orgRef': EntityReference;
    /**
    * The network definition in CDIR form that DNS and DHCP service on an NSX-T edge will run on. The subnet prefix length must be 27. This property applies to creating or importing an NSX-T Edge. This is not supported for VMC. If nothing is set, the default is 192.168.255.225/27.  The DHCP listener IP network is on 192.168.255.225/30. The DNS listener IP network is on 192.168.255.228/32.  This field cannot be updated. 
    */
    'serviceNetworkDefinition': string;
    /**
    * Edge Cluster Configuration for the Edge Gateway. Can be specified if a gateway needs to be placed on a specific set of Edge Clusters. For NSX-T Edges, user should specify the ID of the NSX-T edge cluster as the value of primaryEdgeCluster's backingId. The gateway defaults to the Edge Cluster of the connected External Network's backing Tier-0 router, if nothing is specified. The value of secondaryEdgeCluster will be set to NULL for NSX-T edge gateways. For NSX-V Edges, this is read-only and the legacy API must be used for edge specific placement. 
    */
    'edgeClusterConfig': GatewayEdgeClusterConfig;
}

/**
* Subnet for edge gateway that contains the IPs from the external network that are allocated to the edge. 
*/
export class EdgeGatewaySubnet {
    /**
    * The gateway for the subnet.
    */
    'gateway': string;
    /**
    * The prefix length of the subnet.
    */
    'prefixLength': number;
    /**
    * The DNS suffix that VMs attached to this network will use.
    */
    'dnsSuffix': string;
    /**
    * The first DNS server that VMs attached to this network will use.
    */
    'dnsServer1': string;
    /**
    * The second DNS server that VMs attached to this network will use.
    */
    'dnsServer2': string;
    /**
    * Range of IPs within the subnet that can be used in this network. A VM attached to this network is assigned one of these IPs.
    */
    'ipRanges': IpRanges;
    /**
    * Indicates whether the external network subnet is currently enabled.
    */
    'enabled': boolean;
    /**
    * The number of IP addresses defined by the static IP ranges.
    */
    'totalIpCount': number;
    /**
    * The number of IP address used from the static IP ranges.
    */
    'usedIpCount': number;
    /**
    * The primary IP address allocated for this subnet. If not specified, this IP is auto-allocated.  This IP belongs to the external network and can be used for system-configured NAT rules such as DNS forwarder configuration. 
    */
    'primaryIp': string;
    /**
    * Used for create and update api calls. If set to true, IP Ranges are automatically generated based on totalIpCount.
    */
    'autoAllocateIpRanges': boolean;
}

/**
* List of edge gateways 
*/
export class EdgeGateways {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * A list of EdgeGateways.
    */
    'values': Array<EdgeGateway>;
}

/**
* List of configured IPSec VPN tunnels. 
*/
export class EdgeIpSecVpnTunnels {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The list of IPSec VPN tunnels.
    */
    'values': Array<EdgeIpSecVpnTunnel>;
}

/**
* List of configured L2 VPN tunnels. 
*/
export class EdgeL2VpnTunnels {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The list of L2 VPN tunnels.
    */
    'values': Array<EdgeL2VpnTunnel>;
}

/**
* Specifies common properties for Load Balancer Pool objects.
*/
export class EdgeLoadBalancerPoolCommonProperties {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The unique ID of this Load Balancer Pool. On updates, the ID is required for the pool, while for create a new ID will be generated.
    */
    'id': string;
    /**
    * The description of the Load Balancer Pool.
    */
    'description': string;
    /**
    * True if Load Balancer Pool is enabled.
    */
    'enabled': boolean;
    /**
    * Whether passive monitoring for this pool is enabled or not.
    */
    'passiveMonitoringEnabled': boolean;
    /**
    * The current health status of the pool. Possible values are: <ul> <li> UP - The pool is operational. <li> RUNNING - The pool is operational, but less than 50% of the pool members are up. <li> DOWN - All members in the pool are down. <li> DISABLED - Either the pool is disabled or all of the members are disabled. <li> UNAVAILABLE - The pool is unavailable. Examples: pool has no members or pool is not assigned to any virtual service. <li> UNKNOWN - The pool state is unknown. </ul> 
    */
    'healthStatus': string;
    /**
    * The total number of members in the pool.
    */
    'memberCount': number;
    /**
    * The number of enabled members in the pool.
    */
    'enabledMemberCount': number;
    /**
    * The number of enabled members in the pool that are operational.
    */
    'upMemberCount': number;
}

/**
* List of Load Balancer pool summaries.
*/
export class EdgeLoadBalancerPoolSummaries {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The list of Load Balancer pool summaries.
    */
    'values': Array<EdgeLoadBalancerPoolSummary>;
}

/**
* Specifies common properties for Virtual Service objects.
*/
export class EdgeLoadBalancerVirtualServiceCommonProperties {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The identifier of the Virtual Service in URN format
    */
    'id': string;
    /**
    * The name of the Virtual Service. Name is unique across all Virtual Services for an Edge Gateway.
    */
    'name': string;
    /**
    * The description of the Virtual Service.
    */
    'description': string;
    /**
    * A flag indicating whether Virtual Service is enabled or not.
    */
    'enabled': boolean;
    /**
    * The virtual IP Address (VIP) of the Virtual Service. This IP can be an allocated IP to the Gateway from the External Network or it can be an arbitrary internal IP address used for internal load balancing. It it's an internal IP Address, this IP cannot be part of any existing subnet attached to the Edge Gateway or any vDC Group network if the Edge Gateway is scoped accordingly. 
    */
    'virtualIpAddress': string;
    /**
    * The Load Balancer Pool associated with this Virtual Service.
    */
    'loadBalancerPoolRef': EntityReference;
    /**
    * The Edge Gateway associated with this Virtual Service.
    */
    'gatewayRef': EntityReference;
    /**
    * The Load Balancer Service Engine Group that is assigned to the Edge Gateway. This Virtual Service will be deployed to this Service Engine Group. 
    */
    'serviceEngineGroupRef': EntityReference;
    /**
    * The certificate used for SSL termination for the Virtual Service. This is required if the service port type is \"HTTPS\" or \"L4_TLS\".
    */
    'certificateRef': EntityReference;
    /**
    * A list of service ports supported by this Virtual Service.  Multiple service ports are allowed only with additional licensing. 
    */
    'servicePorts': Array<EdgeLoadBalancerServicePort>;
    /**
    * The current health status of the virtual service. Possible values are: <ul> <li> UP - The virtual service is healthy. <li> DOWN - The virtual service is down, inactive, or has failed. <li> DISABLED - The virtual service is disabled. <li> UNAVAILABLE - The virtual service is unavailable. An example is if the virtual service is waiting for resource to be allocated. <li> UNKNOWN - The virtual service state is unknown. </ul> 
    */
    'healthStatus': string;
    /**
    * The localized message on the health of the virtual service.
    */
    'healthMessage': string;
    /**
    * The non-localized detailed message on the health of the virtual service.
    */
    'detailedHealthMessage': string;
}

/**
* List of Virtual Service Summaries.
*/
export class EdgeLoadBalancerVirtualServiceSummaries {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<EdgeLoadBalancerVirtualServiceSummary>;
}

/**
* List of configured NAT Rules.
*/
export class EdgeNatRules {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The list of NAT Rules.
    */
    'values': Array<EdgeNatRule>;
}

export class EncryptedString extends Parameter {
    'value': string;
}

/**
* Quota policy that enforces this quota.
*/
export class EnforcingQuotaPolicy {
    'name': string;
    'id': string;
    /**
    * The entity from which enforcing quota policy is inherited. 
    */
    'inheritedFrom': EntityReference;
}

/**
* A list of entity references. 
*/
export class EntityReferences {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of entity references.
    */
    'values': Array<EntityReference>;
}

/**
* An external network. 
*/
export class ExternalNetwork {
    /**
    * The unique ID for the network. This field is read-only.
    */
    'id': string;
    /**
    * The name of the network.
    */
    'name': string;
    /**
    * The description of the network.
    */
    'description': string;
    /**
    * List of subnets configured for the network.
    */
    'subnets': Subnets;
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * Backings for this external network. Describes if this external network is backed by port groups, vCenter standard switch or an NSX-T Tier-0 router. 
    */
    'networkBackings': ExternalNetworkBackings;
    /**
    * The number of IP addresses defined by the static ip pools. If the network contains any IpV6 subnets, the total ip count will be null.
    */
    'totalIpCount': number;
    /**
    * The number of IP address used from the static ip pools.
    */
    'usedIpCount': number;
    /**
    * The Organization that this external network is dedicated to. This is null if this is not a dedicated external network.
    */
    'dedicatedOrg': EntityReference;
    /**
    * The Edge Gateway that this external network is dedicated to. This is null if this is not a dedicated external network.
    */
    'dedicatedEdgeGateway': EntityReference;
}

/**
* List of External Networks 
*/
export class ExternalNetworks {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<ExternalNetwork>;
}

/**
* A paginated list of external services. 
*/
export class ExternalServices {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<ExternalService>;
}

export class Field extends PresentationElement {
    'decorators': Array<Decorator>;
    'constraints': Array<Constraint>;
    'type': string;
    'affectedFieldsIds': Array<string>;
}

/**
* List of associated VMs for firewall group 
*/
export class FirewallGroupAssociatedVMs {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<FirewallGroupAssociatedVM>;
}

/**
* A Firewall Group object. 
*/
export class FirewallGroupSummary {
    /**
    * The organization that this firewall group belongs to. This property is read-only and cannot be updated. 
    */
    'orgRef': EntityReference;
    /**
    * The edge gateway that this firewall group is scoped to. This means that this firewall group can be used when configuring firewall rules for the edge gateway. This property is now deprecated. ownerRef should be used instead 
    */
    'edgeGatewayRef': EntityReference;
    /**
    * The vDC Group or Edge Gateway that this firewall group is scoped to. This group can be used for configuring rules for either an Edge Gateway or vDC Group. If an Edge Gateway is specified that belongs to a vDC Group, the the firewall group will be scoped to the vDC Group. 
    */
    'ownerRef': EntityReference;
    /**
    * The network provider scope that this object belongs to. This is a read-only property and is determined by the input context entity ID during object creation. 
    */
    'networkProviderScope': string;
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The id of the firewall group.
    */
    'id': string;
    /**
    * The name of the firewall group.
    */
    'name': string;
    /**
    * The description of the firewall group
    */
    'description': string;
    /**
    * Defines the type of Firewall Group. These groups can be used in Firewall Rules to define rules that are scoped to the IP Addresses/Members defined in a Firewall Group. <ul>   <li> <code> IP_SET </code> should be used when using particular IP Addresses of VMs, Networks, etc.   <li> <code> SECURITY_GROUP </code> should be used when specifying exact members such as a particular Org vDC Network. </ul> 
    */
    'type': FirewallGroupType;
}

/**
* List of Firewall Groups 
*/
export class FirewallGroups {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<FirewallGroupSummary>;
}

/**
* List of IP addresses used by an edge gateway. 
*/
export class GatewayUsedIpAddresses {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<GatewayUsedIpAddress>;
}

/**
* A list of global roles. 
*/
export class GlobalRoles {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of global roles.
    */
    'values': Array<GlobalRole>;
}

export class Group extends PresentationElement {
    'fields': Array<PrimaryField>;
}

export class KeyValuePair extends Parameter {
    'key': string;
    'value': Parameter;
}

/**
* A Load Balancer Cloud. 
*/
export class LoadBalancerCloud {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The identifier of the registered Load Balancer Cloud in URN format
    */
    'id': string;
    /**
    * The name of the Load Balancer Cloud. 
    */
    'name': string;
    /**
    * Description for the registered Load Balancer Cloud.
    */
    'description': string;
    /**
    * The backing that uniquely identifies a Load Balancer Cloud configured within a Load Balancer Controller.  At the present, VCD only supports NSX-T Clouds configured within an NSX-ALB Controller deployment. 
    */
    'loadBalancerCloudBacking': LoadBalancerCloudBacking;
    /**
    * The Network Pool associated with this Cloud
    */
    'networkPoolRef': EntityReference;
    /**
    * The current health status of the Load Balancer Cloud. Possible values are: <ul> <li> UP - The cloud is healthy and ready to enable Load Balancer for an Edge Gateway. <li> DOWN - The cloud is in a failure state. Enabling Load balancer on an Edge Gateway may not be possible. <li> RUNNING - The cloud is currently processing. An example is if it's enabling a Load Balancer for an Edge Gateway. <li> UNAVAILABLE - The cloud is unavailable. <li> UNKNOWN - The cloud state is unknown. </ul> 
    */
    'healthStatus': string;
    /**
    * The non-localized detailed message on the health of the Cloud.
    */
    'detailedHealthMessage': string;
}

/**
* List of Load Balancer Clouds. 
*/
export class LoadBalancerClouds {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<LoadBalancerCloud>;
}

/**
* List of Load Balancer Controllers. 
*/
export class LoadBalancerControllers {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<LoadBalancerController>;
}

/**
* A Load Balancer Service Engine Group. 
*/
export class LoadBalancerServiceEngineGroup {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The identifier of the Load Balancer Service Engine Groups in URN format
    */
    'id': string;
    /**
    * The name of the Load Balancer Service Engine Group. 
    */
    'name': string;
    /**
    * Description of the Load Balancer Service Engine Group.
    */
    'description': string;
    /**
    * The backing that uniquely identifies a Load Balancer Service Engine Group configured within a Load Balancer Cloud. 
    */
    'serviceEngineGroupBacking': LoadBalancerServiceEngineGroupBacking;
    /**
    * The service engine group's High Availability Mode. <ul> <li>ELASTIC_N_PLUS_M_BUFFER - Service Engines will scale out to N active nodes with M nodes as buffer. <li>ELASTIC_ACTIVE_ACTIVE - Active-Active with scale out. <li>LEGACY_ACTIVE_STANDBY - Traditional single Active-Standby configuration </ul> 
    */
    'haMode': string;
    /**
    * The reservation model for virutal services on the Load Balancer Service Engine Group. <ul> <li>DEDICATED - Dedicated to a single Edge Gateway and can only be assigned to a single Edge Gateway. <li>SHARED - Shared between multiple Edge Gateways. Can be assigned to multiple Edge Gateways. </ul> 
    */
    'reservationType': string;
    /**
    * The maximum number of virtual services supported on the Load Balancer Service Engine Group. 
    */
    'maxVirtualServices': number;
    /**
    * The number of virtual services currently deployed on the Load Balancer Service Engine Group. 
    */
    'numDeployedVirtualServices': number;
    /**
    * The number of virtual services already reserved on the Load Balancer Service Engine Group. This value is the sum of the guaranteed virtual services given to Edge Gateways assigned to the Load Balancer Service Engine Group. 
    */
    'reservedVirtualServices': number;
    /**
    * Indicates whether the maximum number of virtual services supported on the Load Balancer Service Engine Group has been surpassed by the current number of reserved virtual services. 
    */
    'overAllocated': boolean;
}

/**
* List of Load Balancer Service Engine Group Assignments. 
*/
export class LoadBalancerServiceEngineGroupAssignments {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<LoadBalancerServiceEngineGroupAssignment>;
}

/**
* List of Load Balancer Service Engine Groups. 
*/
export class LoadBalancerServiceEngineGroups {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<LoadBalancerServiceEngineGroup>;
}

/**
* A list of LogicalVmGroups. 
*/
export class LogicalVmGroups {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of LogicalVmGroups.
    */
    'values': Array<LogicalVmGroup>;
}

export class Mandatory extends Constraint {
}

export class MimeAttachment extends Parameter {
    'content': string;
    'name': string;
    'mimeType': string;
}

export class MultiLine extends Decorator {
}

/**
* Describes a networking context profile. Context profiles are groups of similar type of values where each value specifies some layer 7 App Id, or Domain Name. 
*/
export class NetworkContextProfile {
    /**
    * The organization that this object belongs to. This property is required during creation and cannot be updated. 
    */
    'orgRef': EntityReference;
    /**
    * The context under which this object is created. The context can the id of the organization vDC, vDC Group, or network provider. This field is required on object creation and is unset on object reads. This same context ID can be used in the context filter field when querying for the list of objects. 
    */
    'contextEntityId': string;
    /**
    * The network provider scope that this object belongs to. This is a read-only property and is determined by the input context entity ID during object creation. 
    */
    'networkProviderScope': string;
    /**
    * The unique id of this network context profile in URN format.
    */
    'id': string;
    /**
    * Name for the network context profile.
    */
    'name': string;
    /**
    * Description for the network context profile.
    */
    'description': string;
    /**
    * The scope of the network context profile.
    */
    'scope': NetworkContextProfileScopeType;
    /**
    * Array of network context profile attributes.
    */
    'attributes': Array<NetworkContextProfileAttribute>;
}

/**
* List of Network context profiles.
*/
export class NetworkContextProfiles {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<NetworkContextProfile>;
}

/**
* Common fields that NetworkPoolSummary and NetworkPool have. 
*/
export class NetworkPoolSummary {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The id of the Network Pool in URN format.
    */
    'id': string;
    /**
    * The name of the Network Pool. Names for Network Pools must be unique across the system.
    */
    'name': string;
    'description': string;
    /**
    * The network pool backing type.
    */
    'poolType': NetworkPoolBackingType;
    /**
    * Whether promiscuous mode is enabled on the network pool. This is only applicable for VLAN network pools.
    */
    'promiscuousMode': boolean;
    /**
    * The number of backings available for use.
    */
    'totalBackingsCount': number;
    /**
    * The number of network pool backings in use.
    */
    'usedBackingsCount': number;
    /**
    * The Id of vCenter server or the NSX-T manager that manages backings for this network pool.
    */
    'managingOwnerRef': EntityReference;
}

/**
* List of Network Pool Summary Objects. 
*/
export class NetworkPoolsSummary {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<NetworkPoolSummary>;
}

/**
* List of candidate vDCs that can be added to a single vDC Group in the networking context. 
*/
export class NetworkingCandidateVdcs {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<NetworkingCandidateVdc>;
}

/**
* List of NSX-ALB Controller's Clouds. 
*/
export class NsxAlbClouds {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<NsxAlbCloud>;
}

export class NumberFormat extends Constraint {
    'value': string;
}

export class NumberParam extends Parameter {
    'value': number;
}

export class NumberRange extends Constraint {
    'min': number;
    'max': number;
}

/**
* List of vDCs. 
*/
export class OrgVdcs {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<OrgVdc>;
}

/**
* A list of Organizations. 
*/
export class Orgs {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of organizations.
    */
    'values': Array<Org>;
}

/**
* List of standard portgroups. 
*/
export class PortGroups {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<PortGroup>;
}

/**
* A list of preference definitions 
*/
export class PreferenceDefinitions {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page for preference definitions.
    */
    'values': Array<PreferenceDefinition>;
}

/**
* A list of user preferences 
*/
export class Preferences {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The list of user preferences.
    */
    'values': Array<Preference>;
}

export class Properties extends Parameter {
    'property': Array<KeyValuePair>;
}

/**
* List of Provider VDCs. 
*/
export class ProviderVdcs {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<ProviderVdc>;
}

/**
* A paginated list of proxies 
*/
export class Proxies {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<Proxy>;
}

/**
* A paginated list of proxy configurations 
*/
export class ProxyConfigurations {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<ProxyConfiguration>;
}

/**
* RightsMapping that can be published to tenants 
*/
export class PublishableRightsMapping {
    'name': string;
    'id': string;
    'description': string;
    'bundleKey': string;
    'readOnly': boolean;
    /**
    * Read-only value indicating publishAll state 
    */
    'publishAll': boolean;
}

/**
* A list of provider VDC compute policies. 
*/
export class PvdcComputePolicies {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of provider VDC compute policies.
    */
    'values': Array<PvdcComputePolicy>;
}

/**
* A list of provider vDC compute policies. (Version 2.0.0) 
*/
export class PvdcComputePolicies2 {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of provider vDC compute policies.
    */
    'values': Array<PvdcComputePolicy2>;
}

/**
* A list of quota policies. 
*/
export class QuotaPolicies {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of quota policies.
    */
    'values': Array<QuotaPolicy>;
}

export class RefreshOnChange extends Decorator {
}

export class Regex extends Parameter {
    'value': string;
}

export class Regexp extends Constraint {
    'expression': string;
}

/**
* A list of Resource Pools 
*/
export class ResourcePools {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<ResourcePool>;
}

export class RestrictDuplicates extends Constraint {
}

/**
* A list of rights. 
*/
export class Rights {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of rights.
    */
    'values': Array<Right>;
}

export class RightsBundles {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of rights bundles.
    */
    'values': Array<RightsBundle>;
}

/**
* A list of rights category nodes. 
*/
export class RightsCategoryNodes {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of rights category nodes.
    */
    'values': Array<RightsCategoryNode>;
}

export class Role {
    'name': string;
    'id': string;
    'description': string;
    'bundleKey': string;
    'readOnly': boolean;
}

/**
* A list of roles. 
*/
export class Roles {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of roles.
    */
    'values': Array<Role>;
}

/**
* A paginated list of SDDC endpoints 
*/
export class SddcEndpoints {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<SddcEndpoint>;
}

/**
* A paginated list of SDDC proxies 
*/
export class SddcProxies {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<SddcProxy>;
}

/**
* A paginated list of software-defined data centers 
*/
export class Sddcs {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<Sddc>;
}

export class SdkObject extends Parameter {
    'type': string;
    'href': string;
    'id': string;
    'displayValue': string;
}

export class SecureString extends Parameter {
    'value': string;
    'isPlainText': boolean;
}

/**
* List of VMware service applications 
*/
export class ServiceApps {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<ServiceApp>;
}

/**
* A list of service items. 
*/
export class ServiceItems {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of service items.
    */
    'values': Array<ServiceItem>;
}

/**
* A list of services. 
*/
export class Services {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of services.
    */
    'values': Array<Service>;
}

/**
* A list of sessions. 
*/
export class Sessions {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of sessions.
    */
    'values': Array<Session>;
}

export class StepInfo extends PresentationElement {
    'readOnly': boolean;
    'elements': Array<PresentationElement>;
}

/**
* A list of Storage Profiles 
*/
export class StorageProfiles {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<StorageProfile>;
}

export class StringParam extends Parameter {
    'value': string;
}

/**
* An NSX-T's Tier-0 router. 
*/
export class Tier0Router {
    /**
    * The unique id of the router. Field is sortable.
    */
    'id': string;
    /**
    * The description of the router.
    */
    'description': string;
    /**
    * Name used in NSX-T's logs or GUI. Field is sortable.
    */
    'displayName': string;
    /**
    * Id of parent Tier0 if this Tier0 Router is a VRF-Lite Tier0.
    */
    'parentTier0Id': string;
}

/**
* A paginated list of user specific tokens used for accessing proxies. 
*/
export class Tokens {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<Token>;
}

export class UiPluginMetadataResponse {
    'pluginName': string;
    'vendor': string;
    'description': string;
    'version': string;
    'license': string;
    'link': string;
    'tenantScoped': boolean;
    'providerScoped': boolean;
    'enabled': boolean;
    'id': string;
    'pluginStatus': UiPluginMetadataResponse.PluginStatusEnum;
    'resourcePath': string;
}

export namespace UiPluginMetadataResponse {
    export enum PluginStatusEnum {
        Unavailable = <any> 'unavailable',
        Ready = <any> 'ready'
    }
}
/**
* A list of unmanaged Virtual Machines 
*/
export class UnmanagedVirtualMachines {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<UnmanagedVirtualMachine>;
}

/**
* List of used IP addresses. 
*/
export class UsedIpAddresses {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<UsedIpAddress>;
}

/**
* A list of groups. 
*/
export class UserGroups {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of groups.
    */
    'values': Array<UserGroup>;
}

/**
* A list of vCenter servers. 
*/
export class VCenterServers {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of vCenter server.
    */
    'values': Array<VCenterServer>;
}

/**
* A list of Users of an organization. 
*/
export class VcdUsers {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of users.
    */
    'values': Array<VcdUser>;
}

/**
* A list of VDC compute policies. 
*/
export class VdcComputePolicies {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of VDC compute policies.
    */
    'values': Array<VdcComputePolicy>;
}

/**
* A list of vDC compute policies. (Version 2.0.0) 
*/
export class VdcComputePolicies2 {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of vDC compute policies.
    */
    'values': Array<VdcComputePolicy2>;
}

/**
* List of vDC Groups. 
*/
export class VdcGroups {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<VdcGroup>;
}

/**
* An organization vDC network. 
*/
export class VdcNetwork {
    /**
    * The unique ID for the network. This field is read-only.
    */
    'id': string;
    /**
    * The name of the network.
    */
    'name': string;
    /**
    * The description of the network.
    */
    'description': string;
    /**
    * List of subnets configured for the network.
    */
    'subnets': Subnets;
    /**
    * The NSX id of the backing network.
    */
    'backingNetworkId': string;
    /**
    * The object type of the backing network.
    */
    'backingNetworkType': BackingNetworkType;
    /**
    * The parent network if the network is a direct network, otherwise it will be null.
    */
    'parentNetworkId': EntityReference;
    /**
    * The type of network. Changing the network type allows converting between an isolated and routed network. Note that the \"connection\" field must also be set if converting from isolated to routed network. 
    */
    'networkType': VdcNetworkFenceType;
    /**
    * The organization vDC the network belongs to. This should be unset if the network is owned by a vDC Group. For API version 35.0 and above, this field will be treated as read only. Please use ownerRef for new network creation. 
    */
    'orgVdc': EntityReference;
    /**
    * The org vDC or vDC Group that this network belongs to. If the ownerRef is set to a vDC Group, this network will be available across all the vDCs in the vDC Group. If the vDC Group is backed by a NSX-V network provider, the org vDC network is automatically connected to the distributed router associated with the vDC Group and the \"connection\" field does not need to be set. For API version 35.0 and above, this field should be set for network creation. 
    */
    'ownerRef': EntityReference;
    /**
    * The organization to which the network belongs.
    */
    'orgRef': EntityReference;
    /**
    * The edge gateway that the network is attached to. 
    */
    'connection': RouterConnection;
    /**
    * Deprecated unused field, this property will be removed in future release. 
    */
    'isDefaultNetwork': boolean;
    /**
    * Whether this network is shared with other organization vDCs.
    */
    'shared': boolean;
    /**
    * Whether or not this network will support two subnets
    */
    'enableDualSubnetNetwork': boolean;
    /**
    * Description of the network's status. 
    */
    'status': OrgVdcNetworkStatus;
    /**
    * Brief failure message if the last configuration task failed. Deprecated in Api 33.0, this property will be removed in next release. 
    */
    'lastTaskFailureMessage': string;
    /**
    * Whether guest VLAN tagging is allowed.
    */
    'guestVlanTaggingAllowed': boolean;
    /**
    * Whether network resources such as IP/MAC Addresses are to be retained.
    */
    'retainNicResources': boolean;
    /**
    * The id of the cross vdc network if this is a stretched network, otherwise it will be null.
    */
    'crossVdcNetworkId': string;
    /**
    * The id of the org from which this network can be managed if this is a stretched network, otherwise it will be null.
    */
    'crossVdcNetworkLocationId': string;
    /**
    * The number of IP addresses defined by the static ip pools. If the network contains any IpV6 subnets, the total ip count will be null.
    */
    'totalIpCount': number;
    /**
    * The number of IP address used from the static ip pools.
    */
    'usedIpCount': number;
    /**
    * Whether this network is advertised so that it can be routed out to the external networks. This applies only to network backed by NSX-T. Value will be unset if route advertisement is not applicable. 
    */
    'routeAdvertised': boolean;
    /**
    * The list of firewall groups of type SECURITY_GROUP that are assigned to the Org VDC Network. These groups can then be used in firewall rules to protect the Org VDC Network and allow/deny traffic. 
    */
    'securityGroups': Array<EntityReference>;
}

/**
* List of Org vDC networks 
*/
export class VdcNetworks {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<VdcNetwork>;
}

/**
* A list of Virtual Machine Classes. 
*/
export class VirtualMachineClasses {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page Virtual Machine Classes.
    */
    'values': Array<VirtualMachineClass>;
}

/**
* List of VMware Cloud on AWS SDDCs 
*/
export class VmcSddcs {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    'values': Array<VmcSddc>;
}

/**
* A list of remote VRO workflows. 
*/
export class VroRemoteWorkflowItems {
    /**
    * How many results there are in total (i.e., considering all pages).
    */
    'resultTotal': number;
    /**
    * How many pages there are in total.
    */
    'pageCount': number;
    /**
    * The page that was fetched, 1-indexed.
    */
    'page': number;
    /**
    * Result count for page that was fetched.
    */
    'pageSize': number;
    /**
    * Association info for each result.
    */
    'associations': Array<Association>;
    /**
    * The current page of remove VRO workflows.
    */
    'values': Array<VroRemoteWorkflowItem>;
}

export class VroWorkflowServiceItem extends ServiceItem {
    'vroWorkflowId': string;
    'vroServerId': string;
}

/**
* Specifies the Load Balancer pool configuration.
*/
export class EdgeLoadBalancerPool {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The unique ID of this Load Balancer Pool. On updates, the ID is required for the pool, while for create a new ID will be generated.
    */
    'id': string;
    /**
    * The description of the Load Balancer Pool.
    */
    'description': string;
    /**
    * True if Load Balancer Pool is enabled.
    */
    'enabled': boolean;
    /**
    * Whether passive monitoring for this pool is enabled or not.
    */
    'passiveMonitoringEnabled': boolean;
    /**
    * The current health status of the pool. Possible values are: <ul> <li> UP - The pool is operational. <li> RUNNING - The pool is operational, but less than 50% of the pool members are up. <li> DOWN - All members in the pool are down. <li> DISABLED - Either the pool is disabled or all of the members are disabled. <li> UNAVAILABLE - The pool is unavailable. Examples: pool has no members or pool is not assigned to any virtual service. <li> UNKNOWN - The pool state is unknown. </ul> 
    */
    'healthStatus': string;
    /**
    * The total number of members in the pool.
    */
    'memberCount': number;
    /**
    * The number of enabled members in the pool.
    */
    'enabledMemberCount': number;
    /**
    * The number of enabled members in the pool that are operational.
    */
    'upMemberCount': number;
    /**
    * Name for the Load Balancer Pool. Name is unique across all pools for an Edge Gateway.
    */
    'name': string;
    /**
    * The destination server port used by the traffic sent to the member.
    */
    'defaultPort': number;
    /**
    * Maximum time (in minutes) to gracefully disable a member. Virtual service waits for the specified time before terminating the existing connections to the members that are disabled. <code>Special values: 0 represents 'Immediate', -1 represents 'Infinite'.</code> 
    */
    'gracefulTimeoutPeriod': number;
    /**
    * The algorithm for choosing a member within the pool's list of available members for each new connection. Default value is \"LEAST_CONNECTIONS\". Supported algorithms are: <ul> <li>LEAST_CONNECTIONS <li>ROUND_ROBIN <li>FASTEST_RESPONSE <li>CONSISTENT_HASH <li>LEAST_LOAD <li>FEWEST_SERVERS <li>RANDOM <li>FEWEST_TASKS <li>CORE_AFFINITY </ul> 
    */
    'algorithm': string;
    /**
    * Member server's health can be monitored by using one or more health monitors. Active monitors generate synthetic traffic and mark a server up or down based on the response. 
    */
    'healthMonitors': Array<EdgeLoadBalancerHealthMonitor>;
    /**
    * Selected persistence profile for the Load Balancer Pool.
    */
    'persistenceProfile': EdgeLoadBalancerPersistenceProfile;
    /**
    * The list of destination servers which are used by the Load Balancer Pool to direct load balanced traffic. 
    */
    'members': Array<EdgeLoadBalancerPoolMember>;
    /**
    * The list of Load Balancer Virtual Services associated with this Load balancer Pool.
    */
    'virtualServiceRefs': Array<EntityReference>;
    /**
    * The Edge Gateway associated with this Load Balancer Pool.
    */
    'gatewayRef': EntityReference;
    /**
    * The root certificates to use when validating certificates presented by the pool members.
    */
    'caCertificateRefs': Array<EntityReference>;
    /**
    * Whether to check the common name of the certificate presented by the pool member. This cannot be enabled if no caCertificateRefs are specified. 
    */
    'commonNameCheckEnabled': boolean;
    /**
    * A list of domain names which will be used to verify the common names or subject alternative names presented by the pool member certificates. It is performed only when common name check (commonNameCheckEnabled) is enabled. If common name check is enabled, but domain names are not specified then the incoming host header will be used to check the certificate. 
    */
    'domainNames': Array<string>;
}

/**
* Specifies a summary of a Load Balancer pool.
*/
export class EdgeLoadBalancerPoolSummary {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The unique ID of this Load Balancer Pool. On updates, the ID is required for the pool, while for create a new ID will be generated.
    */
    'id': string;
    /**
    * The description of the Load Balancer Pool.
    */
    'description': string;
    /**
    * True if Load Balancer Pool is enabled.
    */
    'enabled': boolean;
    /**
    * Whether passive monitoring for this pool is enabled or not.
    */
    'passiveMonitoringEnabled': boolean;
    /**
    * The current health status of the pool. Possible values are: <ul> <li> UP - The pool is operational. <li> RUNNING - The pool is operational, but less than 50% of the pool members are up. <li> DOWN - All members in the pool are down. <li> DISABLED - Either the pool is disabled or all of the members are disabled. <li> UNAVAILABLE - The pool is unavailable. Examples: pool has no members or pool is not assigned to any virtual service. <li> UNKNOWN - The pool state is unknown. </ul> 
    */
    'healthStatus': string;
    /**
    * The total number of members in the pool.
    */
    'memberCount': number;
    /**
    * The number of enabled members in the pool.
    */
    'enabledMemberCount': number;
    /**
    * The number of enabled members in the pool that are operational.
    */
    'upMemberCount': number;
    /**
    * Name for the Load Balancer Pool. Name is unique across all pools for an Edge Gateway.
    */
    'name': string;
    /**
    * Whether active monitoring for this pool is enabled or not.
    */
    'activeMonitoringEnabled': boolean;
    /**
    * The list of Load Balancer Virtual Services associated with this Load balancer Pool. Only first 10 Virtual Services will be returned. 
    */
    'virtualServiceRefs': Array<EntityReference>;
    /**
    * Whether SSL is enabled for communicatation between the Load Balancer Virtual Services and the pool members 
    */
    'memberSslEnabled': boolean;
}

/**
* A Virtual Service for an Edge Gateway.
*/
export class EdgeLoadBalancerVirtualService {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The identifier of the Virtual Service in URN format
    */
    'id': string;
    /**
    * The name of the Virtual Service. Name is unique across all Virtual Services for an Edge Gateway.
    */
    'name': string;
    /**
    * The description of the Virtual Service.
    */
    'description': string;
    /**
    * A flag indicating whether Virtual Service is enabled or not.
    */
    'enabled': boolean;
    /**
    * The virtual IP Address (VIP) of the Virtual Service. This IP can be an allocated IP to the Gateway from the External Network or it can be an arbitrary internal IP address used for internal load balancing. It it's an internal IP Address, this IP cannot be part of any existing subnet attached to the Edge Gateway or any vDC Group network if the Edge Gateway is scoped accordingly. 
    */
    'virtualIpAddress': string;
    /**
    * The Load Balancer Pool associated with this Virtual Service.
    */
    'loadBalancerPoolRef': EntityReference;
    /**
    * The Edge Gateway associated with this Virtual Service.
    */
    'gatewayRef': EntityReference;
    /**
    * The Load Balancer Service Engine Group that is assigned to the Edge Gateway. This Virtual Service will be deployed to this Service Engine Group. 
    */
    'serviceEngineGroupRef': EntityReference;
    /**
    * The certificate used for SSL termination for the Virtual Service. This is required if the service port type is \"HTTPS\" or \"L4_TLS\".
    */
    'certificateRef': EntityReference;
    /**
    * A list of service ports supported by this Virtual Service.  Multiple service ports are allowed only with additional licensing. 
    */
    'servicePorts': Array<EdgeLoadBalancerServicePort>;
    /**
    * The current health status of the virtual service. Possible values are: <ul> <li> UP - The virtual service is healthy. <li> DOWN - The virtual service is down, inactive, or has failed. <li> DISABLED - The virtual service is disabled. <li> UNAVAILABLE - The virtual service is unavailable. An example is if the virtual service is waiting for resource to be allocated. <li> UNKNOWN - The virtual service state is unknown. </ul> 
    */
    'healthStatus': string;
    /**
    * The localized message on the health of the virtual service.
    */
    'healthMessage': string;
    /**
    * The non-localized detailed message on the health of the virtual service.
    */
    'detailedHealthMessage': string;
    /**
    * Specifies the application profile for the virtual service such as whether it's HTTP, HTTPS, or TCP/UDP.
    */
    'applicationProfile': EdgeLoadBalancerApplicationProfile;
}

/**
* A Virtual Service for an Edge Gateway.
*/
export class EdgeLoadBalancerVirtualServiceSummary {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The identifier of the Virtual Service in URN format
    */
    'id': string;
    /**
    * The name of the Virtual Service. Name is unique across all Virtual Services for an Edge Gateway.
    */
    'name': string;
    /**
    * The description of the Virtual Service.
    */
    'description': string;
    /**
    * A flag indicating whether Virtual Service is enabled or not.
    */
    'enabled': boolean;
    /**
    * The virtual IP Address (VIP) of the Virtual Service. This IP can be an allocated IP to the Gateway from the External Network or it can be an arbitrary internal IP address used for internal load balancing. It it's an internal IP Address, this IP cannot be part of any existing subnet attached to the Edge Gateway or any vDC Group network if the Edge Gateway is scoped accordingly. 
    */
    'virtualIpAddress': string;
    /**
    * The Load Balancer Pool associated with this Virtual Service.
    */
    'loadBalancerPoolRef': EntityReference;
    /**
    * The Edge Gateway associated with this Virtual Service.
    */
    'gatewayRef': EntityReference;
    /**
    * The Load Balancer Service Engine Group that is assigned to the Edge Gateway. This Virtual Service will be deployed to this Service Engine Group. 
    */
    'serviceEngineGroupRef': EntityReference;
    /**
    * The certificate used for SSL termination for the Virtual Service. This is required if the service port type is \"HTTPS\" or \"L4_TLS\".
    */
    'certificateRef': EntityReference;
    /**
    * A list of service ports supported by this Virtual Service.  Multiple service ports are allowed only with additional licensing. 
    */
    'servicePorts': Array<EdgeLoadBalancerServicePort>;
    /**
    * The current health status of the virtual service. Possible values are: <ul> <li> UP - The virtual service is healthy. <li> DOWN - The virtual service is down, inactive, or has failed. <li> DISABLED - The virtual service is disabled. <li> UNAVAILABLE - The virtual service is unavailable. An example is if the virtual service is waiting for resource to be allocated. <li> UNKNOWN - The virtual service state is unknown. </ul> 
    */
    'healthStatus': string;
    /**
    * The localized message on the health of the virtual service.
    */
    'healthMessage': string;
    /**
    * The non-localized detailed message on the health of the virtual service.
    */
    'detailedHealthMessage': string;
    /**
    * The profile type of application that this Virtual Service is configured with. A value of \"-\" represents an unknown type. <ul> <li>HTTP - Virtual Service supports HTTP protocol. <li>HTTPS - Virtual Service supports HTTPS protocol. <li>L4 - Virtual Service supports Layer 4 (Transport) using UDP/TCP protocol. <li>L4_TLS - Virtual Service supports Layer 4 (Transport) using UDP/TCP protocol with TLS. </ul> 
    */
    'applicationProfileType': string;
}

/**
* A Firewall Group object. 
*/
export class FirewallGroupDetails {
    /**
    * The id of the firewall group.
    */
    'id': string;
    /**
    * The name of the firewall group.
    */
    'name': string;
    /**
    * The description of the firewall group
    */
    'description': string;
    /**
    * Defines the type of Firewall Group. These groups can be used in Firewall Rules to define rules that are scoped to the IP Addresses/Members defined in a Firewall Group. <ul>   <li> <code> IP_SET </code> should be used when using particular IP Addresses of VMs, Networks, etc.   <li> <code> SECURITY_GROUP </code> should be used when specifying exact members such as a particular Org vDC Network. </ul> 
    */
    'type': FirewallGroupType;
    /**
    * The organization that this firewall group belongs to. This property is read-only and cannot be updated. 
    */
    'orgRef': EntityReference;
    /**
    * The edge gateway that this firewall group is scoped to. This means that this firewall group can be used when configuring firewall rules for the edge gateway. This property is now deprecated. ownerRef should be used instead 
    */
    'edgeGatewayRef': EntityReference;
    /**
    * The vDC Group or Edge Gateway that this firewall group is scoped to. This group can be used for configuring rules for either an Edge Gateway or vDC Group. If an Edge Gateway is specified that belongs to a vDC Group, the the firewall group will be scoped to the vDC Group. 
    */
    'ownerRef': EntityReference;
    /**
    * The network provider scope that this object belongs to. This is a read-only property and is determined by the input context entity ID during object creation. 
    */
    'networkProviderScope': string;
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * IP Addresses included in the group. This is only applicable for IP_SET Firewall Groups. This can support IPv4 and IPv6 addresses in single, range, and CIDR formats. 
    */
    'ipAddresses': Array<string>;
    /**
    * The list of static member entities such as Org vDC Networks to be used. This is only applicable for SECURITY_GROUP Firewall Groups. The objects used must be scoped to the particular Edge Gateway / vDC Group specified. 
    */
    'members': Array<EntityReference>;
}

export class GlobalRole {
    'name': string;
    'id': string;
    'description': string;
    'bundleKey': string;
    'readOnly': boolean;
    /**
    * Read-only value indicating publishAll state 
    */
    'publishAll': boolean;
}

/**
* A network pool is a group of undifferentiated networks that is available for use within an organization vDC to create certain type of vDC networks such as Organization vDC and Cross vDC networks. 
*/
export class NetworkPool {
    /**
    * Represents current status of the networking object. 
    */
    'status': NetworkingObjectStatusType;
    /**
    * The id of the Network Pool in URN format.
    */
    'id': string;
    /**
    * The name of the Network Pool. Names for Network Pools must be unique across the system.
    */
    'name': string;
    'description': string;
    /**
    * The network pool backing type.
    */
    'poolType': NetworkPoolBackingType;
    /**
    * Whether promiscuous mode is enabled on the network pool. This is only applicable for VLAN network pools.
    */
    'promiscuousMode': boolean;
    /**
    * The number of backings available for use.
    */
    'totalBackingsCount': number;
    /**
    * The number of network pool backings in use.
    */
    'usedBackingsCount': number;
    /**
    * The Id of vCenter server or the NSX-T manager that manages backings for this network pool.
    */
    'managingOwnerRef': EntityReference;
    /**
    * The network pool backing information.
    */
    'backing': NetworkPoolBacking;
}

export class PrimaryField extends Field {
    'fields': Array<Field>;
    'value': Parameter;
}

export class RightsBundle {
    'name': string;
    'id': string;
    'description': string;
    'bundleKey': string;
    'readOnly': boolean;
    /**
    * Read-only value indicating publishAll state 
    */
    'publishAll': boolean;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AccessControlsApiApiKeys {
    ApiKeyAuth,
}

export class AccessControlsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccessControlsApiApiKeys, value: string) {
        this.authentications[AccessControlsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates an access-control grant, giving the user the level of access for the vCD entity. 
     * @summary Creates an access-control grant
     * @param objectId 
     * @param accessControlGrant 
     */
    public createEntityAccessControlGrant (objectId: string, accessControlGrant: AccessControlGrant) : Promise<{ response: http.ClientResponse; body: AccessControlGrant;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{objectId}/accessControls'
            .replace('{' + 'objectId' + '}', String(objectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'objectId' is not null or undefined
        if (objectId === null || objectId === undefined) {
            throw new Error('Required parameter objectId was null or undefined when calling createEntityAccessControlGrant.');
        }

        // verify required parameter 'accessControlGrant' is not null or undefined
        if (accessControlGrant === null || accessControlGrant === undefined) {
            throw new Error('Required parameter accessControlGrant was null or undefined when calling createEntityAccessControlGrant.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: accessControlGrant,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccessControlGrant;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the specified access-control grant. 
     * @summary Get the specified access-control grant.
     * @param objectId 
     * @param accessControlId 
     */
    public getEntityAccessControlGrant (objectId: string, accessControlId: string) : Promise<{ response: http.ClientResponse; body: AccessControlGrant;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{objectId}/accessControls/{accessControlId}'
            .replace('{' + 'objectId' + '}', String(objectId))
            .replace('{' + 'accessControlId' + '}', String(accessControlId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'objectId' is not null or undefined
        if (objectId === null || objectId === undefined) {
            throw new Error('Required parameter objectId was null or undefined when calling getEntityAccessControlGrant.');
        }

        // verify required parameter 'accessControlId' is not null or undefined
        if (accessControlId === null || accessControlId === undefined) {
            throw new Error('Required parameter accessControlId was null or undefined when calling getEntityAccessControlGrant.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccessControlGrant;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the access-control list for the specified vCD entity. 
     * @summary Get the access-control list for the specified vCD entity.
     * @param objectId 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     */
    public queryEntityAccessControlGrants (objectId: string, page: number, pageSize: number) : Promise<{ response: http.ClientResponse; body: AccessControlGrants;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{objectId}/accessControls'
            .replace('{' + 'objectId' + '}', String(objectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'objectId' is not null or undefined
        if (objectId === null || objectId === undefined) {
            throw new Error('Required parameter objectId was null or undefined when calling queryEntityAccessControlGrants.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryEntityAccessControlGrants.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryEntityAccessControlGrants.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccessControlGrants;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes the specified access-control grant from the vCD entities access-control list. 
     * @summary Removes the specified access-control grant from the vCD entities access-control list.
     * @param objectId 
     * @param accessControlId 
     */
    public removeEntityAccessControlGrant (objectId: string, accessControlId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{objectId}/accessControls/{accessControlId}'
            .replace('{' + 'objectId' + '}', String(objectId))
            .replace('{' + 'accessControlId' + '}', String(accessControlId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'objectId' is not null or undefined
        if (objectId === null || objectId === undefined) {
            throw new Error('Required parameter objectId was null or undefined when calling removeEntityAccessControlGrant.');
        }

        // verify required parameter 'accessControlId' is not null or undefined
        if (accessControlId === null || accessControlId === undefined) {
            throw new Error('Required parameter accessControlId was null or undefined when calling removeEntityAccessControlGrant.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the specified access-control grant. 
     * @summary Updates the specified access-control grant.
     * @param objectId 
     * @param accessControlId 
     * @param accessControlGrant 
     */
    public updateEntityAccessControlGrant (objectId: string, accessControlId: string, accessControlGrant: AccessControlGrant) : Promise<{ response: http.ClientResponse; body: AccessControlGrant;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{objectId}/accessControls/{accessControlId}'
            .replace('{' + 'objectId' + '}', String(objectId))
            .replace('{' + 'accessControlId' + '}', String(accessControlId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'objectId' is not null or undefined
        if (objectId === null || objectId === undefined) {
            throw new Error('Required parameter objectId was null or undefined when calling updateEntityAccessControlGrant.');
        }

        // verify required parameter 'accessControlId' is not null or undefined
        if (accessControlId === null || accessControlId === undefined) {
            throw new Error('Required parameter accessControlId was null or undefined when calling updateEntityAccessControlGrant.');
        }

        // verify required parameter 'accessControlGrant' is not null or undefined
        if (accessControlGrant === null || accessControlGrant === undefined) {
            throw new Error('Required parameter accessControlGrant was null or undefined when calling updateEntityAccessControlGrant.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: accessControlGrant,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccessControlGrant;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccessLevelsApiApiKeys {
    ApiKeyAuth,
}

export class AccessLevelsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccessLevelsApiApiKeys, value: string) {
        this.authentications[AccessLevelsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get the specified access level. 
     * @summary Get the specified access level.
     * @param accessLevelUrn 
     */
    public getAccessLevel (accessLevelUrn: string) : Promise<{ response: http.ClientResponse; body: AccessLevel;  }> {
        const localVarPath = this.basePath + '/1.0.0/accessLevels/{accessLevelUrn}'
            .replace('{' + 'accessLevelUrn' + '}', String(accessLevelUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accessLevelUrn' is not null or undefined
        if (accessLevelUrn === null || accessLevelUrn === undefined) {
            throw new Error('Required parameter accessLevelUrn was null or undefined when calling getAccessLevel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccessLevel;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all access levels. 
     * @summary Get all access levels.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryAccessLevels (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: AccessLevels;  }> {
        const localVarPath = this.basePath + '/1.0.0/accessLevels';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryAccessLevels.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryAccessLevels.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccessLevels;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AdvisoryApiApiKeys {
    ApiKeyAuth,
}

export class AdvisoryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AdvisoryApiApiKeys, value: string) {
        this.authentications[AdvisoryApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new advisory definition.
     * @param newAdvisoryDefinition 
     */
    public createAdvisoryDefinition (newAdvisoryDefinition: AdvisoryDefinition) : Promise<{ response: http.ClientResponse; body: AdvisoryDefinition;  }> {
        const localVarPath = this.basePath + '/1.0.0/definitions/advisories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newAdvisoryDefinition' is not null or undefined
        if (newAdvisoryDefinition === null || newAdvisoryDefinition === undefined) {
            throw new Error('Required parameter newAdvisoryDefinition was null or undefined when calling createAdvisoryDefinition.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newAdvisoryDefinition,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdvisoryDefinition;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the advisory with the associated specified id.
     * @param advisoryId advisory URN
     */
    public deleteAdvisoryDefinition (advisoryId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/definitions/advisories/{advisoryId}'
            .replace('{' + 'advisoryId' + '}', String(advisoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'advisoryId' is not null or undefined
        if (advisoryId === null || advisoryId === undefined) {
            throw new Error('Required parameter advisoryId was null or undefined when calling deleteAdvisoryDefinition.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the advisory with the specified id.
     * @param advisoryId advisory URN
     */
    public getAdvisory (advisoryId: string) : Promise<{ response: http.ClientResponse; body: Advisory;  }> {
        const localVarPath = this.basePath + '/1.0.0/advisories/{advisoryId}'
            .replace('{' + 'advisoryId' + '}', String(advisoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'advisoryId' is not null or undefined
        if (advisoryId === null || advisoryId === undefined) {
            throw new Error('Required parameter advisoryId was null or undefined when calling getAdvisory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Advisory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the advisory definition with the specified id.
     * @param advisoryId advisory URN
     */
    public getAdvisoryDefinition (advisoryId: string) : Promise<{ response: http.ClientResponse; body: AdvisoryDefinition;  }> {
        const localVarPath = this.basePath + '/1.0.0/definitions/advisories/{advisoryId}'
            .replace('{' + 'advisoryId' + '}', String(advisoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'advisoryId' is not null or undefined
        if (advisoryId === null || advisoryId === undefined) {
            throw new Error('Required parameter advisoryId was null or undefined when calling getAdvisoryDefinition.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdvisoryDefinition;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all advisories accessible to the user. 
     * @summary Get a list of all advisories accessible to the user.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryAdvisories (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Advisories;  }> {
        const localVarPath = this.basePath + '/1.0.0/advisories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryAdvisories.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryAdvisories.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Advisories;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all advisory definitions. 
     * @summary Get a list of all advisory definitions.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryAdvisoryDefinitions (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: AdvisoryDefinitions;  }> {
        const localVarPath = this.basePath + '/1.0.0/definitions/advisories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryAdvisoryDefinitions.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryAdvisoryDefinitions.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AdvisoryDefinitions;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates an advisory for the active session using a specified id. Advisories that have a MANDATORY priority may not be updated. 
     * @summary Updates an advisory.
     * @param modifiedAdvisory 
     * @param advisoryId advisory URN
     */
    public updateAdvisory (modifiedAdvisory: Advisory, advisoryId: string) : Promise<{ response: http.ClientResponse; body: Advisory;  }> {
        const localVarPath = this.basePath + '/1.0.0/advisories/{advisoryId}'
            .replace('{' + 'advisoryId' + '}', String(advisoryId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'modifiedAdvisory' is not null or undefined
        if (modifiedAdvisory === null || modifiedAdvisory === undefined) {
            throw new Error('Required parameter modifiedAdvisory was null or undefined when calling updateAdvisory.');
        }

        // verify required parameter 'advisoryId' is not null or undefined
        if (advisoryId === null || advisoryId === undefined) {
            throw new Error('Required parameter advisoryId was null or undefined when calling updateAdvisory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: modifiedAdvisory,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Advisory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApplicationPortProfileApiApiKeys {
    ApiKeyAuth,
}

export class ApplicationPortProfileApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApplicationPortProfileApiApiKeys, value: string) {
        this.authentications[ApplicationPortProfileApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific user-defined Application Port Profile
     * @param applicationPortProfileId 
     */
    public deleteApplicationPortProfile (applicationPortProfileId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/applicationPortProfiles/{applicationPortProfileId}'
            .replace('{' + 'applicationPortProfileId' + '}', String(applicationPortProfileId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'applicationPortProfileId' is not null or undefined
        if (applicationPortProfileId === null || applicationPortProfileId === undefined) {
            throw new Error('Required parameter applicationPortProfileId was null or undefined when calling deleteApplicationPortProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific user-defined Application Port Profile
     * @param applicationPortProfileId 
     */
    public getApplicationPortProfile (applicationPortProfileId: string) : Promise<{ response: http.ClientResponse; body: ApplicationPortProfile;  }> {
        const localVarPath = this.basePath + '/1.0.0/applicationPortProfiles/{applicationPortProfileId}'
            .replace('{' + 'applicationPortProfileId' + '}', String(applicationPortProfileId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'applicationPortProfileId' is not null or undefined
        if (applicationPortProfileId === null || applicationPortProfileId === undefined) {
            throw new Error('Required parameter applicationPortProfileId was null or undefined when calling getApplicationPortProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApplicationPortProfile;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific user-defined Application Port Profile
     * @param applicationPortProfile 
     * @param applicationPortProfileId 
     */
    public updateApplicationPortProfile (applicationPortProfile: ApplicationPortProfile, applicationPortProfileId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/applicationPortProfiles/{applicationPortProfileId}'
            .replace('{' + 'applicationPortProfileId' + '}', String(applicationPortProfileId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'applicationPortProfile' is not null or undefined
        if (applicationPortProfile === null || applicationPortProfile === undefined) {
            throw new Error('Required parameter applicationPortProfile was null or undefined when calling updateApplicationPortProfile.');
        }

        // verify required parameter 'applicationPortProfileId' is not null or undefined
        if (applicationPortProfileId === null || applicationPortProfileId === undefined) {
            throw new Error('Required parameter applicationPortProfileId was null or undefined when calling updateApplicationPortProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: applicationPortProfile,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApplicationPortProfilesApiApiKeys {
    ApiKeyAuth,
}

export class ApplicationPortProfilesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApplicationPortProfilesApiApiKeys, value: string) {
        this.authentications[ApplicationPortProfilesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a user-defined application port profile.
     * @param applicationPortProfile 
     */
    public createApplicationPortProfile (applicationPortProfile: ApplicationPortProfile) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/applicationPortProfiles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'applicationPortProfile' is not null or undefined
        if (applicationPortProfile === null || applicationPortProfile === undefined) {
            throw new Error('Required parameter applicationPortProfile was null or undefined when calling createApplicationPortProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: applicationPortProfile,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all Application Port Profiles. This includes user-defined profiles and default system profile. Supported contexts are: Org vDC ID (_context==orgVdcId) - | Returns all the application port profiles which are available to a specific Org vDC. Network provider ID (_context==networkProviderId) - | Returns all the application port profiles which are available under a specific network provider. VDC Group Id <code>(_context==vdcGroupId)</code> - | Returns all the application port profiles which are available to a specific vDC Group. 
     * @summary Get all Application Port Profiles.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getApplicationPortProfiles (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: ApplicationPortProfiles;  }> {
        const localVarPath = this.basePath + '/1.0.0/applicationPortProfiles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getApplicationPortProfiles.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getApplicationPortProfiles.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApplicationPortProfiles;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sync the application port profiles from the network provider to VCD. The network provider is required to be specified in the filter context. Context example: (_context==networkProviderId). 
     * @summary Sync the application port profiles from the network provider to VCD.
     * @param filter Filter for a query.  FIQL format.
     */
    public syncApplicationPortProfiles (filter?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/applicationPortProfiles/sync';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuditTrailApiApiKeys {
    ApiKeyAuth,
}

export class AuditTrailApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuditTrailApiApiKeys, value: string) {
        this.authentications[AuditTrailApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get list of audit trail events 
     * @summary Get list of audit trail events
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryAuditTrail (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: AuditTrailEvents;  }> {
        const localVarPath = this.basePath + '/1.0.0/auditTrail';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryAuditTrail.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryAuditTrail.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AuditTrailEvents;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BrandingApiApiKeys {
    ApiKeyAuth,
}

export class BrandingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BrandingApiApiKeys, value: string) {
        this.authentications[BrandingApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new custom theme, uniquely identified by name.  This can be used to set the theme in \"/branding\". 
     * @summary Create a new custom theme
     * @param newTheme 
     */
    public createBrandingTheme (newTheme: UiTheme) : Promise<{ response: http.ClientResponse; body: UiTheme;  }> {
        const localVarPath = this.basePath + '/branding/themes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newTheme' is not null or undefined
        if (newTheme === null || newTheme === undefined) {
            throw new Error('Required parameter newTheme was null or undefined when calling createBrandingTheme.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newTheme,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiTheme;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a custom theme 
     * @summary Delete an existing custom theme
     * @param name 
     */
    public deleteBrandingTheme (name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/themes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteBrandingTheme.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a custom theme's contents 
     * @summary Delete an existing custom theme's contents
     * @param name 
     */
    public deleteBrandingThemeContents (name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/themes/{name}/contents'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteBrandingThemeContents.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete the system level icon, forcing the get method to return the vCloud Director default icon. 
     * @summary Delete system level icon
     */
    public deleteSystemIcon () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/icon';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete the system level logo, forcing the get method to return the vCloud Director default logo. 
     * @summary Delete system level logo
     */
    public deleteSystemLogo () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/logo';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete the system level icon, forcing the get method to return the vCloud Director default icon. 
     * @summary Delete system level icon
     * @param org Organization for whom branding is being set
     */
    public deleteTenantIcon (org: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/tenant/{org}/icon'
            .replace('{' + 'org' + '}', String(org));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling deleteTenantIcon.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete the org-specific logo, forcing the get method to return the system default logo. 
     * @summary Delete the org-specific logo
     * @param org Organization for whom branding is being set
     */
    public deleteTenantLogo (org: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/tenant/{org}/logo'
            .replace('{' + 'org' + '}', String(org));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling deleteTenantLogo.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing theme, uniquely identified by name. 
     * @summary Retrieve a specified theme identified by name
     * @param name 
     */
    public getBrandingTheme (name: string) : Promise<{ response: http.ClientResponse; body: UiTheme;  }> {
        const localVarPath = this.basePath + '/branding/themes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getBrandingTheme.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiTheme;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the CSS for this theme if it has been set 
     * @summary Retrieve the custom CSS for this theme, if any
     * @param name 
     */
    public getBrandingThemeCss (name: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/branding/themes/{name}/css'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getBrandingThemeCss.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of supported themes, uniquely identified by their names.  This can be used to set the theme in \"/branding\". 
     * @summary Get a list of themes
     */
    public getBrandingThemes () : Promise<{ response: http.ClientResponse; body: Array<UiTheme>;  }> {
        const localVarPath = this.basePath + '/branding/themes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<UiTheme>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the system level branding information including the portal name, portal color, selected theme and custom URLs. 
     * @summary Gets the system level branding
     */
    public getSystemBranding () : Promise<{ response: http.ClientResponse; body: UiBranding;  }> {
        const localVarPath = this.basePath + '/branding';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiBranding;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the system level icon as raw image data suitable for use in an image tag's src attribute.  If a custom icon is not set then the vCloud Director default icon is sent. 
     * @summary Gets the system level browser icon
     */
    public getSystemIcon () : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/branding/icon';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the system level logo as raw image data suitable for use in an image tag's src attribute.  If a custom logo is not set then the vCloud Director default logo is sent. 
     * @summary Gets the system level logo
     */
    public getSystemLogo () : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/branding/logo';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get org-specific branding information including the portal name, portal color, selected theme and custom URLs. If no org branding has been specified, retrieve the default system branding. 
     * @summary Gets org-specific branding
     * @param org Organization for whom branding is being set
     */
    public getTenantBranding (org: string) : Promise<{ response: http.ClientResponse; body: UiBranding;  }> {
        const localVarPath = this.basePath + '/branding/tenant/{org}'
            .replace('{' + 'org' + '}', String(org));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling getTenantBranding.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiBranding;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the system level icon as raw image data suitable for use in an image tag's src attribute.  If a custom icon is not set then the vCloud Director default icon is sent. 
     * @summary Gets the system level browser icon
     * @param org Organization for whom branding is being set
     */
    public getTenantIcon (org: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/branding/tenant/{org}/icon'
            .replace('{' + 'org' + '}', String(org));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling getTenantIcon.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the org-specific logo as raw image data suitable for use in an image tag's src attribute. If an org-specific logo is not set, get the default system logo.  If a custom logo is not set then the vCloud Director default logo is sent. 
     * @summary Gets the org-specific logo
     * @param org Organization for whom branding is being set
     */
    public getTenantLogo (org: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/branding/tenant/{org}/logo'
            .replace('{' + 'org' + '}', String(org));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling getTenantLogo.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sets the branding information including the portal name, portal color, selected theme and custom URLs for a specific org or system default. 
     * @summary Sets default branding
     * @param body 
     */
    public putSystemBranding (body: UiBranding) : Promise<{ response: http.ClientResponse; body: UiBranding;  }> {
        const localVarPath = this.basePath + '/branding';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putSystemBranding.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiBranding;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the system icon data. 
     * @summary Sets the system level icon
     * @param contentType 
     * @param body 
     */
    public putSystemIcon (contentType: string, body: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/icon';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling putSystemIcon.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putSystemIcon.');
        }

        headerParams['Content-Type'] = contentType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the system logo data. 
     * @summary Sets the system level logo
     * @param contentType 
     * @param body 
     */
    public putSystemLogo (contentType: string, body: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/logo';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling putSystemLogo.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putSystemLogo.');
        }

        headerParams['Content-Type'] = contentType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sets the branding information including the portal name, portal color, selected theme and custom URLs for a specific org. 
     * @summary Sets org-specific branding
     * @param body 
     * @param org Organization for whom branding is being set
     */
    public putTenantBranding (body: UiBranding, org: string) : Promise<{ response: http.ClientResponse; body: UiBranding;  }> {
        const localVarPath = this.basePath + '/branding/tenant/{org}'
            .replace('{' + 'org' + '}', String(org));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putTenantBranding.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling putTenantBranding.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiBranding;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the system icon data. 
     * @summary Sets the system level icon
     * @param contentType 
     * @param body 
     * @param org Organization for whom branding is being set
     */
    public putTenantIcon (contentType: string, body: string, org: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/tenant/{org}/icon'
            .replace('{' + 'org' + '}', String(org));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling putTenantIcon.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putTenantIcon.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling putTenantIcon.');
        }

        headerParams['Content-Type'] = contentType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the org-specific data. 
     * @summary Sets the org-specific logo
     * @param contentType 
     * @param body 
     * @param org Organization for whom branding is being set
     */
    public putTenantLogo (contentType: string, body: string, org: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/tenant/{org}/logo'
            .replace('{' + 'org' + '}', String(org));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling putTenantLogo.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putTenantLogo.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling putTenantLogo.');
        }

        headerParams['Content-Type'] = contentType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes org-specific branding information if specified 
     * @summary Remove org-specific branding
     * @param org Organization for whom branding is being set
     */
    public removeTenantBranding (org: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/tenant/{org}'
            .replace('{' + 'org' + '}', String(org));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling removeTenantBranding.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing custom theme, uniquely identified by name.  This can be used to set the theme in \"/branding\". 
     * @summary Update an existing custom theme
     * @param updatedTheme 
     * @param name 
     */
    public updateBrandingTheme (updatedTheme: UiTheme, name: string) : Promise<{ response: http.ClientResponse; body: UiTheme;  }> {
        const localVarPath = this.basePath + '/branding/themes/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedTheme' is not null or undefined
        if (updatedTheme === null || updatedTheme === undefined) {
            throw new Error('Required parameter updatedTheme was null or undefined when calling updateBrandingTheme.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateBrandingTheme.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedTheme,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiTheme;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing custom theme's contents, uniquely identified by name. Currently, this is limited to a single CSS file. 
     * @summary Upload the contents for this theme
     * @param pluginUploadSpec 
     * @param name 
     */
    public uploadBrandingThemeContents (pluginUploadSpec: UploadSpec, name: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/branding/themes/{name}/contents'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pluginUploadSpec' is not null or undefined
        if (pluginUploadSpec === null || pluginUploadSpec === undefined) {
            throw new Error('Required parameter pluginUploadSpec was null or undefined when calling uploadBrandingThemeContents.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling uploadBrandingThemeContents.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pluginUploadSpec,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CapabilitiesApiApiKeys {
    ApiKeyAuth,
}

export class CapabilitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CapabilitiesApiApiKeys, value: string) {
        this.authentications[CapabilitiesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves the current capabilities configured on a specific organization VDC storage policy. These cannot be edited. 
     * @summary Retrieves capabilities of a specific organization VDC storage policy.
     * @param id 
     */
    public getOrgVdcStoragePolicyCapabilities (id: string) : Promise<{ response: http.ClientResponse; body: Capabilities;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcStoragePolicies/{id}/capabilities'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOrgVdcStoragePolicyCapabilities.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Capabilities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the current capabilities configured on a specific provider VDC storage policy. These cannot be edited. 
     * @summary Retrieves capabilities of a specific provider VDC storage policy.
     * @param id 
     */
    public getPvdcStoragePolicyCapabilities (id: string) : Promise<{ response: http.ClientResponse; body: Capabilities;  }> {
        const localVarPath = this.basePath + '/1.0.0/pvdcStoragePolicies/{id}/capabilities'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPvdcStoragePolicyCapabilities.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Capabilities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves capabilities for quotaPolicy feature.
     */
    public getQuotaPolicyCapabilities () : Promise<{ response: http.ClientResponse; body: Capabilities;  }> {
        const localVarPath = this.basePath + '/1.0.0/quotaPolicy/capabilities';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Capabilities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves capabilities for the given Organization vDC.
     * @param orgVdcId 
     */
    public getVdcCapabilities (orgVdcId: string) : Promise<{ response: http.ClientResponse; body: Capabilities;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcs/{orgVdcId}/capabilities'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling getVdcCapabilities.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Capabilities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the supported capabilities of the specified vDC Group.
     * @param vdcGroupId 
     */
    public getVdcGroupCapabilities (vdcGroupId: string) : Promise<{ response: http.ClientResponse; body: Capabilities;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/capabilities'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling getVdcGroupCapabilities.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Capabilities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CellApiApiKeys {
    ApiKeyAuth,
}

export class CellApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CellApiApiKeys, value: string) {
        this.authentications[CellApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specified cell.
     * @param cellUrn cellUrn
     */
    public deleteCell (cellUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/cells/{cellUrn}'
            .replace('{' + 'cellUrn' + '}', String(cellUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cellUrn' is not null or undefined
        if (cellUrn === null || cellUrn === undefined) {
            throw new Error('Required parameter cellUrn was null or undefined when calling deleteCell.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a cell. Read only. 
     * @summary Get cell.
     * @param cellUrn cellUrn
     */
    public getCell (cellUrn: string) : Promise<{ response: http.ClientResponse; body: Cell;  }> {
        const localVarPath = this.basePath + '/1.0.0/cells/{cellUrn}'
            .replace('{' + 'cellUrn' + '}', String(cellUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cellUrn' is not null or undefined
        if (cellUrn === null || cellUrn === undefined) {
            throw new Error('Required parameter cellUrn was null or undefined when calling getCell.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Cell;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of cells 
     * @summary Get cells.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryCells (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Cells;  }> {
        const localVarPath = this.basePath + '/1.0.0/cells';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryCells.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryCells.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Cells;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CertificateLibraryApiApiKeys {
    ApiKeyAuth,
}

export class CertificateLibraryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CertificateLibraryApiApiKeys, value: string) {
        this.authentications[CertificateLibraryApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add an item to the certificate library 
     * @summary Add an item to the certificate library
     * @param newCertificateLibraryItem 
     */
    public addCertificateLibraryItem (newCertificateLibraryItem: CertificateLibraryItem) : Promise<{ response: http.ClientResponse; body: CertificateLibraryItem;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/certificateLibrary';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newCertificateLibraryItem' is not null or undefined
        if (newCertificateLibraryItem === null || newCertificateLibraryItem === undefined) {
            throw new Error('Required parameter newCertificateLibraryItem was null or undefined when calling addCertificateLibraryItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newCertificateLibraryItem,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CertificateLibraryItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Adds the specified consumer reference to a library item. 
     * @summary Adds the specified consumer reference to a library item.
     * @param consumerReference 
     * @param certLibraryItemId 
     */
    public addConsumerRefToCertLibraryItem (consumerReference: EntityReference, certLibraryItemId: string) : Promise<{ response: http.ClientResponse; body: EntityReference;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/certificateLibrary/{certLibraryItemId}/consumers'
            .replace('{' + 'certLibraryItemId' + '}', String(certLibraryItemId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'consumerReference' is not null or undefined
        if (consumerReference === null || consumerReference === undefined) {
            throw new Error('Required parameter consumerReference was null or undefined when calling addConsumerRefToCertLibraryItem.');
        }

        // verify required parameter 'certLibraryItemId' is not null or undefined
        if (certLibraryItemId === null || certLibraryItemId === undefined) {
            throw new Error('Required parameter certLibraryItemId was null or undefined when calling addConsumerRefToCertLibraryItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: consumerReference,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReference;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete the specified certificate library item. Only items that are not in use can be deleted.
     * @summary Remove certificate library item
     * @param id 
     */
    public deleteCertificateLibraryItem (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/cetificateLibrary/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCertificateLibraryItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the specified certificate library item
     * @param id 
     */
    public getCertificateLibraryItem (id: string) : Promise<{ response: http.ClientResponse; body: CertificateLibraryItem;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/cetificateLibrary/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCertificateLibraryItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CertificateLibraryItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of consumers (as references) of a particular certificate library item 
     * @summary Gets a paged list of consumers (as references) of a particular certificate library item
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param certLibraryItemId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryCertLibraryItemConsumerRefs (page: number, pageSize: number, certLibraryItemId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/certificateLibrary/{certLibraryItemId}/consumers'
            .replace('{' + 'certLibraryItemId' + '}', String(certLibraryItemId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryCertLibraryItemConsumerRefs.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryCertLibraryItemConsumerRefs.');
        }

        // verify required parameter 'certLibraryItemId' is not null or undefined
        if (certLibraryItemId === null || certLibraryItemId === undefined) {
            throw new Error('Required parameter certLibraryItemId was null or undefined when calling queryCertLibraryItemConsumerRefs.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of the certificate library items 
     * @summary Get the certificate libray items
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryCertificateLibrary (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: CertificateLibraryItems;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/certificateLibrary';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryCertificateLibrary.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryCertificateLibrary.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CertificateLibraryItems;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replaces the existing consumer refs with the consumer references supplied. 
     * @summary Replaces the existing consumer refs with the used by references supplied.
     * @param consumerRefs 
     * @param certLibraryItemId 
     */
    public replaceCertLibraryItemConsumerRefs (consumerRefs: EntityReferences, certLibraryItemId: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/certificateLibrary/{certLibraryItemId}/consumers'
            .replace('{' + 'certLibraryItemId' + '}', String(certLibraryItemId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'consumerRefs' is not null or undefined
        if (consumerRefs === null || consumerRefs === undefined) {
            throw new Error('Required parameter consumerRefs was null or undefined when calling replaceCertLibraryItemConsumerRefs.');
        }

        // verify required parameter 'certLibraryItemId' is not null or undefined
        if (certLibraryItemId === null || certLibraryItemId === undefined) {
            throw new Error('Required parameter certLibraryItemId was null or undefined when calling replaceCertLibraryItemConsumerRefs.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: consumerRefs,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update the specified certificate library item. Only the alias and description fields may be edited
     * @param modifiedCertificatLibraryItem 
     * @param id 
     */
    public updateCertificateLibraryItem (modifiedCertificatLibraryItem: CertificateLibraryItem, id: string) : Promise<{ response: http.ClientResponse; body: CertificateLibraryItem;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/cetificateLibrary/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'modifiedCertificatLibraryItem' is not null or undefined
        if (modifiedCertificatLibraryItem === null || modifiedCertificatLibraryItem === undefined) {
            throw new Error('Required parameter modifiedCertificatLibraryItem was null or undefined when calling updateCertificateLibraryItem.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCertificateLibraryItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: modifiedCertificatLibraryItem,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CertificateLibraryItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CloudApiBaseApiApiKeys {
    ApiKeyAuth,
}

export class CloudApiBaseApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CloudApiBaseApiApiKeys, value: string) {
        this.authentications[CloudApiBaseApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves links to start navigation
     * @summary Get base navigation links
     */
    public getBaseLinks () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CodegenPlaceholderApiApiKeys {
    ApiKeyAuth,
}

export class CodegenPlaceholderApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CodegenPlaceholderApiApiKeys, value: string) {
        this.authentications[CodegenPlaceholderApiApiKeys[key]].apiKey = value;
    }
    /**
     * This endpoint will not produce results. It is a placeholder to enforce code generation of Page.
     * @summary This endpoint will not produce results. It is a placeholder to enforce code generation of Page.
     */
    public getQueryResult () : Promise<{ response: http.ClientResponse; body: Page;  }> {
        const localVarPath = this.basePath + '/query/page';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Page;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CrossVdcNetworkApiApiKeys {
    ApiKeyAuth,
}

export class CrossVdcNetworkApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CrossVdcNetworkApiApiKeys, value: string) {
        this.authentications[CrossVdcNetworkApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific Cross vDC network
     * @param crossVdcNetworkId 
     * @param force Value \&quot;true\&quot; means to forcefully delete the object that contains other objects even if those objects are in a state that does not allow removal. The default is \&quot;false\&quot;; therefore, objects are not removed if they are not in a state that normally allows removal. Force also implies recursive delete where other contained objects are removed. Errors may be ignored. Invalid value (not true or false) are ignored. 
     */
    public deleteCrossVdcNetwork (crossVdcNetworkId: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/crossVdcNetworks/{crossVdcNetworkId}'
            .replace('{' + 'crossVdcNetworkId' + '}', String(crossVdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'crossVdcNetworkId' is not null or undefined
        if (crossVdcNetworkId === null || crossVdcNetworkId === undefined) {
            throw new Error('Required parameter crossVdcNetworkId was null or undefined when calling deleteCrossVdcNetwork.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific Cross vDC network.
     * @param crossVdcNetworkId 
     */
    public getCrossVdcNetwork (crossVdcNetworkId: string) : Promise<{ response: http.ClientResponse; body: CrossVdcNetwork;  }> {
        const localVarPath = this.basePath + '/1.0.0/crossVdcNetworks/{crossVdcNetworkId}'
            .replace('{' + 'crossVdcNetworkId' + '}', String(crossVdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'crossVdcNetworkId' is not null or undefined
        if (crossVdcNetworkId === null || crossVdcNetworkId === undefined) {
            throw new Error('Required parameter crossVdcNetworkId was null or undefined when calling getCrossVdcNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CrossVdcNetwork;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sync/repair the specific cross vdc network 
     * @summary Sync/repair a specific Cross vDC network.
     * @param crossVdcNetworkId 
     */
    public syncCrossVdcNetwork (crossVdcNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/crossVdcNetworks/{crossVdcNetworkId}/sync'
            .replace('{' + 'crossVdcNetworkId' + '}', String(crossVdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'crossVdcNetworkId' is not null or undefined
        if (crossVdcNetworkId === null || crossVdcNetworkId === undefined) {
            throw new Error('Required parameter crossVdcNetworkId was null or undefined when calling syncCrossVdcNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific Cross vDC network.
     * @param crossVdcNetwork 
     * @param crossVdcNetworkId 
     */
    public updateCrossVdcNetwork (crossVdcNetwork: CrossVdcNetwork, crossVdcNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/crossVdcNetworks/{crossVdcNetworkId}'
            .replace('{' + 'crossVdcNetworkId' + '}', String(crossVdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'crossVdcNetwork' is not null or undefined
        if (crossVdcNetwork === null || crossVdcNetwork === undefined) {
            throw new Error('Required parameter crossVdcNetwork was null or undefined when calling updateCrossVdcNetwork.');
        }

        // verify required parameter 'crossVdcNetworkId' is not null or undefined
        if (crossVdcNetworkId === null || crossVdcNetworkId === undefined) {
            throw new Error('Required parameter crossVdcNetworkId was null or undefined when calling updateCrossVdcNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: crossVdcNetwork,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CrossVdcNetworksApiApiKeys {
    ApiKeyAuth,
}

export class CrossVdcNetworksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CrossVdcNetworksApiApiKeys, value: string) {
        this.authentications[CrossVdcNetworksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a Cross vDC network.
     * @param crossVdcNetwork 
     */
    public createCrossVdcNetwork (crossVdcNetwork: CrossVdcNetwork) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/crossVdcNetworks';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'crossVdcNetwork' is not null or undefined
        if (crossVdcNetwork === null || crossVdcNetwork === undefined) {
            throw new Error('Required parameter crossVdcNetwork was null or undefined when calling createCrossVdcNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: crossVdcNetwork,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all Cross vDC networks in the system. 
     * @summary Get all Cross vDC networks in the system.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getAllCrossVdcNetworks (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: CrossVdcNetworks;  }> {
        const localVarPath = this.basePath + '/1.0.0/crossVdcNetworks';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getAllCrossVdcNetworks.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getAllCrossVdcNetworks.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CrossVdcNetworks;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all Cross vDC networks of a vDC group.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param vdcGroupId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getAllCrossVdcNetworksForVdcGroup (page: number, pageSize: number, vdcGroupId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: CrossVdcNetworks;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/crossVdcNetworks'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getAllCrossVdcNetworksForVdcGroup.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getAllCrossVdcNetworksForVdcGroup.');
        }

        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling getAllCrossVdcNetworksForVdcGroup.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CrossVdcNetworks;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomEntitiesApiApiKeys {
    ApiKeyAuth,
}

export class CustomEntitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomEntitiesApiApiKeys, value: string) {
        this.authentications[CustomEntitiesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a new custom entity type 
     * @summary Creates a new custom entity type
     * @param newCustomEntityType 
     */
    public createCustomEntityType (newCustomEntityType: CustomEntityType) : Promise<{ response: http.ClientResponse; body: CustomEntityType;  }> {
        const localVarPath = this.basePath + '/customEntityTypes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newCustomEntityType' is not null or undefined
        if (newCustomEntityType === null || newCustomEntityType === undefined) {
            throw new Error('Required parameter newCustomEntityType was null or undefined when calling createCustomEntityType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newCustomEntityType,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomEntityType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new custom entity type action 
     * @summary Creates a new custom entity type action.
     * @param newCustomEntityTypeAction 
     * @param customEntityTypeId 
     */
    public createCustomEntityTypeAction (newCustomEntityTypeAction: CreateCustomEntityTypeAction, customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: CustomEntityTypeAction;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}/actions'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newCustomEntityTypeAction' is not null or undefined
        if (newCustomEntityTypeAction === null || newCustomEntityTypeAction === undefined) {
            throw new Error('Required parameter newCustomEntityTypeAction was null or undefined when calling createCustomEntityTypeAction.');
        }

        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling createCustomEntityTypeAction.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newCustomEntityTypeAction,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomEntityTypeAction;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified custom entity type.
     * @param recursive if true, will recursively delete both custom entity type, all its instances and associated actions
     * @param customEntityTypeId 
     */
    public deleteCustomEntityType (recursive: boolean, customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'recursive' is not null or undefined
        if (recursive === null || recursive === undefined) {
            throw new Error('Required parameter recursive was null or undefined when calling deleteCustomEntityType.');
        }

        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling deleteCustomEntityType.');
        }

        if (recursive !== undefined) {
            queryParameters['recursive'] = recursive;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified custom entity type action
     * @param customEntityTypeId 
     * @param workflowId 
     */
    public deleteCustomEntityTypeAction (customEntityTypeId: string, workflowId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}/actions/{workflowId}'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId))
            .replace('{' + 'workflowId' + '}', String(workflowId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling deleteCustomEntityTypeAction.');
        }

        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling deleteCustomEntityTypeAction.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of custom entities 
     * @summary Get list of all custom entities
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getCustomEntities (filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: CustomEntities;  }> {
        const localVarPath = this.basePath + '/customEntities';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomEntities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified custom entity
     * @param customEntityId 
     */
    public getCustomEntity (customEntityId: string) : Promise<{ response: http.ClientResponse; body: CustomEntity;  }> {
        const localVarPath = this.basePath + '/customEntities/{customEntityId}'
            .replace('{' + 'customEntityId' + '}', String(customEntityId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customEntityId' is not null or undefined
        if (customEntityId === null || customEntityId === undefined) {
            throw new Error('Required parameter customEntityId was null or undefined when calling getCustomEntity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomEntity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified custom entity represented as on Sdk-Object
     * @param customEntityId 
     */
    public getCustomEntityAsSdkObject (customEntityId: string) : Promise<{ response: http.ClientResponse; body: SdkObject;  }> {
        const localVarPath = this.basePath + '/customEntities/{customEntityId}/sdkObject'
            .replace('{' + 'customEntityId' + '}', String(customEntityId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customEntityId' is not null or undefined
        if (customEntityId === null || customEntityId === undefined) {
            throw new Error('Required parameter customEntityId was null or undefined when calling getCustomEntityAsSdkObject.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SdkObject;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified custom entity type
     * @param customEntityTypeId 
     */
    public getCustomEntityType (customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: CustomEntityType;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling getCustomEntityType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomEntityType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all actions associated with this custom entity type
     * @param customEntityTypeId 
     */
    public getCustomEntityTypeActions (customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: CustomEntityTypeActions;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}/actions'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling getCustomEntityTypeActions.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomEntityTypeActions;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves list of item for whom the custom entity type is explicitly published 
     * @summary Retrieves list of tenants for whom the custom entity type is explicitly published
     * @param customEntityTypeId 
     */
    public getCustomEntityTypeTenants (customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}/tenants'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling getCustomEntityTypeTenants.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the custom entity type to the specified tenants 
     * @summary Publishes the custom entity type to the specified tenants
     * @param publishTenantsBody 
     * @param customEntityTypeId 
     */
    public postCustomEntityTypePublish (publishTenantsBody: Array<EntityReference>, customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}/tenants/publish'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling postCustomEntityTypePublish.');
        }

        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling postCustomEntityTypePublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the custom entity type to all tenants 
     * @summary Publishes the custom entity type to all tenants
     * @param customEntityTypeId 
     */
    public postCustomEntityTypePublishAll (customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}/tenants/publishAll'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling postCustomEntityTypePublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revokes publication of the custom entity type to the specified tenants 
     * @summary Revokes publication of the custom entity type to the specified tenants
     * @param unpublishTenantsBody 
     * @param customEntityTypeId 
     */
    public postCustomEntityTypeUnpublish (unpublishTenantsBody: Array<EntityReference>, customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}/tenants/unpublish'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'unpublishTenantsBody' is not null or undefined
        if (unpublishTenantsBody === null || unpublishTenantsBody === undefined) {
            throw new Error('Required parameter unpublishTenantsBody was null or undefined when calling postCustomEntityTypeUnpublish.');
        }

        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling postCustomEntityTypeUnpublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unpublishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unpublishes the custom entity type from all tenants 
     * @summary Unpublishes the custom entity type from all tenants
     * @param customEntityTypeId 
     */
    public postCustomEntityTypeUnpublishAll (customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}/tenants/unpublishAll'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling postCustomEntityTypeUnpublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of custom entity types. 
     * @summary Get list of all custom entity types
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryCustomEntityTypes (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: CustomEntityTypes;  }> {
        const localVarPath = this.basePath + '/customEntityTypes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryCustomEntityTypes.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryCustomEntityTypes.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomEntityTypes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resets list of tenants for whom the custom entity type is explicitly published 
     * @summary Resets list of tenants for whom the custom entity type is explicitly published
     * @param publishTenantsBody 
     * @param customEntityTypeId 
     */
    public setCustomEntityTypeTenants (publishTenantsBody: Array<EntityReference>, customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}/tenants'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling setCustomEntityTypeTenants.');
        }

        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling setCustomEntityTypeTenants.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified custom entity type
     * @param updatedCustomEntityType 
     * @param customEntityTypeId 
     */
    public updateCustomEntityType (updatedCustomEntityType: CustomEntityType, customEntityTypeId: string) : Promise<{ response: http.ClientResponse; body: CustomEntityType;  }> {
        const localVarPath = this.basePath + '/customEntityTypes/{customEntityTypeId}'
            .replace('{' + 'customEntityTypeId' + '}', String(customEntityTypeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedCustomEntityType' is not null or undefined
        if (updatedCustomEntityType === null || updatedCustomEntityType === undefined) {
            throw new Error('Required parameter updatedCustomEntityType was null or undefined when calling updateCustomEntityType.');
        }

        // verify required parameter 'customEntityTypeId' is not null or undefined
        if (customEntityTypeId === null || customEntityTypeId === undefined) {
            throw new Error('Required parameter customEntityTypeId was null or undefined when calling updateCustomEntityType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedCustomEntityType,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomEntityType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefinedEntityApiApiKeys {
    ApiKeyAuth,
}

export class DefinedEntityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefinedEntityApiApiKeys, value: string) {
        this.authentications[DefinedEntityApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a defined entity based on the entity type (URN).
     * @summary Creates a defined entity based on the entity type (URN).
     * @param entity 
     * @param id 
     */
    public createDefinedEntity (entity: DefinedEntity, id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'entity' is not null or undefined
        if (entity === null || entity === undefined) {
            throw new Error('Required parameter entity was null or undefined when calling createDefinedEntity.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createDefinedEntity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: entity,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes the defined entity with the unique identifier (URN)
     * @summary Deletes the defined entity with the unique identifier (URN)
     * @param id 
     */
    public deleteDefinedEntity (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDefinedEntity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the collection of defined entities for the vCD-defined type with the specified vendor, nss and version. The version can act as a wildcard. If only '1' is specified as the version, all entity types with a major version of '1' will be matched (e.g. 1.0.0, 1.1.2). If '1.0' is specified, all entity types with a major version of '1' and a minor version of '0' will be included (e.g. 1.0.0, 1.0.1). If the full semver is specified, then no search will be performed. 
     * @summary Gets the collection of defined entities for the vCD-defined type with the specified vendor, nss and version.
     * @param vendor 
     * @param nss 
     * @param version 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getDefinedEntitiesByEntityType (vendor: string, nss: string, version: string, page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: DefinedEntities;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/types/{vendor}/{nss}/{version}'
            .replace('{' + 'vendor' + '}', String(vendor))
            .replace('{' + 'nss' + '}', String(nss))
            .replace('{' + 'version' + '}', String(version));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vendor' is not null or undefined
        if (vendor === null || vendor === undefined) {
            throw new Error('Required parameter vendor was null or undefined when calling getDefinedEntitiesByEntityType.');
        }

        // verify required parameter 'nss' is not null or undefined
        if (nss === null || nss === undefined) {
            throw new Error('Required parameter nss was null or undefined when calling getDefinedEntitiesByEntityType.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getDefinedEntitiesByEntityType.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getDefinedEntitiesByEntityType.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getDefinedEntitiesByEntityType.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedEntities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the collection of defined entities for the vCD-defined interface with the specified vendor, nss and version. The version can act as a wildcard. If only '1' is specified as the version, all entity types with a major version of '1' will be matched (e.g. 1.0.0, 1.1.2). If '1.0' is specified, all entity types with a major version of '1' and a minor version of '0' will be included (e.g. 1.0.0, 1.0.1). If the full semver is specified, then no search will be performed. 
     * @summary Gets the collection of defined entities for the vCD-defined interface with the specified vendor, nss and version
     * @param vendor 
     * @param nss 
     * @param version 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getDefinedEntitiesByInterface (vendor: string, nss: string, version: string, page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: DefinedEntities;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/interfaces/{vendor}/{nss}/{version}'
            .replace('{' + 'vendor' + '}', String(vendor))
            .replace('{' + 'nss' + '}', String(nss))
            .replace('{' + 'version' + '}', String(version));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vendor' is not null or undefined
        if (vendor === null || vendor === undefined) {
            throw new Error('Required parameter vendor was null or undefined when calling getDefinedEntitiesByInterface.');
        }

        // verify required parameter 'nss' is not null or undefined
        if (nss === null || nss === undefined) {
            throw new Error('Required parameter nss was null or undefined when calling getDefinedEntitiesByInterface.');
        }

        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getDefinedEntitiesByInterface.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getDefinedEntitiesByInterface.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getDefinedEntitiesByInterface.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedEntities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the defined entity with the unique identifier (URN)
     * @summary Gets the defined entity with the unique identifier (URN)
     * @param id 
     */
    public getDefinedEntity (id: string) : Promise<{ response: http.ClientResponse; body: DefinedEntity;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDefinedEntity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedEntity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Validates the defined entity against the entity type schema. If the validation is successful, the entity will transition to a \"RESOLVED\" state. Otherwise, it will transition to an \"ERROR\" state. 
     * @summary Validates the defined entity against the entity type schema.
     * @param id 
     */
    public resolveDefinedEntity (id: string) : Promise<{ response: http.ClientResponse; body: EntityState;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{id}/resolve'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling resolveDefinedEntity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityState;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the defined entity with the unique identifier (URN)
     * @summary Updates the defined entity with the unique identifier (URN)
     * @param entity 
     * @param id 
     */
    public updateDefinedEntity (entity: DefinedEntity, id: string) : Promise<{ response: http.ClientResponse; body: DefinedEntity;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'entity' is not null or undefined
        if (entity === null || entity === undefined) {
            throw new Error('Required parameter entity was null or undefined when calling updateDefinedEntity.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateDefinedEntity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: entity,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedEntity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefinedEntityTypeApiApiKeys {
    ApiKeyAuth,
}

export class DefinedEntityTypeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefinedEntityTypeApiApiKeys, value: string) {
        this.authentications[DefinedEntityTypeApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a defined entity type.
     * @summary Creates a defined entity type.
     * @param definition 
     */
    public createDefinedEntityType (definition: DefinedEntityType) : Promise<{ response: http.ClientResponse; body: DefinedEntityType;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'definition' is not null or undefined
        if (definition === null || definition === undefined) {
            throw new Error('Required parameter definition was null or undefined when calling createDefinedEntityType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: definition,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedEntityType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes the entity type with the unique identifier (URN)
     * @summary Deletes the entity type with the unique identifier (URN)
     * @param id 
     */
    public deleteDefinedEntityType (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteDefinedEntityType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the entity type with the unique identifier (URN)
     * @summary Gets the entity type with the unique identifier (URN)
     * @param id 
     */
    public getDefinedEntityType (id: string) : Promise<{ response: http.ClientResponse; body: DefinedEntityType;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDefinedEntityType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedEntityType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the collection of entity types defined in the vCD instance. Allows collection refinement through traditional FIQL-based filtering
     * @summary Gets the collection of entity types defined in the vCD instance. Allows collection refinement through traditional FIQL-based filtering
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getDefinedEntityTypes (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: DefinedEntityTypes;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getDefinedEntityTypes.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getDefinedEntityTypes.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedEntityTypes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the entity type with the unique identifier (URN)
     * @summary Updates the entity type with the unique identifier (URN)
     * @param definition 
     * @param id 
     */
    public updateDefinedEntityType (definition: DefinedEntityType, id: string) : Promise<{ response: http.ClientResponse; body: DefinedEntityType;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'definition' is not null or undefined
        if (definition === null || definition === undefined) {
            throw new Error('Required parameter definition was null or undefined when calling updateDefinedEntityType.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateDefinedEntityType.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: definition,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedEntityType;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefinedInterfaceApiApiKeys {
    ApiKeyAuth,
}

export class DefinedInterfaceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefinedInterfaceApiApiKeys, value: string) {
        this.authentications[DefinedInterfaceApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a defined interface. The version must follow semantic versioning rules. 
     * @summary Creates a defined interface.
     * @param definedInterface 
     */
    public createInterface (definedInterface: DefinedInterface) : Promise<{ response: http.ClientResponse; body: DefinedInterface;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'definedInterface' is not null or undefined
        if (definedInterface === null || definedInterface === undefined) {
            throw new Error('Required parameter definedInterface was null or undefined when calling createInterface.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: definedInterface,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedInterface;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes the interface with the unique identifier (URN) 
     * @summary Deletes the interface with the unique identifier (URN)
     * @param id 
     */
    public deleteInterface (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteInterface.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the interface with the unique identifier (URN) 
     * @summary Gets the interface with the unique identifier (URN)
     * @param id 
     */
    public getInterface (id: string) : Promise<{ response: http.ClientResponse; body: DefinedInterface;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInterface.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedInterface;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the collection of interfaces defined in the vCD instance. Allows collection refinement through traditional FIQL-based filtering
     * @summary Gets the collection of interfaces defined in the vCD instance. Allows collection refinement through traditional FIQL-based filtering
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryInterfaces (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: DefinedInterfaces;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryInterfaces.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryInterfaces.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedInterfaces;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the interface with the unique identifier (URN) The version must follow semantic versioning rules. 
     * @summary Updates the interface with the unique identifier (URN)
     * @param definedInterface 
     * @param id 
     */
    public updateInterface (definedInterface: DefinedInterface, id: string) : Promise<{ response: http.ClientResponse; body: DefinedInterface;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'definedInterface' is not null or undefined
        if (definedInterface === null || definedInterface === undefined) {
            throw new Error('Required parameter definedInterface was null or undefined when calling updateInterface.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateInterface.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: definedInterface,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefinedInterface;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefinedInterfaceBehaviorsApiApiKeys {
    ApiKeyAuth,
}

export class DefinedInterfaceBehaviorsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefinedInterfaceBehaviorsApiApiKeys, value: string) {
        this.authentications[DefinedInterfaceBehaviorsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Adds an access control configuration of an entity type's behavior
     * @summary Adds an access control configuration of an entity type's behavior
     * @param definition 
     * @param id 
     */
    public addDefinedEntityTypeAccess (definition: BehaviorAccess, id: string) : Promise<{ response: http.ClientResponse; body: BehaviorAccess;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}/behaviorAccessControls'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'definition' is not null or undefined
        if (definition === null || definition === undefined) {
            throw new Error('Required parameter definition was null or undefined when calling addDefinedEntityTypeAccess.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addDefinedEntityTypeAccess.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: definition,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BehaviorAccess;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a new Behavior to the Interface. Only allowed if the Interface is not in use. 
     * @summary Add a new interface Behavior if the Interface is not in use
     * @param behavior 
     * @param id 
     */
    public addInterfaceBehavior (behavior: Behavior, id: string) : Promise<{ response: http.ClientResponse; body: Behavior;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces/{id}/behaviors'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'behavior' is not null or undefined
        if (behavior === null || behavior === undefined) {
            throw new Error('Required parameter behavior was null or undefined when calling addInterfaceBehavior.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addInterfaceBehavior.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: behavior,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Behavior;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a Behavior from the Defined Interface. The Behaviors can be specified by ID or by name. 
     * @summary Remove a Behavior from the Defined Interface.
     * @param id 
     * @param behaviorId 
     */
    public deleteInterfaceBehavior (id: string, behaviorId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces/{id}/behaviors/{behaviorId}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'behaviorId' + '}', String(behaviorId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteInterfaceBehavior.');
        }

        // verify required parameter 'behaviorId' is not null or undefined
        if (behaviorId === null || behaviorId === undefined) {
            throw new Error('Required parameter behaviorId was null or undefined when calling deleteInterfaceBehavior.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the access control configuration of the entity type's behaviors
     * @summary Gets the access control configuration of the entity type's behaviors
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id 
     */
    public getDefinedEntityTypeAccess (page: number, pageSize: number, id: string) : Promise<{ response: http.ClientResponse; body: BehaviorAccesses;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}/behaviorAccessControls'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getDefinedEntityTypeAccess.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getDefinedEntityTypeAccess.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDefinedEntityTypeAccess.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BehaviorAccesses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the Behaviors of the specified Defined Entity Type. 
     * @summary Get the Behaviors of the Defined Entity Type.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id 
     */
    public getDefinedEntityTypeBehaviors (page: number, pageSize: number, id: string) : Promise<{ response: http.ClientResponse; body: Behaviors;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}/behaviors'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getDefinedEntityTypeBehaviors.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getDefinedEntityTypeBehaviors.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDefinedEntityTypeBehaviors.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Behaviors;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a specific Behavior in the specified Defined Interface. 
     * @summary Get a Behavior in the Defined Interface.
     * @param id 
     * @param behaviorId 
     */
    public getInterfaceBehavior (id: string, behaviorId: string) : Promise<{ response: http.ClientResponse; body: Behavior;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces/{id}/behaviors/{behaviorId}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'behaviorId' + '}', String(behaviorId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInterfaceBehavior.');
        }

        // verify required parameter 'behaviorId' is not null or undefined
        if (behaviorId === null || behaviorId === undefined) {
            throw new Error('Required parameter behaviorId was null or undefined when calling getInterfaceBehavior.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Behavior;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the Behaviors of the specified Defined Interface. 
     * @summary Get the Behaviors of the Defined Interface.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id 
     */
    public getInterfaceBehaviors (page: number, pageSize: number, id: string) : Promise<{ response: http.ClientResponse; body: Behaviors;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces/{id}/behaviors'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getInterfaceBehaviors.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getInterfaceBehaviors.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInterfaceBehaviors.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Behaviors;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a specific Behavior in the Defined Type. The Behavior must be specified by ID. 
     * @summary Get a Behavior in the Defined Type
     * @param id 
     * @param behaviorId 
     */
    public getTypeBehavior (id: string, behaviorId: string) : Promise<{ response: http.ClientResponse; body: Behavior;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}/behaviors/{behaviorId}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'behaviorId' + '}', String(behaviorId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTypeBehavior.');
        }

        // verify required parameter 'behaviorId' is not null or undefined
        if (behaviorId === null || behaviorId === undefined) {
            throw new Error('Required parameter behaviorId was null or undefined when calling getTypeBehavior.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Behavior;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Invokes a behavior on a defined entity. The contract of the behavior is specified in the behavior description. If an Activity behavior is invoked with an 'operationId' in the invocation metadata, then another invocation of the behavior with the same 'operationId' will be ignored within the next 1 hour. 
     * @summary Invokes a behavior on a defined entity
     * @param id 
     * @param behaviorId 
     * @param invocation 
     */
    public invokeDefinedEntityBehavior (id: string, behaviorId: string, invocation?: BehaviorInvocation) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/entities/{id}/behaviors/{behaviorId}/invocations'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'behaviorId' + '}', String(behaviorId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling invokeDefinedEntityBehavior.');
        }

        // verify required parameter 'behaviorId' is not null or undefined
        if (behaviorId === null || behaviorId === undefined) {
            throw new Error('Required parameter behaviorId was null or undefined when calling invokeDefinedEntityBehavior.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: invocation,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a Behavior override in the Defined Entity Type. The Behavior must be specified by ID. 
     * @summary Remove a Behavior override from the Defined Entity Type.
     * @param id 
     * @param behaviorId 
     */
    public removeBehaviorOverride (id: string, behaviorId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}/behaviors/{behaviorId}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'behaviorId' + '}', String(behaviorId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeBehaviorOverride.');
        }

        // verify required parameter 'behaviorId' is not null or undefined
        if (behaviorId === null || behaviorId === undefined) {
            throw new Error('Required parameter behaviorId was null or undefined when calling removeBehaviorOverride.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sets the access control configuration of the entity type's behaviors
     * @summary Sets the access control configuration of the entity type's behaviors
     * @param definition 
     * @param id 
     */
    public setDefinedEntityTypeAccess (definition: BehaviorAccesses, id: string) : Promise<{ response: http.ClientResponse; body: BehaviorAccesses;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}/behaviorAccessControls'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'definition' is not null or undefined
        if (definition === null || definition === undefined) {
            throw new Error('Required parameter definition was null or undefined when calling setDefinedEntityTypeAccess.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setDefinedEntityTypeAccess.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: definition,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BehaviorAccesses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the execution of the specified Behavior in the Defined Interface. The Behaviors can be specified by ID or by name. 
     * @summary Update the execution of the specified Behavior in the Defined Interface
     * @param behavior 
     * @param id 
     * @param behaviorId 
     */
    public updateInterfaceBehavior (behavior: Behavior, id: string, behaviorId: string) : Promise<{ response: http.ClientResponse; body: Behavior;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces/{id}/behaviors/{behaviorId}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'behaviorId' + '}', String(behaviorId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'behavior' is not null or undefined
        if (behavior === null || behavior === undefined) {
            throw new Error('Required parameter behavior was null or undefined when calling updateInterfaceBehavior.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateInterfaceBehavior.');
        }

        // verify required parameter 'behaviorId' is not null or undefined
        if (behaviorId === null || behaviorId === undefined) {
            throw new Error('Required parameter behaviorId was null or undefined when calling updateInterfaceBehavior.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: behavior,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Behavior;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update all Behaviors, possibly adding or removing some if the Interface is not in use. If the Interface is in use, then only the executions of the existing Behaviors can be updated. The Behaviors can be specified by ID or by name. 
     * @summary Update all the executions of the specified Behaviors (possibly removing or adding some)
     * @param behaviors 
     * @param id 
     */
    public updateInterfaceBehaviors (behaviors: Behaviors, id: string) : Promise<{ response: http.ClientResponse; body: Behaviors;  }> {
        const localVarPath = this.basePath + '/1.0.0/interfaces/{id}/behaviors'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'behaviors' is not null or undefined
        if (behaviors === null || behaviors === undefined) {
            throw new Error('Required parameter behaviors was null or undefined when calling updateInterfaceBehaviors.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateInterfaceBehaviors.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: behaviors,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Behaviors;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Override the execution of the specified Behavior in the Defined Entity Type. The Behavior must be specified by ID. 
     * @summary Update the execution of the specified Behavior in the Defined Entity Type
     * @param behavior 
     * @param id 
     * @param behaviorId 
     */
    public updateTypeBehavior (behavior: Behavior, id: string, behaviorId: string) : Promise<{ response: http.ClientResponse; body: Behavior;  }> {
        const localVarPath = this.basePath + '/1.0.0/entityTypes/{id}/behaviors/{behaviorId}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'behaviorId' + '}', String(behaviorId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'behavior' is not null or undefined
        if (behavior === null || behavior === undefined) {
            throw new Error('Required parameter behavior was null or undefined when calling updateTypeBehavior.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTypeBehavior.');
        }

        // verify required parameter 'behaviorId' is not null or undefined
        if (behaviorId === null || behaviorId === undefined) {
            throw new Error('Required parameter behaviorId was null or undefined when calling updateTypeBehavior.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: behavior,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Behavior;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DfwPoliciesApiApiKeys {
    ApiKeyAuth,
}

export class DfwPoliciesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DfwPoliciesApiApiKeys, value: string) {
        this.authentications[DfwPoliciesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves the current state of DFW along with all the DFW security policies for a given networking and security domain. 
     * @summary Retrieves DFW security policies configuration.
     * @param vdcGroupId 
     */
    public getDfwPolicies (vdcGroupId: string) : Promise<{ response: http.ClientResponse; body: DfwPolicies;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling getDfwPolicies.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DfwPolicies;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the DFW security policies for a given networking and security domain. A default security policy will be created when DFW is enabled. Removing a security policy will result in removal of the policy and all of its associated firewall rules. 
     * @summary Update DFW security policies configuration.
     * @param dfwPolicies 
     * @param vdcGroupId 
     */
    public updateDfwPolicies (dfwPolicies: DfwPolicies, vdcGroupId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dfwPolicies' is not null or undefined
        if (dfwPolicies === null || dfwPolicies === undefined) {
            throw new Error('Required parameter dfwPolicies was null or undefined when calling updateDfwPolicies.');
        }

        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling updateDfwPolicies.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dfwPolicies,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DfwPolicyApiApiKeys {
    ApiKeyAuth,
}

export class DfwPolicyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DfwPolicyApiApiKeys, value: string) {
        this.authentications[DfwPolicyApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific DFW security policy. Removing a security policy will result in removal of the policy and all of its associated firewall rules. 
     * @param vdcGroupId 
     * @param policyId 
     */
    public deleteDfwPolicy (vdcGroupId: string, policyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies/{policyId}'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId))
            .replace('{' + 'policyId' + '}', String(policyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling deleteDfwPolicy.');
        }

        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling deleteDfwPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a specific firewall rule for a given DFW security policy.
     * @param vdcGroupId 
     * @param policyId 
     * @param ruleId 
     */
    public deleteDfwRule (vdcGroupId: string, policyId: string, ruleId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies/{policyId}/rules/{ruleId}'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId))
            .replace('{' + 'policyId' + '}', String(policyId))
            .replace('{' + 'ruleId' + '}', String(ruleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling deleteDfwRule.');
        }

        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling deleteDfwRule.');
        }

        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling deleteDfwRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific DFW security policy.
     * @param vdcGroupId 
     * @param policyId 
     */
    public getDfwPolicy (vdcGroupId: string, policyId: string) : Promise<{ response: http.ClientResponse; body: DfwPolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies/{policyId}'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId))
            .replace('{' + 'policyId' + '}', String(policyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling getDfwPolicy.');
        }

        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling getDfwPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DfwPolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific firewall rule for a given DFW security policy.
     * @param vdcGroupId 
     * @param policyId 
     * @param ruleId 
     */
    public getDfwRule (vdcGroupId: string, policyId: string, ruleId: string) : Promise<{ response: http.ClientResponse; body: DfwRule;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies/{policyId}/rules/{ruleId}'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId))
            .replace('{' + 'policyId' + '}', String(policyId))
            .replace('{' + 'ruleId' + '}', String(ruleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling getDfwRule.');
        }

        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling getDfwRule.');
        }

        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling getDfwRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DfwRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all firewall rules for a given DFW security policy. The rules are returned in the order of precedence. 
     * @summary Retrieves all firewall rules for a given DFW security policy.
     * @param vdcGroupId 
     * @param policyId 
     */
    public getDfwRules (vdcGroupId: string, policyId: string) : Promise<{ response: http.ClientResponse; body: DfwRules;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies/{policyId}/rules'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId))
            .replace('{' + 'policyId' + '}', String(policyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling getDfwRules.');
        }

        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling getDfwRules.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DfwRules;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific DFW security policy.
     * @param dfwPolicy 
     * @param vdcGroupId 
     * @param policyId 
     */
    public updateDfwPolicy (dfwPolicy: DfwPolicy, vdcGroupId: string, policyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies/{policyId}'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId))
            .replace('{' + 'policyId' + '}', String(policyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dfwPolicy' is not null or undefined
        if (dfwPolicy === null || dfwPolicy === undefined) {
            throw new Error('Required parameter dfwPolicy was null or undefined when calling updateDfwPolicy.');
        }

        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling updateDfwPolicy.');
        }

        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling updateDfwPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dfwPolicy,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific firewall rule for a given DFW security policy.
     * @param dfwRule 
     * @param vdcGroupId 
     * @param policyId 
     * @param ruleId 
     */
    public updateDfwRule (dfwRule: DfwRule, vdcGroupId: string, policyId: string, ruleId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies/{policyId}/rules/{ruleId}'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId))
            .replace('{' + 'policyId' + '}', String(policyId))
            .replace('{' + 'ruleId' + '}', String(ruleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dfwRule' is not null or undefined
        if (dfwRule === null || dfwRule === undefined) {
            throw new Error('Required parameter dfwRule was null or undefined when calling updateDfwRule.');
        }

        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling updateDfwRule.');
        }

        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling updateDfwRule.');
        }

        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling updateDfwRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dfwRule,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates all the firewall rules for a given DFW security policy. If a rule with the ruleId is not already present, a new rule will be created. If it already exists, the rule will be updated. Any existing rule that is not specified in the update payload will be deleted. The order of rules in payload will define the actual order in which this rules will be applied. 
     * @summary Updates firewall rules for a given DFW security policy.
     * @param dfwRules 
     * @param vdcGroupId 
     * @param policyId 
     */
    public updateDfwRules (dfwRules: DfwRules, vdcGroupId: string, policyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/dfwPolicies/{policyId}/rules'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId))
            .replace('{' + 'policyId' + '}', String(policyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dfwRules' is not null or undefined
        if (dfwRules === null || dfwRules === undefined) {
            throw new Error('Required parameter dfwRules was null or undefined when calling updateDfwRules.');
        }

        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling updateDfwRules.');
        }

        // verify required parameter 'policyId' is not null or undefined
        if (policyId === null || policyId === undefined) {
            throw new Error('Required parameter policyId was null or undefined when calling updateDfwRules.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dfwRules,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DvpgPropertiesApiApiKeys {
    ApiKeyAuth,
}

export class DvpgPropertiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DvpgPropertiesApiApiKeys, value: string) {
        this.authentications[DvpgPropertiesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Returns the DVPG properties, such as promiscuous mode and forged transmit, of a specific Org vDC network. This is a SysAdmin only API.
     * @param vdcNetworkId 
     */
    public getDvpgProperties (vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body: DvpgProperties;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}/dvpgProperties'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling getDvpgProperties.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DvpgProperties;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles the DVPG properties of a specific Org vDC network. Allows for update of promiscuous mode and forged transmit. This is a SysAdmin only API.
     * @param dvpgProperties 
     * @param vdcNetworkId 
     */
    public updateDvpgProperties (dvpgProperties: DvpgProperties, vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}/dvpgProperties'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dvpgProperties' is not null or undefined
        if (dvpgProperties === null || dvpgProperties === undefined) {
            throw new Error('Required parameter dvpgProperties was null or undefined when calling updateDvpgProperties.');
        }

        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling updateDvpgProperties.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dvpgProperties,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeClusterApiApiKeys {
    ApiKeyAuth,
}

export class EdgeClusterApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeClusterApiApiKeys, value: string) {
        this.authentications[EdgeClusterApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific Edge Cluster
     * @param edgeClusterId 
     */
    public deleteEdgeCluster (edgeClusterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeClusters/{edgeClusterId}'
            .replace('{' + 'edgeClusterId' + '}', String(edgeClusterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'edgeClusterId' is not null or undefined
        if (edgeClusterId === null || edgeClusterId === undefined) {
            throw new Error('Required parameter edgeClusterId was null or undefined when calling deleteEdgeCluster.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific Edge Cluster
     * @param edgeClusterId 
     */
    public getEdgeCluster (edgeClusterId: string) : Promise<{ response: http.ClientResponse; body: EdgeCluster;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeClusters/{edgeClusterId}'
            .replace('{' + 'edgeClusterId' + '}', String(edgeClusterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'edgeClusterId' is not null or undefined
        if (edgeClusterId === null || edgeClusterId === undefined) {
            throw new Error('Required parameter edgeClusterId was null or undefined when calling getEdgeCluster.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeCluster;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific Edge Cluster
     * @param edgeCluster 
     * @param edgeClusterId 
     */
    public updateEdgeCluster (edgeCluster: EdgeCluster, edgeClusterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeClusters/{edgeClusterId}'
            .replace('{' + 'edgeClusterId' + '}', String(edgeClusterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'edgeCluster' is not null or undefined
        if (edgeCluster === null || edgeCluster === undefined) {
            throw new Error('Required parameter edgeCluster was null or undefined when calling updateEdgeCluster.');
        }

        // verify required parameter 'edgeClusterId' is not null or undefined
        if (edgeClusterId === null || edgeClusterId === undefined) {
            throw new Error('Required parameter edgeClusterId was null or undefined when calling updateEdgeCluster.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: edgeCluster,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeClustersApiApiKeys {
    ApiKeyAuth,
}

export class EdgeClustersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeClustersApiApiKeys, value: string) {
        this.authentications[EdgeClustersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new Edge Cluster. An Edge Cluster is defined by a Resouce Pool and Storage Profile for deploying Edge Gateways. It can subsequently be assigned to a given vDC Network Profile as a Primary or Secondary Edge Cluster. 
     * @summary Create a new Edge Cluster
     * @param edgeCluster 
     */
    public createEdgeCluster (edgeCluster: EdgeCluster) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeClusters';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'edgeCluster' is not null or undefined
        if (edgeCluster === null || edgeCluster === undefined) {
            throw new Error('Required parameter edgeCluster was null or undefined when calling createEdgeCluster.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: edgeCluster,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all Edge Clusters. Results can be filtered by id, name and vCenter (resourcePool.vcId). 
     * @summary Get all Edge Clusters in the system
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getEdgeClusters (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EdgeClusters;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeClusters';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getEdgeClusters.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getEdgeClusters.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeClusters;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayApiApiKeys, value: string) {
        this.authentications[EdgeGatewayApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific Edge Gateway
     * @param gatewayId 
     * @param force Value \&quot;true\&quot; means to forcefully delete the object that contains other objects even if those objects are in a state that does not allow removal. The default is \&quot;false\&quot;; therefore, objects are not removed if they are not in a state that normally allows removal. Force also implies recursive delete where other contained objects are removed. Errors may be ignored. Invalid value (not true or false) are ignored. 
     */
    public deleteEdgeGateway (gatewayId: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling deleteEdgeGateway.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific Edge Gateway
     * @param gatewayId 
     */
    public getEdgeGateway (gatewayId: string) : Promise<{ response: http.ClientResponse; body: EdgeGateway;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getEdgeGateway.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeGateway;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all the IP Addresses which are being used by the Edge Gateway such as the primary IP or an IP used by a given Edge Service, such as NAT. These IP addresses are a subset of the IPs allocated from the connected external networks. If the IP is  being consumed by any of the configured services on the edge gateway then name of service will be returned. 
     * @summary Retrieve the list of IP addresses which are being used by the edge gateway.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param gatewayId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getUsedIpAddresses (page: number, pageSize: number, gatewayId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: GatewayUsedIpAddresses;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/usedIpAddresses'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getUsedIpAddresses.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getUsedIpAddresses.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getUsedIpAddresses.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GatewayUsedIpAddresses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific Edge Gateway
     * @param gateway 
     * @param gatewayId 
     */
    public updateEdgeGateway (gateway: EdgeGateway, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gateway' is not null or undefined
        if (gateway === null || gateway === undefined) {
            throw new Error('Required parameter gateway was null or undefined when calling updateEdgeGateway.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateEdgeGateway.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: gateway,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayBgpApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayBgpApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayBgpApiApiKeys, value: string) {
        this.authentications[EdgeGatewayBgpApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves the general BGP configuration for an edge gateway. 
     * @summary Retrieves the BGP configuration for a given Edge Gateway.
     * @param gatewayId 
     */
    public getBgpConfig (gatewayId: string) : Promise<{ response: http.ClientResponse; body: EdgeBgpConfig;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getBgpConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeBgpConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the general BGP configuration on an edge gateway. 
     * @summary Updates the BGP configuration on the Edge Gateway.
     * @param bgpConfig 
     * @param gatewayId 
     */
    public updateBgpConfig (bgpConfig: EdgeBgpConfig, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'bgpConfig' is not null or undefined
        if (bgpConfig === null || bgpConfig === undefined) {
            throw new Error('Required parameter bgpConfig was null or undefined when calling updateBgpConfig.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateBgpConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: bgpConfig,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayBgpNeighborApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayBgpNeighborApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayBgpNeighborApiApiKeys, value: string) {
        this.authentications[EdgeGatewayBgpNeighborApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific BGP neighbor of edge gateway.
     * @param gatewayId 
     * @param neighborId 
     */
    public deleteBgpNeighbor (gatewayId: string, neighborId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/neighbors/{neighborId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'neighborId' + '}', String(neighborId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling deleteBgpNeighbor.');
        }

        // verify required parameter 'neighborId' is not null or undefined
        if (neighborId === null || neighborId === undefined) {
            throw new Error('Required parameter neighborId was null or undefined when calling deleteBgpNeighbor.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific BGP neighbor of edge gateway.
     * @param gatewayId 
     * @param neighborId 
     */
    public getBgpNeighbor (gatewayId: string, neighborId: string) : Promise<{ response: http.ClientResponse; body: EdgeBgpNeighbor;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/neighbors/{neighborId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'neighborId' + '}', String(neighborId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getBgpNeighbor.');
        }

        // verify required parameter 'neighborId' is not null or undefined
        if (neighborId === null || neighborId === undefined) {
            throw new Error('Required parameter neighborId was null or undefined when calling getBgpNeighbor.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeBgpNeighbor;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves status of a specific BGP neighbor configured on an Edge Gateway.
     * @param gatewayId 
     * @param neighborId 
     */
    public getBgpNeighborStatus (gatewayId: string, neighborId: string) : Promise<{ response: http.ClientResponse; body: NetworkingObjectStatus;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/neighbors/{neighborId}/status'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'neighborId' + '}', String(neighborId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getBgpNeighborStatus.');
        }

        // verify required parameter 'neighborId' is not null or undefined
        if (neighborId === null || neighborId === undefined) {
            throw new Error('Required parameter neighborId was null or undefined when calling getBgpNeighborStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NetworkingObjectStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific BGP neighbor of edge gateway.
     * @param bgpNeighbor 
     * @param gatewayId 
     * @param neighborId 
     */
    public updateBgpNeighbor (bgpNeighbor: EdgeBgpNeighbor, gatewayId: string, neighborId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/neighbors/{neighborId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'neighborId' + '}', String(neighborId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'bgpNeighbor' is not null or undefined
        if (bgpNeighbor === null || bgpNeighbor === undefined) {
            throw new Error('Required parameter bgpNeighbor was null or undefined when calling updateBgpNeighbor.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateBgpNeighbor.');
        }

        // verify required parameter 'neighborId' is not null or undefined
        if (neighborId === null || neighborId === undefined) {
            throw new Error('Required parameter neighborId was null or undefined when calling updateBgpNeighbor.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: bgpNeighbor,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayBgpNeighborsApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayBgpNeighborsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayBgpNeighborsApiApiKeys, value: string) {
        this.authentications[EdgeGatewayBgpNeighborsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a new BGP neighbor for the edge gateway.
     * @param bgpNeighbor 
     * @param gatewayId 
     */
    public createBgpNeighbor (bgpNeighbor: EdgeBgpNeighbor, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/neighbors'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'bgpNeighbor' is not null or undefined
        if (bgpNeighbor === null || bgpNeighbor === undefined) {
            throw new Error('Required parameter bgpNeighbor was null or undefined when calling createBgpNeighbor.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling createBgpNeighbor.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: bgpNeighbor,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all BGP neighbors configured for the edge gateway.
     * @param gatewayId 
     */
    public getBgpNeighbors (gatewayId: string) : Promise<{ response: http.ClientResponse; body: EdgeBgpNeighbors;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/neighbors'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getBgpNeighbors.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeBgpNeighbors;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayDnsApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayDnsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayDnsApiApiKeys, value: string) {
        this.authentications[EdgeGatewayDnsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes DNS configuration of the edge gateway.
     * @param gatewayId 
     */
    public deleteEdgeGatewayDns (gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/dns'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling deleteEdgeGatewayDns.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves DNS configuration of the edge gateway.
     * @param gatewayId 
     */
    public getEdgeGatewayDns (gatewayId: string) : Promise<{ response: http.ClientResponse; body: EdgeDnsConfig;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/dns'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getEdgeGatewayDns.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeDnsConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates DNS configuration of the edge gateway.
     * @param dnsConfig 
     * @param gatewayId 
     */
    public updateEdgeGatewayDns (dnsConfig: EdgeDnsConfig, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/dns'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dnsConfig' is not null or undefined
        if (dnsConfig === null || dnsConfig === undefined) {
            throw new Error('Required parameter dnsConfig was null or undefined when calling updateEdgeGatewayDns.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateEdgeGatewayDns.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dnsConfig,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayFirewallRuleApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayFirewallRuleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayFirewallRuleApiApiKeys, value: string) {
        this.authentications[EdgeGatewayFirewallRuleApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific firewall rule for a given edge gateway.
     * @param gatewayId 
     * @param ruleId 
     */
    public deleteFirewallRule (gatewayId: string, ruleId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/firewall/rules/{ruleId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'ruleId' + '}', String(ruleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling deleteFirewallRule.');
        }

        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling deleteFirewallRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific firewall rule for a given edge gateway.
     * @param gatewayId 
     * @param ruleId 
     */
    public getFirewallRule (gatewayId: string, ruleId: string) : Promise<{ response: http.ClientResponse; body: EdgeFirewallRule;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/firewall/rules/{ruleId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'ruleId' + '}', String(ruleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getFirewallRule.');
        }

        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling getFirewallRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeFirewallRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific firewall rule for a given edge gateway.
     * @param firewallRule 
     * @param gatewayId 
     * @param ruleId 
     */
    public updateFirewallRule (firewallRule: EdgeFirewallRule, gatewayId: string, ruleId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/firewall/rules/{ruleId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'ruleId' + '}', String(ruleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'firewallRule' is not null or undefined
        if (firewallRule === null || firewallRule === undefined) {
            throw new Error('Required parameter firewallRule was null or undefined when calling updateFirewallRule.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateFirewallRule.');
        }

        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling updateFirewallRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: firewallRule,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayFirewallRulesApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayFirewallRulesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayFirewallRulesApiApiKeys, value: string) {
        this.authentications[EdgeGatewayFirewallRulesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes all the firewall rules for a given edge gateway.
     * @param gatewayId 
     */
    public deleteFirewallRules (gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/firewall/rules'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling deleteFirewallRules.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all user-defined and default firewall rules for a given edge gateway. The rules are returned in the order of precedence. 
     * @summary Retrieves all firewall rules for a given edge gateway.
     * @param gatewayId 
     */
    public getFirewallRules (gatewayId: string) : Promise<{ response: http.ClientResponse; body: EdgeFirewallRules;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/firewall/rules'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getFirewallRules.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeFirewallRules;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates all the firewall rules for a given edge gateway. If a rule with the ruleId is not already present, a new rule will be created. If it already exists, the rule will be updated. Any existing rule that is not specified in the update payload will be deleted. The order of rules in payload will define the actual order in which this rules will be applied. 
     * @summary Updates firewall rules for a given edge gateway.
     * @param firewallRules 
     * @param gatewayId 
     */
    public updateFirewallRules (firewallRules: EdgeFirewallRules, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/firewall/rules'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'firewallRules' is not null or undefined
        if (firewallRules === null || firewallRules === undefined) {
            throw new Error('Required parameter firewallRules was null or undefined when calling updateFirewallRules.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateFirewallRules.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: firewallRules,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayIpSecVpnTunnelApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayIpSecVpnTunnelApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayIpSecVpnTunnelApiApiKeys, value: string) {
        this.authentications[EdgeGatewayIpSecVpnTunnelApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific IPSec tunnel for a given edge gateway.
     * @param gatewayId 
     * @param tunnelId 
     */
    public deleteIpSecVpnTunnel (gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels/{tunnelId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling deleteIpSecVpnTunnel.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling deleteIpSecVpnTunnel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific IPSec tunnel for a given edge gateway.
     * @param gatewayId 
     * @param tunnelId 
     */
    public getIpSecVpnTunnel (gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnel;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels/{tunnelId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getIpSecVpnTunnel.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling getIpSecVpnTunnel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnel;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the default connection properties that are used for a given IPSec Tunnel in NSX-T when default is set or no security type is specified.
     * @param gatewayId 
     */
    public getIpSecVpnTunnelDefaultConnectionProperties (gatewayId: string) : Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnelConnectionProperties;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels/defaultConnectionProperties'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getIpSecVpnTunnelDefaultConnectionProperties.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnelConnectionProperties;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves connection statistics for a given IPSec VPN Tunnel configured on an Edge Gateway.
     * @param gatewayId 
     * @param tunnelId 
     */
    public getIpSecVpnTunnelStatistics (gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnelStatistics;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels/{tunnelId}/statistics'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getIpSecVpnTunnelStatistics.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling getIpSecVpnTunnelStatistics.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnelStatistics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves status of a given IPSec VPN Tunnel configured on an Edge Gateway.
     * @param gatewayId 
     * @param tunnelId 
     */
    public getIpSecVpnTunnelStatus (gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnelStatus;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels/{tunnelId}/status'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getIpSecVpnTunnelStatus.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling getIpSecVpnTunnelStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnelStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific IPSec tunnel for a given edge gateway.
     * @param ipsecVpnTunnel 
     * @param gatewayId 
     * @param tunnelId 
     */
    public updateIpSecVpnTunnel (ipsecVpnTunnel: EdgeIpSecVpnTunnel, gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels/{tunnelId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ipsecVpnTunnel' is not null or undefined
        if (ipsecVpnTunnel === null || ipsecVpnTunnel === undefined) {
            throw new Error('Required parameter ipsecVpnTunnel was null or undefined when calling updateIpSecVpnTunnel.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateIpSecVpnTunnel.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling updateIpSecVpnTunnel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ipsecVpnTunnel,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayIpSecVpnTunnelConnectionPropertiesApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayIpSecVpnTunnelConnectionPropertiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayIpSecVpnTunnelConnectionPropertiesApiApiKeys, value: string) {
        this.authentications[EdgeGatewayIpSecVpnTunnelConnectionPropertiesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves connection properties for a given IPSec VPN Tunnel configured on an Edge Gateway.
     * @param gatewayId 
     * @param tunnelId 
     */
    public getIpSecVpnTunnelConnectionProperties (gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnelConnectionProperties;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels/{tunnelId}/connectionProperties'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getIpSecVpnTunnelConnectionProperties.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling getIpSecVpnTunnelConnectionProperties.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnelConnectionProperties;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the connection properties for a given IPSec VPN Tunnel configured on an Edge Gateway.
     * @param ipSecVpnTunnelConnectionProperties 
     * @param gatewayId 
     * @param tunnelId 
     */
    public updateIpSecVpnTunnelConnectionProperties (ipSecVpnTunnelConnectionProperties: EdgeIpSecVpnTunnelConnectionProperties, gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels/{tunnelId}/connectionProperties'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ipSecVpnTunnelConnectionProperties' is not null or undefined
        if (ipSecVpnTunnelConnectionProperties === null || ipSecVpnTunnelConnectionProperties === undefined) {
            throw new Error('Required parameter ipSecVpnTunnelConnectionProperties was null or undefined when calling updateIpSecVpnTunnelConnectionProperties.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateIpSecVpnTunnelConnectionProperties.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling updateIpSecVpnTunnelConnectionProperties.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ipSecVpnTunnelConnectionProperties,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayIpSecVpnTunnelsApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayIpSecVpnTunnelsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayIpSecVpnTunnelsApiApiKeys, value: string) {
        this.authentications[EdgeGatewayIpSecVpnTunnelsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates an IPSec tunnel on the Edge Gateway.
     * @param ipsecVpnTunnel 
     * @param gatewayId 
     */
    public createIpSecVpnTunnel (ipsecVpnTunnel: EdgeIpSecVpnTunnel, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ipsecVpnTunnel' is not null or undefined
        if (ipsecVpnTunnel === null || ipsecVpnTunnel === undefined) {
            throw new Error('Required parameter ipsecVpnTunnel was null or undefined when calling createIpSecVpnTunnel.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling createIpSecVpnTunnel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ipsecVpnTunnel,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all IPSec VPN tunnels that are configured for an edge gateway. Pagination is supported, use response header to get the next page. Results can be sorted by only a single parameter. Sorting by combination of parameters (sortAsc=foo&sortDesc=bar) is not allowed. 
     * @summary Retrieves all IPSec tunnels for a given edge gateway.
     * @param pageSize Results per page to fetch.
     * @param gatewayId 
     * @param cursor Field used for getting next page of records. The value is supplied by the current result page. If not set, the first page is retrieved. If cursor is set, then all other pagination query parameters such as pageSize, sortDesc, sortAsc, queryFilter are ignored. 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getIpSecVpnTunnels (pageSize: number, gatewayId: string, cursor?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnels;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/ipsec/tunnels'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getIpSecVpnTunnels.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getIpSecVpnTunnels.');
        }

        if (cursor !== undefined) {
            queryParameters['cursor'] = cursor;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeIpSecVpnTunnels;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayL2VpnTunnelApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayL2VpnTunnelApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayL2VpnTunnelApiApiKeys, value: string) {
        this.authentications[EdgeGatewayL2VpnTunnelApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific L2 VPN tunnel for a given edge gateway.
     * @param gatewayId 
     * @param tunnelId 
     */
    public deleteL2VpnTunnel (gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/l2vpn/tunnels/{tunnelId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling deleteL2VpnTunnel.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling deleteL2VpnTunnel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific L2 VPN tunnel for a given edge gateway.
     * @param gatewayId 
     * @param tunnelId 
     */
    public getL2VpnTunnel (gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body: EdgeL2VpnTunnel;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/l2vpn/tunnels/{tunnelId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getL2VpnTunnel.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling getL2VpnTunnel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeL2VpnTunnel;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves connection statistics for a given L2 VPN Tunnel configured on an Edge Gateway.
     * @param gatewayId 
     * @param tunnelId 
     */
    public getL2VpnTunnelStatistics (gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body: EdgeL2VpnTunnelStatistics;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/l2vpn/tunnels/{tunnelId}/metrics'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getL2VpnTunnelStatistics.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling getL2VpnTunnelStatistics.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeL2VpnTunnelStatistics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves status of a given L2 VPN Tunnel.
     * @param gatewayId 
     * @param tunnelId 
     */
    public getL2VpnTunnelStatus (gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body: EdgeL2VpnTunnelStatus;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/l2vpn/tunnels/{tunnelId}/status'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getL2VpnTunnelStatus.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling getL2VpnTunnelStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeL2VpnTunnelStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific L2 VPN tunnel for a given edge gateway.
     * @param l2VpnTunnel 
     * @param gatewayId 
     * @param tunnelId 
     */
    public updateL2VpnTunnel (l2VpnTunnel: EdgeL2VpnTunnel, gatewayId: string, tunnelId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/l2vpn/tunnels/{tunnelId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'tunnelId' + '}', String(tunnelId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'l2VpnTunnel' is not null or undefined
        if (l2VpnTunnel === null || l2VpnTunnel === undefined) {
            throw new Error('Required parameter l2VpnTunnel was null or undefined when calling updateL2VpnTunnel.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateL2VpnTunnel.');
        }

        // verify required parameter 'tunnelId' is not null or undefined
        if (tunnelId === null || tunnelId === undefined) {
            throw new Error('Required parameter tunnelId was null or undefined when calling updateL2VpnTunnel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: l2VpnTunnel,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayL2VpnTunnelsApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayL2VpnTunnelsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayL2VpnTunnelsApiApiKeys, value: string) {
        this.authentications[EdgeGatewayL2VpnTunnelsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates an L2 VPN tunnel on the Edge Gateway.
     * @param l2VpnTunnel 
     * @param gatewayId 
     */
    public createL2VpnTunnel (l2VpnTunnel: EdgeL2VpnTunnel, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/l2vpn/tunnels'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'l2VpnTunnel' is not null or undefined
        if (l2VpnTunnel === null || l2VpnTunnel === undefined) {
            throw new Error('Required parameter l2VpnTunnel was null or undefined when calling createL2VpnTunnel.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling createL2VpnTunnel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: l2VpnTunnel,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all L2 VPN tunnels that are configured for an edge gateway. Results can be sorted by only a single parameter. Sorting by combination of parameters (sortAsc=foo&sortDesc=bar) is not allowed. 
     * @summary Retrieves all L2 VPN tunnels for a given edge gateway.
     * @param gatewayId 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getL2VpnTunnels (gatewayId: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EdgeL2VpnTunnels;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/l2vpn/tunnels'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getL2VpnTunnels.');
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeL2VpnTunnels;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayLoadBalancerApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayLoadBalancerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayLoadBalancerApiApiKeys, value: string) {
        this.authentications[EdgeGatewayLoadBalancerApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves the current state of Load Balancer service on Edge Gateway. 
     * @summary Retrieves Load Balancer configuration on an Edge Gateway.
     * @param gatewayId 
     */
    public getLoadBalancerConfig (gatewayId: string) : Promise<{ response: http.ClientResponse; body: EdgeGatewayLoadBalancerConfig;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/loadBalancer'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getLoadBalancerConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeGatewayLoadBalancerConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the Load Balancer service configuration on Edge Gateway. 
     * @summary Update Load Balancer configuration on an Edge Gateway.
     * @param loadBalancerConfig 
     * @param gatewayId 
     */
    public updateLoadBalancerConfig (loadBalancerConfig: EdgeGatewayLoadBalancerConfig, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/loadBalancer'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerConfig' is not null or undefined
        if (loadBalancerConfig === null || loadBalancerConfig === undefined) {
            throw new Error('Required parameter loadBalancerConfig was null or undefined when calling updateLoadBalancerConfig.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateLoadBalancerConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loadBalancerConfig,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayLoadBalancerAnalyticsApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayLoadBalancerAnalyticsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayLoadBalancerAnalyticsApiApiKeys, value: string) {
        this.authentications[EdgeGatewayLoadBalancerAnalyticsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves analytics for a specific load balancer.  Metrics are specified in the filter query along with time period and series resolution.  Up to 5 metric series can be specified per report.  All reports will span the same time period.  Report filters are encapsulated in a fiql filter query parameter. Sample filter:   <code>filter=(componentId==urn:vcloud:virtualservice:7d38ad7f-cd93-4501-8c40-6f61650ccda0;         metric==l4_server.avg_total_rtt;metric==l7_server.avg_application_response_time;step==500;limit==100)</code> Supported filters are:   <ul>   <li>componentId.  The URN of the virtual service or pool for which metrics will be gathered.  Only one should be specified.   This is required.   <li>metric.  One or more metrics of interest.  <code>filter=(metric==l4_server.avg_total_rtt;metric==l7_server.avg_application_response_time)</code> -   This is required.  Supported metrics can be found at the analytics/supportedMetrics endpoint.   <li>step.  The time resolution of the report, in seconds.   This is required.  Minimum supported resolution is 300 seconds (5 minutes).   <li>limit.  Optional.  The number of data points to be returned.   This is optional.  Defaults to 59 where it can't be calculated.   <li>startTime.  Start time of the series.   This is optional.  Must be in ISO 8601 format (i.e. 2020-07-24T00:00:00).  If not provided, start time is calculated from the step and end time.   <li>endTime.  End period of the series.   This is optional.  Must be in ISO 8601 format (i.e. 2020-07-24T00:00:00). Defaults to the time of latest collected data point.   </ul> 
     * @param filter Filter for a query.  FIQL format.
     */
    public getLoadBalancerAnalyticReports (filter?: string) : Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerAnalyticReports;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/analyticReports';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerAnalyticReports;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the supported metrics for load balancer analytic reports.  These metrics can be used to create runtime reports of load balancer virtual services and pools. 
     */
    public getLoadBalancerSupportedAnalyticMetrics () : Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerAnalyticMetrics;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/analyticReports/supportedMetrics';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerAnalyticMetrics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayLoadBalancerPoolApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayLoadBalancerPoolApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayLoadBalancerPoolApiApiKeys, value: string) {
        this.authentications[EdgeGatewayLoadBalancerPoolApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific Load Balancer Pool.
     * @param poolId 
     */
    public deleteLoadBalancerPool (poolId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/pools/{poolId}'
            .replace('{' + 'poolId' + '}', String(poolId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'poolId' is not null or undefined
        if (poolId === null || poolId === undefined) {
            throw new Error('Required parameter poolId was null or undefined when calling deleteLoadBalancerPool.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific Load Balancer Pool.
     * @param poolId 
     */
    public getLoadBalancerPool (poolId: string) : Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerPool;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/pools/{poolId}'
            .replace('{' + 'poolId' + '}', String(poolId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'poolId' is not null or undefined
        if (poolId === null || poolId === undefined) {
            throw new Error('Required parameter poolId was null or undefined when calling getLoadBalancerPool.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerPool;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific Load Balancer Pool.
     * @param loadBalancerPool 
     * @param poolId 
     */
    public updateLoadBalancerPool (loadBalancerPool: EdgeLoadBalancerPool, poolId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/pools/{poolId}'
            .replace('{' + 'poolId' + '}', String(poolId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerPool' is not null or undefined
        if (loadBalancerPool === null || loadBalancerPool === undefined) {
            throw new Error('Required parameter loadBalancerPool was null or undefined when calling updateLoadBalancerPool.');
        }

        // verify required parameter 'poolId' is not null or undefined
        if (poolId === null || poolId === undefined) {
            throw new Error('Required parameter poolId was null or undefined when calling updateLoadBalancerPool.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loadBalancerPool,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayLoadBalancerPoolsApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayLoadBalancerPoolsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayLoadBalancerPoolsApiApiKeys, value: string) {
        this.authentications[EdgeGatewayLoadBalancerPoolsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a Load Balancer Pool.
     * @param loadBalancerPool 
     */
    public createLoadBalancerPool (loadBalancerPool: EdgeLoadBalancerPool) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/pools';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerPool' is not null or undefined
        if (loadBalancerPool === null || loadBalancerPool === undefined) {
            throw new Error('Required parameter loadBalancerPool was null or undefined when calling createLoadBalancerPool.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loadBalancerPool,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves summaries for all of the Load Balancer Pools that are configured for an Edge Gateway. 
     * @summary Retrieves all Load Balancer Pool Summaries for a given Edge Gateway.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param gatewayId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getPoolSummariesForGateway (page: number, pageSize: number, gatewayId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerPoolSummaries;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/loadBalancer/poolSummaries'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getPoolSummariesForGateway.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getPoolSummariesForGateway.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getPoolSummariesForGateway.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerPoolSummaries;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayLoadBalancerVirtualServiceApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayLoadBalancerVirtualServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayLoadBalancerVirtualServiceApiApiKeys, value: string) {
        this.authentications[EdgeGatewayLoadBalancerVirtualServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * Delete a Virtual Service. 
     * @summary Delete the specified Virtual Service.
     * @param virtualServiceId 
     */
    public deleteVirtualService (virtualServiceId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/virtualServices/{virtualServiceId}'
            .replace('{' + 'virtualServiceId' + '}', String(virtualServiceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'virtualServiceId' is not null or undefined
        if (virtualServiceId === null || virtualServiceId === undefined) {
            throw new Error('Required parameter virtualServiceId was null or undefined when calling deleteVirtualService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a specific Virtual Service. 
     * @summary Get Virtual Service.
     * @param virtualServiceId 
     */
    public getVirtualService (virtualServiceId: string) : Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerVirtualService;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/virtualServices/{virtualServiceId}'
            .replace('{' + 'virtualServiceId' + '}', String(virtualServiceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'virtualServiceId' is not null or undefined
        if (virtualServiceId === null || virtualServiceId === undefined) {
            throw new Error('Required parameter virtualServiceId was null or undefined when calling getVirtualService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerVirtualService;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a Virtual Service. 
     * @summary Update specified Virtual Service.
     * @param virtualServiceConfig 
     * @param virtualServiceId 
     */
    public updateVirtualService (virtualServiceConfig: EdgeLoadBalancerVirtualService, virtualServiceId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/virtualServices/{virtualServiceId}'
            .replace('{' + 'virtualServiceId' + '}', String(virtualServiceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'virtualServiceConfig' is not null or undefined
        if (virtualServiceConfig === null || virtualServiceConfig === undefined) {
            throw new Error('Required parameter virtualServiceConfig was null or undefined when calling updateVirtualService.');
        }

        // verify required parameter 'virtualServiceId' is not null or undefined
        if (virtualServiceId === null || virtualServiceId === undefined) {
            throw new Error('Required parameter virtualServiceId was null or undefined when calling updateVirtualService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: virtualServiceConfig,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayLoadBalancerVirtualServicesApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayLoadBalancerVirtualServicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayLoadBalancerVirtualServicesApiApiKeys, value: string) {
        this.authentications[EdgeGatewayLoadBalancerVirtualServicesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new Virtual Service for a specific Edge Gateway. 
     * @summary Create a new Virtual Service for a specific Edge Gateway.
     * @param virtualServiceConfig 
     */
    public createVirtualService (virtualServiceConfig: EdgeLoadBalancerVirtualService) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/virtualServices';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'virtualServiceConfig' is not null or undefined
        if (virtualServiceConfig === null || virtualServiceConfig === undefined) {
            throw new Error('Required parameter virtualServiceConfig was null or undefined when calling createVirtualService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: virtualServiceConfig,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all Virtual Service Summaries for an Edge Gateway. 
     * @summary Get all Virtual Service Summaries for an Edge Gateway.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param gatewayId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getVirtualServiceSummariesForGateway (page: number, pageSize: number, gatewayId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerVirtualServiceSummaries;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/loadBalancer/virtualServiceSummaries'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getVirtualServiceSummariesForGateway.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getVirtualServiceSummariesForGateway.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getVirtualServiceSummariesForGateway.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeLoadBalancerVirtualServiceSummaries;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayNatRuleApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayNatRuleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayNatRuleApiApiKeys, value: string) {
        this.authentications[EdgeGatewayNatRuleApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific NAT Rule configuration of the edge gateway based on the rule id passed in.
     * @param gatewayId 
     * @param ruleId 
     */
    public deleteNatRule (gatewayId: string, ruleId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/nat/rules/{ruleId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'ruleId' + '}', String(ruleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling deleteNatRule.');
        }

        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling deleteNatRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific NAT Rule configuration of the edge gateway based on the rule id passed in.
     * @param gatewayId 
     * @param ruleId 
     */
    public getNatRule (gatewayId: string, ruleId: string) : Promise<{ response: http.ClientResponse; body: EdgeNatRule;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/nat/rules/{ruleId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'ruleId' + '}', String(ruleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getNatRule.');
        }

        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling getNatRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeNatRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a specific NAT Rule configuration of the edge gateway based on the rule id passed in.
     * @param edgeNatRule 
     * @param gatewayId 
     * @param ruleId 
     */
    public updateNatRule (edgeNatRule: EdgeNatRule, gatewayId: string, ruleId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/nat/rules/{ruleId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'ruleId' + '}', String(ruleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'edgeNatRule' is not null or undefined
        if (edgeNatRule === null || edgeNatRule === undefined) {
            throw new Error('Required parameter edgeNatRule was null or undefined when calling updateNatRule.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateNatRule.');
        }

        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling updateNatRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: edgeNatRule,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayNatRulesApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayNatRulesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayNatRulesApiApiKeys, value: string) {
        this.authentications[EdgeGatewayNatRulesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a NAT Rule on the Edge Gateway.
     * @param edgeNatRule 
     * @param gatewayId 
     */
    public createNatRule (edgeNatRule: EdgeNatRule, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/nat/rules'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'edgeNatRule' is not null or undefined
        if (edgeNatRule === null || edgeNatRule === undefined) {
            throw new Error('Required parameter edgeNatRule was null or undefined when calling createNatRule.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling createNatRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: edgeNatRule,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all NAT Rules on the edge gateway.  Pagination is supported to get the next page in the header response. Results can be sorted by only a single parameter. Sorting by combination of parameters (sortAsc=foo&sortDesc=bar) is not allowed. 
     * @summary Retrieves all NAT Rules on the edge gateway. 
     * @param pageSize Results per page to fetch.
     * @param gatewayId 
     * @param cursor Field used for getting next page of records. The value is supplied by the current result page. If not set, the first page is retrieved. If cursor is set, then all other pagination query parameters such as pageSize, sortDesc, sortAsc, queryFilter are ignored. 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getNatRules (pageSize: number, gatewayId: string, cursor?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EdgeNatRules;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/nat/rules'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getNatRules.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getNatRules.');
        }

        if (cursor !== undefined) {
            queryParameters['cursor'] = cursor;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeNatRules;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayPrefixListApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayPrefixListApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayPrefixListApiApiKeys, value: string) {
        this.authentications[EdgeGatewayPrefixListApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific Prefix list for a given edge gateway.
     * @param gatewayId 
     * @param listId 
     */
    public deletePrefixList (gatewayId: string, listId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/prefixLists/{listId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'listId' + '}', String(listId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling deletePrefixList.');
        }

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling deletePrefixList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific Prefix list for a given edge gateway.
     * @param gatewayId 
     * @param listId 
     */
    public getPrefixList (gatewayId: string, listId: string) : Promise<{ response: http.ClientResponse; body: EdgePrefixList;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/prefixLists/{listId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'listId' + '}', String(listId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getPrefixList.');
        }

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling getPrefixList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgePrefixList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific Prefix list for a given edge gateway.
     * @param prefixList 
     * @param gatewayId 
     * @param listId 
     */
    public updatePrefixList (prefixList: EdgePrefixList, gatewayId: string, listId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/prefixLists/{listId}'
            .replace('{' + 'gatewayId' + '}', String(gatewayId))
            .replace('{' + 'listId' + '}', String(listId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'prefixList' is not null or undefined
        if (prefixList === null || prefixList === undefined) {
            throw new Error('Required parameter prefixList was null or undefined when calling updatePrefixList.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updatePrefixList.');
        }

        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling updatePrefixList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: prefixList,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayPrefixListsApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayPrefixListsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayPrefixListsApiApiKeys, value: string) {
        this.authentications[EdgeGatewayPrefixListsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a new Prefix list on the edge gateway.
     * @param prefixList 
     * @param gatewayId 
     */
    public createPrefixList (prefixList: EdgePrefixList, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/prefixLists'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'prefixList' is not null or undefined
        if (prefixList === null || prefixList === undefined) {
            throw new Error('Required parameter prefixList was null or undefined when calling createPrefixList.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling createPrefixList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: prefixList,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all Prefix lists for a given edge gateway. Results can be sorted by only a single parameter. Sorting by combination of parameters (sortAsc=foo&sortDesc=bar) is not allowed. 
     * @summary Retrieves all Prefix lists for a given edge gateway.
     * @param gatewayId 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getPrefixLists (gatewayId: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EdgePrefixLists;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/bgp/prefixLists'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getPrefixLists.');
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgePrefixLists;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewayRouteAdvertisementApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewayRouteAdvertisementApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewayRouteAdvertisementApiApiKeys, value: string) {
        this.authentications[EdgeGatewayRouteAdvertisementApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieve the list of subnets that will be advertised so that the Edge Gateway can route out to the connected external network. Org vDC networks that are in any of these subnets can then be routed out to the external networks. 
     * @summary Retrieve the list of subnets that will be advertised so that the Edge Gateway can route out to the connected external network.
     * @param gatewayId 
     */
    public getRouteAdvertisement (gatewayId: string) : Promise<{ response: http.ClientResponse; body: RouteAdvertisement;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/advertisement'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getRouteAdvertisement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouteAdvertisement;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the list of subnets that will be advertised so that the Edge Gateway can route out to the connected external network.
     * @param routeAdvertisement 
     * @param gatewayId 
     */
    public updateRouteAdvertisement (routeAdvertisement: RouteAdvertisement, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/routing/advertisement'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'routeAdvertisement' is not null or undefined
        if (routeAdvertisement === null || routeAdvertisement === undefined) {
            throw new Error('Required parameter routeAdvertisement was null or undefined when calling updateRouteAdvertisement.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateRouteAdvertisement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: routeAdvertisement,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewaySLAACProfileApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewaySLAACProfileApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewaySLAACProfileApiApiKeys, value: string) {
        this.authentications[EdgeGatewaySLAACProfileApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves the SLAAC profile on the edge gateway. 
     * @summary Retrieves the SLAAC profile on the edge gateway. 
     * @param gatewayId 
     */
    public getSLAACProfile (gatewayId: string) : Promise<{ response: http.ClientResponse; body: SLAACProfile;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/slaacProfile'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getSLAACProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SLAACProfile;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a SLAAC profile or updates the existing one if it already exists.
     * @param sLAACProfile 
     * @param gatewayId 
     */
    public updateSLAACProfile (sLAACProfile: SLAACProfile, gatewayId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways/{gatewayId}/slaacProfile'
            .replace('{' + 'gatewayId' + '}', String(gatewayId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'sLAACProfile' is not null or undefined
        if (sLAACProfile === null || sLAACProfile === undefined) {
            throw new Error('Required parameter sLAACProfile was null or undefined when calling updateSLAACProfile.');
        }

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling updateSLAACProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: sLAACProfile,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EdgeGatewaysApiApiKeys {
    ApiKeyAuth,
}

export class EdgeGatewaysApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EdgeGatewaysApiApiKeys, value: string) {
        this.authentications[EdgeGatewaysApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new edge gateway for a vDC 
     * @summary Create a new edge gateway
     * @param edgeGateway 
     */
    public createEdgeGateway (edgeGateway: EdgeGateway) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'edgeGateway' is not null or undefined
        if (edgeGateway === null || edgeGateway === undefined) {
            throw new Error('Required parameter edgeGateway was null or undefined when calling createEdgeGateway.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: edgeGateway,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all edge gateways. If \"ownerRef.id\" filter is not specified, then user will see all the edge gateways in the organization they have the right to view. Results can be filtered by ownerRef. Combination of ownerRef and _context. <code>(_context==includeAccessible)</code> can be used to get all the edge gateways which are available to an Org vDC including the gateways which are owned by datacenter groups but available to Org vDC. 
     * @summary Get all the edge gateways
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getAllEdgeGateways (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EdgeGateways;  }> {
        const localVarPath = this.basePath + '/1.0.0/edgeGateways';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getAllEdgeGateways.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getAllEdgeGateways.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EdgeGateways;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EgressPointApiApiKeys {
    ApiKeyAuth,
}

export class EgressPointApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EgressPointApiApiKeys, value: string) {
        this.authentications[EgressPointApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific Universal Egress Point.
     * @param universalRouterId 
     * @param egressPointId 
     * @param force Value \&quot;true\&quot; means to forcefully delete the object that contains other objects even if those objects are in a state that does not allow removal. The default is \&quot;false\&quot;; therefore, objects are not removed if they are not in a state that normally allows removal. Force also implies recursive delete where other contained objects are removed. Errors may be ignored. Invalid value (not true or false) are ignored. 
     */
    public deleteEgressPoint (universalRouterId: string, egressPointId: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing/egressPoints/{egressPointId}'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId))
            .replace('{' + 'egressPointId' + '}', String(egressPointId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling deleteEgressPoint.');
        }

        // verify required parameter 'egressPointId' is not null or undefined
        if (egressPointId === null || egressPointId === undefined) {
            throw new Error('Required parameter egressPointId was null or undefined when calling deleteEgressPoint.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific Universal Egress Point.
     * @param universalRouterId 
     * @param egressPointId 
     */
    public getEgressPoint (universalRouterId: string, egressPointId: string) : Promise<{ response: http.ClientResponse; body: EgressPoint;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing/egressPoints/{egressPointId}'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId))
            .replace('{' + 'egressPointId' + '}', String(egressPointId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling getEgressPoint.');
        }

        // verify required parameter 'egressPointId' is not null or undefined
        if (egressPointId === null || egressPointId === undefined) {
            throw new Error('Required parameter egressPointId was null or undefined when calling getEgressPoint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EgressPoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sync/repair the egress point.
     * @param universalRouterId 
     * @param egressPointId 
     */
    public syncEgressPoint (universalRouterId: string, egressPointId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing/egressPoints/{egressPointId}/sync'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId))
            .replace('{' + 'egressPointId' + '}', String(egressPointId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling syncEgressPoint.');
        }

        // verify required parameter 'egressPointId' is not null or undefined
        if (egressPointId === null || egressPointId === undefined) {
            throw new Error('Required parameter egressPointId was null or undefined when calling syncEgressPoint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EgressPointsApiApiKeys {
    ApiKeyAuth,
}

export class EgressPointsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EgressPointsApiApiKeys, value: string) {
        this.authentications[EgressPointsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a new Universal Egress Point from a specified Edge Gateway and Org vDC.
     * @param egressPoint 
     * @param universalRouterId 
     */
    public createEgressPoint (egressPoint: EgressPoint, universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing/egressPoints'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'egressPoint' is not null or undefined
        if (egressPoint === null || egressPoint === undefined) {
            throw new Error('Required parameter egressPoint was null or undefined when calling createEgressPoint.');
        }

        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling createEgressPoint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: egressPoint,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of Universal Egress Points for a Universal Router.
     * @param universalRouterId 
     */
    public getEgressPoints (universalRouterId: string) : Promise<{ response: http.ClientResponse; body: EgressPoints;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing/egressPoints'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling getEgressPoints.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EgressPoints;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EmailSettingsApiApiKeys {
    ApiKeyAuth,
}

export class EmailSettingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EmailSettingsApiApiKeys, value: string) {
        this.authentications[EmailSettingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Tests that Email SMTP Settings are valid 
     * @summary Tests Email Settings and Connection
     * @param testEmailRequest Email Settings and destination email address for Email Test call
     */
    public testEmailSettings (testEmailRequest: TestEmailRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/smtp/test';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'testEmailRequest' is not null or undefined
        if (testEmailRequest === null || testEmailRequest === undefined) {
            throw new Error('Required parameter testEmailRequest was null or undefined when calling testEmailSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: testEmailRequest,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EntityApiApiKeys {
    ApiKeyAuth,
}

export class EntityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EntityApiApiKeys, value: string) {
        this.authentications[EntityApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get specified entity object
     * @param id the URN of the entity to be resolved
     */
    public resolveEntity (id: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/entity/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling resolveEntity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EntityQuotasApiApiKeys {
    ApiKeyAuth,
}

export class EntityQuotasApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EntityQuotasApiApiKeys, value: string) {
        this.authentications[EntityQuotasApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Assign quotas to given target group.
     * @param quotas 
     * @param groupUrn 
     */
    public assignQuotasToGroup (quotas: Quotas, groupUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/groups/{groupUrn}/quotas'
            .replace('{' + 'groupUrn' + '}', String(groupUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotas' is not null or undefined
        if (quotas === null || quotas === undefined) {
            throw new Error('Required parameter quotas was null or undefined when calling assignQuotasToGroup.');
        }

        // verify required parameter 'groupUrn' is not null or undefined
        if (groupUrn === null || groupUrn === undefined) {
            throw new Error('Required parameter groupUrn was null or undefined when calling assignQuotasToGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: quotas,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign quotas to given target organization.
     * @param quotas 
     * @param orgUrn 
     */
    public assignQuotasToOrg (quotas: Quotas, orgUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgs/{orgUrn}/quotas'
            .replace('{' + 'orgUrn' + '}', String(orgUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotas' is not null or undefined
        if (quotas === null || quotas === undefined) {
            throw new Error('Required parameter quotas was null or undefined when calling assignQuotasToOrg.');
        }

        // verify required parameter 'orgUrn' is not null or undefined
        if (orgUrn === null || orgUrn === undefined) {
            throw new Error('Required parameter orgUrn was null or undefined when calling assignQuotasToOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: quotas,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign quotas to given target user.
     * @param quotas 
     * @param userUrn 
     */
    public assignQuotasToUser (quotas: Quotas, userUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/users/{userUrn}/quotas'
            .replace('{' + 'userUrn' + '}', String(userUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotas' is not null or undefined
        if (quotas === null || quotas === undefined) {
            throw new Error('Required parameter quotas was null or undefined when calling assignQuotasToUser.');
        }

        // verify required parameter 'userUrn' is not null or undefined
        if (userUrn === null || userUrn === undefined) {
            throw new Error('Required parameter userUrn was null or undefined when calling assignQuotasToUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: quotas,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the effective quotas applicable for the given group.
     * @param groupUrn 
     */
    public getQuotasForGroup (groupUrn: string) : Promise<{ response: http.ClientResponse; body: Quotas;  }> {
        const localVarPath = this.basePath + '/1.0.0/groups/{groupUrn}/quotas'
            .replace('{' + 'groupUrn' + '}', String(groupUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'groupUrn' is not null or undefined
        if (groupUrn === null || groupUrn === undefined) {
            throw new Error('Required parameter groupUrn was null or undefined when calling getQuotasForGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Quotas;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the effective quotas applicable for the given organization.
     * @param orgUrn 
     */
    public getQuotasForOrg (orgUrn: string) : Promise<{ response: http.ClientResponse; body: Quotas;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgs/{orgUrn}/quotas'
            .replace('{' + 'orgUrn' + '}', String(orgUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgUrn' is not null or undefined
        if (orgUrn === null || orgUrn === undefined) {
            throw new Error('Required parameter orgUrn was null or undefined when calling getQuotasForOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Quotas;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the effective quotas applicable for the given user.
     * @param userUrn 
     */
    public getQuotasForUser (userUrn: string) : Promise<{ response: http.ClientResponse; body: Quotas;  }> {
        const localVarPath = this.basePath + '/1.0.0/users/{userUrn}/quotas'
            .replace('{' + 'userUrn' + '}', String(userUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userUrn' is not null or undefined
        if (userUrn === null || userUrn === undefined) {
            throw new Error('Required parameter userUrn was null or undefined when calling getQuotasForUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Quotas;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the effective quotas applicable for the given vapp.
     * @param vappUrn 
     */
    public getQuotasForVApp (vappUrn: string) : Promise<{ response: http.ClientResponse; body: Quotas;  }> {
        const localVarPath = this.basePath + '/1.0.0/vapps/{vappUrn}/quotas'
            .replace('{' + 'vappUrn' + '}', String(vappUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vappUrn' is not null or undefined
        if (vappUrn === null || vappUrn === undefined) {
            throw new Error('Required parameter vappUrn was null or undefined when calling getQuotasForVApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Quotas;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExternalNetworkApiApiKeys {
    ApiKeyAuth,
}

export class ExternalNetworkApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExternalNetworkApiApiKeys, value: string) {
        this.authentications[ExternalNetworkApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create an external network
     * @param externalNetwork 
     */
    public createExternalNetwork (externalNetwork: ExternalNetwork) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/externalNetworks';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'externalNetwork' is not null or undefined
        if (externalNetwork === null || externalNetwork === undefined) {
            throw new Error('Required parameter externalNetwork was null or undefined when calling createExternalNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: externalNetwork,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a specific external network.
     * @param externalNetworkId 
     * @param force Value \&quot;true\&quot; means to forcefully delete the object that contains other objects even if those objects are in a state that does not allow removal. The default is \&quot;false\&quot;; therefore, objects are not removed if they are not in a state that normally allows removal. Force also implies recursive delete where other contained objects are removed. Errors may be ignored. Invalid value (not true or false) are ignored. 
     */
    public deleteExternalNetwork (externalNetworkId: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/externalNetworks/{externalNetworkId}'
            .replace('{' + 'externalNetworkId' + '}', String(externalNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'externalNetworkId' is not null or undefined
        if (externalNetworkId === null || externalNetworkId === undefined) {
            throw new Error('Required parameter externalNetworkId was null or undefined when calling deleteExternalNetwork.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all the available IPs for a given external network. 
     * @summary Retrieve the list of IP addresses available for use on the network.
     * @param externalNetworkId 
     */
    public getAvailableIpAddresses (externalNetworkId: string) : Promise<{ response: http.ClientResponse; body: AvailableIpPoolSubnets;  }> {
        const localVarPath = this.basePath + '/1.0.0/externalNetworks/{externalNetworkId}/availableIpAddresses'
            .replace('{' + 'externalNetworkId' + '}', String(externalNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'externalNetworkId' is not null or undefined
        if (externalNetworkId === null || externalNetworkId === undefined) {
            throw new Error('Required parameter externalNetworkId was null or undefined when calling getAvailableIpAddresses.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AvailableIpPoolSubnets;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific external network.
     * @param externalNetworkId 
     */
    public getExternalNetwork (externalNetworkId: string) : Promise<{ response: http.ClientResponse; body: ExternalNetwork;  }> {
        const localVarPath = this.basePath + '/1.0.0/externalNetworks/{externalNetworkId}'
            .replace('{' + 'externalNetworkId' + '}', String(externalNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'externalNetworkId' is not null or undefined
        if (externalNetworkId === null || externalNetworkId === undefined) {
            throw new Error('Required parameter externalNetworkId was null or undefined when calling getExternalNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExternalNetwork;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all the used IPs for a given external network. This returns all the IP addresses of network which are being used by a vApp VM or by an edge gateway connected to this external network. Results can be filtered by IP address. 
     * @summary Retrieve the list of IP addresses which are being used from the network.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param externalNetworkId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getUsedIpAddresses (page: number, pageSize: number, externalNetworkId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: UsedIpAddresses;  }> {
        const localVarPath = this.basePath + '/1.0.0/externalNetworks/{externalNetworkId}/usedIpAddresses'
            .replace('{' + 'externalNetworkId' + '}', String(externalNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getUsedIpAddresses.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getUsedIpAddresses.');
        }

        // verify required parameter 'externalNetworkId' is not null or undefined
        if (externalNetworkId === null || externalNetworkId === undefined) {
            throw new Error('Required parameter externalNetworkId was null or undefined when calling getUsedIpAddresses.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UsedIpAddresses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific external network.
     * @param externalNetwork 
     * @param externalNetworkId 
     */
    public updateExternalNetwork (externalNetwork: ExternalNetwork, externalNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/externalNetworks/{externalNetworkId}'
            .replace('{' + 'externalNetworkId' + '}', String(externalNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'externalNetwork' is not null or undefined
        if (externalNetwork === null || externalNetwork === undefined) {
            throw new Error('Required parameter externalNetwork was null or undefined when calling updateExternalNetwork.');
        }

        // verify required parameter 'externalNetworkId' is not null or undefined
        if (externalNetworkId === null || externalNetworkId === undefined) {
            throw new Error('Required parameter externalNetworkId was null or undefined when calling updateExternalNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: externalNetwork,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExternalNetworksApiApiKeys {
    ApiKeyAuth,
}

export class ExternalNetworksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExternalNetworksApiApiKeys, value: string) {
        this.authentications[ExternalNetworksApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get all external networks. Results can be filtered by id, name, backing type (networkBackings.values.backingType) and context (_context). Supported contexts are: Provider vDC ID (_context==providerVdcId) - | Returns all the external networks which are available to a specific Provider vDC. Org vDC ID (_context==orgVdcId) - | Returns all the external networks which are available to a specific Org vDC. vCenter ID And Resource Pool Moref (_context==vCenterId;_context==rpMoref) - | Returns all the external networks accessible to a given vCenter resource pool. Org vDC ID And Edge Deployment Mode (_context==orgVdcId;_context==anEdgeDeploymentMode) - | Returns all the external networks to which an edge gateway can connect. Edge Deployment Mode can be 'standaloneEdgeDeployment' or 'haEdgeDeployment'. Deployment mode specifies whether to use both primary edge cluster and secondary edge cluster or just primary edge cluster to determine external network accessibility. Edge clusters are determined via vDC Network Profile for input Org vDC. Org vDC ID And Dedicatable External Networks (_context==orgVdcId;_context==dedicatable) - | Dedicatable only shows external networks that have no connected Edge Gateways. 
     * @summary Get all external networks.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getAllExternalNetworks (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: ExternalNetworks;  }> {
        const localVarPath = this.basePath + '/1.0.0/externalNetworks';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getAllExternalNetworks.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getAllExternalNetworks.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExternalNetworks;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExternalServiceApiApiKeys {
    ApiKeyAuth,
}

export class ExternalServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExternalServiceApiApiKeys, value: string) {
        this.authentications[ExternalServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create an external service. Once created, the combination of vendor, name and version cannot be modified and must be unique. Each extension will have its own MQTT topics. 
     * @summary Create external service.
     * @param service 
     */
    public createExternalService (service: ExternalService) : Promise<{ response: http.ClientResponse; body: ExternalService;  }> {
        const localVarPath = this.basePath + '/extensions/api';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'service' is not null or undefined
        if (service === null || service === undefined) {
            throw new Error('Required parameter service was null or undefined when calling createExternalService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: service,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExternalService;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an external service. The extension must be disabled or the deletion will fail. 
     * @summary Delete an external service.
     * @param id 
     */
    public deleteExternalService (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/extensions/api/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteExternalService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Extensions, created from other APIs will not be returned. 
     * @summary Retrieve an external service.
     * @param id 
     */
    public getExternalService (id: string) : Promise<{ response: http.ClientResponse; body: ExternalService;  }> {
        const localVarPath = this.basePath + '/extensions/api/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getExternalService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExternalService;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Query all external services. Extensions, created from other APIs will not be returned. 
     * @summary Query external services.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getExternalServices (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: ExternalServices;  }> {
        const localVarPath = this.basePath + '/extensions/api';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getExternalServices.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getExternalServices.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExternalServices;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an external service. Vendor, name and version cannot be updated. 
     * @summary Update an external service.
     * @param service 
     * @param id 
     */
    public updateExternalService (service: ExternalService, id: string) : Promise<{ response: http.ClientResponse; body: ExternalService;  }> {
        const localVarPath = this.basePath + '/extensions/api/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'service' is not null or undefined
        if (service === null || service === undefined) {
            throw new Error('Required parameter service was null or undefined when calling updateExternalService.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateExternalService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: service,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExternalService;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FirewallGroupApiApiKeys {
    ApiKeyAuth,
}

export class FirewallGroupApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FirewallGroupApiApiKeys, value: string) {
        this.authentications[FirewallGroupApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a Firewall Group.
     * @param firewallGroupId 
     */
    public deleteFirewallGroup (firewallGroupId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/firewallGroups/{firewallGroupId}'
            .replace('{' + 'firewallGroupId' + '}', String(firewallGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'firewallGroupId' is not null or undefined
        if (firewallGroupId === null || firewallGroupId === undefined) {
            throw new Error('Required parameter firewallGroupId was null or undefined when calling deleteFirewallGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific firewall group.
     * @param firewallGroupId 
     */
    public getFirewallGroup (firewallGroupId: string) : Promise<{ response: http.ClientResponse; body: FirewallGroupDetails;  }> {
        const localVarPath = this.basePath + '/1.0.0/firewallGroups/{firewallGroupId}'
            .replace('{' + 'firewallGroupId' + '}', String(firewallGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'firewallGroupId' is not null or undefined
        if (firewallGroupId === null || firewallGroupId === undefined) {
            throw new Error('Required parameter firewallGroupId was null or undefined when calling getFirewallGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FirewallGroupDetails;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves associated VMs for a specific firewall group.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param firewallGroupId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getFirewallGroupAssociatedVMs (page: number, pageSize: number, firewallGroupId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: FirewallGroupAssociatedVMs;  }> {
        const localVarPath = this.basePath + '/1.0.0/firewallGroups/{firewallGroupId}/associatedVMs'
            .replace('{' + 'firewallGroupId' + '}', String(firewallGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getFirewallGroupAssociatedVMs.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getFirewallGroupAssociatedVMs.');
        }

        // verify required parameter 'firewallGroupId' is not null or undefined
        if (firewallGroupId === null || firewallGroupId === undefined) {
            throw new Error('Required parameter firewallGroupId was null or undefined when calling getFirewallGroupAssociatedVMs.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FirewallGroupAssociatedVMs;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the Firewall Group.
     * @param firewallGroup 
     * @param firewallGroupId 
     */
    public updateFirewallGroup (firewallGroup: FirewallGroupDetails, firewallGroupId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/firewallGroups/{firewallGroupId}'
            .replace('{' + 'firewallGroupId' + '}', String(firewallGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'firewallGroup' is not null or undefined
        if (firewallGroup === null || firewallGroup === undefined) {
            throw new Error('Required parameter firewallGroup was null or undefined when calling updateFirewallGroup.');
        }

        // verify required parameter 'firewallGroupId' is not null or undefined
        if (firewallGroupId === null || firewallGroupId === undefined) {
            throw new Error('Required parameter firewallGroupId was null or undefined when calling updateFirewallGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: firewallGroup,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FirewallGroupsApiApiKeys {
    ApiKeyAuth,
}

export class FirewallGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FirewallGroupsApiApiKeys, value: string) {
        this.authentications[FirewallGroupsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a firewall group. 
     * @summary Create a firewall group
     * @param firewallGroup 
     */
    public createFirewallGroup (firewallGroup: FirewallGroupDetails) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/firewallGroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'firewallGroup' is not null or undefined
        if (firewallGroup === null || firewallGroup === undefined) {
            throw new Error('Required parameter firewallGroup was null or undefined when calling createFirewallGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: firewallGroup,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all firewall groups. Results can be filtered by name and context (_context). Supported contexts are:   <ul>   <li>Org Vdc Network ID <code>(_context==networkId)</code> -   Returns all the firewall groups which the specified network is a member of.   <li>Edge Gateway ID <code>(_context==edgeGatewayId)</code> -   Returns all the firewall groups which are available to the specific edge gateway.   <li>Network Provider ID <code>(_context==networkProviderId)</code> -   Returns all the firewall groups which are available under a specific network provider. This context requires system admin privilege.   </ul> 
     * @summary Retrieves the Firewall Groups.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getFirewallGroups (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: FirewallGroups;  }> {
        const localVarPath = this.basePath + '/1.0.0/firewallGroups/summaries';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getFirewallGroups.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getFirewallGroups.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FirewallGroups;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GlobalRolesApiApiKeys {
    ApiKeyAuth,
}

export class GlobalRolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GlobalRolesApiApiKeys, value: string) {
        this.authentications[GlobalRolesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Adds the list of rights (passed as references) to a global role. 
     * @summary Adds the specified rights to a global role.
     * @param rightsReferencesBody 
     * @param id 
     */
    public addRightsToGlobalRole (rightsReferencesBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}/rights'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'rightsReferencesBody' is not null or undefined
        if (rightsReferencesBody === null || rightsReferencesBody === undefined) {
            throw new Error('Required parameter rightsReferencesBody was null or undefined when calling addRightsToGlobalRole.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addRightsToGlobalRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rightsReferencesBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new global role 
     * @summary Creates a new global role
     * @param newGlobalRole 
     */
    public createGlobalRole (newGlobalRole: GlobalRole) : Promise<{ response: http.ClientResponse; body: GlobalRole;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newGlobalRole' is not null or undefined
        if (newGlobalRole === null || newGlobalRole === undefined) {
            throw new Error('Required parameter newGlobalRole was null or undefined when calling createGlobalRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newGlobalRole,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GlobalRole;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified global role
     * @param id 
     */
    public deleteGlobalRole (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteGlobalRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified global role
     * @param id 
     */
    public getGlobalRole (id: string) : Promise<{ response: http.ClientResponse; body: GlobalRole;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getGlobalRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GlobalRole;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the global role to the specified tenants 
     * @summary Publishes the global role to the specified tenants
     * @param publishTenantsBody 
     * @param id 
     */
    public postGlobalRolePublish (publishTenantsBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}/tenants/publish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling postGlobalRolePublish.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postGlobalRolePublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the global role to all tenants 
     * @summary Publishes the global role to all tenants
     * @param id 
     */
    public postGlobalRolePublishAll (id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}/tenants/publishAll'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postGlobalRolePublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revokes publication of the global role to the specified tenants 
     * @summary Revokes publication of the global role to the specified tenants
     * @param unpublishTenantsBody 
     * @param id 
     */
    public postGlobalRoleUnpublish (unpublishTenantsBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}/tenants/unpublish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'unpublishTenantsBody' is not null or undefined
        if (unpublishTenantsBody === null || unpublishTenantsBody === undefined) {
            throw new Error('Required parameter unpublishTenantsBody was null or undefined when calling postGlobalRoleUnpublish.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postGlobalRoleUnpublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unpublishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unpublishes the global role from all tenants 
     * @summary Unpublishes the global role from all tenants
     * @param id 
     */
    public postGlobalRoleUnpublishAll (id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}/tenants/unpublishAll'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postGlobalRoleUnpublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of rights (as references) contained by a particular global role 
     * @summary Gets a paged list of rights (as references) contained by a particular global role
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryGlobalRoleRights (page: number, pageSize: number, id: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}/rights'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryGlobalRoleRights.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryGlobalRoleRights.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling queryGlobalRoleRights.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves list of tenants for whom the global role is explicitly published 
     * @summary Retrieves list of tenants for whom the global role is explicitly published
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryGlobalRoleTenants (page: number, pageSize: number, id: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}/tenants'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryGlobalRoleTenants.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryGlobalRoleTenants.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling queryGlobalRoleTenants.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of global roles 
     * @summary Get list of global roles
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryGlobalRoles (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: GlobalRoles;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryGlobalRoles.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryGlobalRoles.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GlobalRoles;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replaces the existing set of rights in global role with the rights (as references) supplied. 
     * @summary Replaces the existing set of rights in global role with the rights (as references) supplied.
     * @param rightsReferencesBody 
     * @param id 
     */
    public replaceRightsInGlobalRole (rightsReferencesBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}/rights'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'rightsReferencesBody' is not null or undefined
        if (rightsReferencesBody === null || rightsReferencesBody === undefined) {
            throw new Error('Required parameter rightsReferencesBody was null or undefined when calling replaceRightsInGlobalRole.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replaceRightsInGlobalRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rightsReferencesBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resets list of tenants for whom the global role is explicitly published 
     * @summary Resets list of tenants for whom the global role is explicitly published
     * @param publishTenantsBody 
     * @param id 
     */
    public setGlobalRoleTenants (publishTenantsBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}/tenants'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling setGlobalRoleTenants.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setGlobalRoleTenants.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified global role
     * @param updatedGlobalRole 
     * @param id 
     */
    public updateGlobalRole (updatedGlobalRole: GlobalRole, id: string) : Promise<{ response: http.ClientResponse; body: GlobalRole;  }> {
        const localVarPath = this.basePath + '/1.0.0/globalRoles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedGlobalRole' is not null or undefined
        if (updatedGlobalRole === null || updatedGlobalRole === undefined) {
            throw new Error('Required parameter updatedGlobalRole was null or undefined when calling updateGlobalRole.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateGlobalRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedGlobalRole,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GlobalRole;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GroupApiApiKeys {
    ApiKeyAuth,
}

export class GroupApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GroupApiApiKeys, value: string) {
        this.authentications[GroupApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a specified group.
     * @param groupUrn groupUrn
     */
    public getGroup (groupUrn: string) : Promise<{ response: http.ClientResponse; body: UserGroup;  }> {
        const localVarPath = this.basePath + '/1.0.0/groups/{groupUrn}'
            .replace('{' + 'groupUrn' + '}', String(groupUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'groupUrn' is not null or undefined
        if (groupUrn === null || groupUrn === undefined) {
            throw new Error('Required parameter groupUrn was null or undefined when calling getGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserGroup;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of users of any type that belong to the specified group.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param groupUrn groupUrn
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryGroupUsers (page: number, pageSize: number, groupUrn: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/groups/{groupUrn}/users'
            .replace('{' + 'groupUrn' + '}', String(groupUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryGroupUsers.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryGroupUsers.');
        }

        // verify required parameter 'groupUrn' is not null or undefined
        if (groupUrn === null || groupUrn === undefined) {
            throw new Error('Required parameter groupUrn was null or undefined when calling queryGroupUsers.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of groups. 
     * @summary Get a list of groups.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryGroups (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: UserGroups;  }> {
        const localVarPath = this.basePath + '/1.0.0/groups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryGroups.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryGroups.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserGroups;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LDAPApiApiKeys {
    ApiKeyAuth,
}

export class LDAPApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LDAPApiApiKeys, value: string) {
        this.authentications[LDAPApiApiKeys[key]].apiKey = value;
    }
    /**
     * Searches LDAP for given group(s) 
     * @summary Search LDAP Groups
     * @param q String to search for via LDAP
     */
    public searchLdapGroups (q?: string) : Promise<{ response: http.ClientResponse; body: Array<UserGroup>;  }> {
        const localVarPath = this.basePath + '/1.0.0/ldap/search/group';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (q !== undefined) {
            queryParameters['q'] = q;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<UserGroup>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches LDAP for given user(s) 
     * @summary Search LDAP Users
     * @param q String to search for via LDAP
     */
    public searchLdapUsers (q?: string) : Promise<{ response: http.ClientResponse; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/1.0.0/ldap/search/user';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (q !== undefined) {
            queryParameters['q'] = q;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<User>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Begins the LDAP sync task 
     * @summary Synchronize LDAP users/settings
     */
    public syncLdap () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/ldap/sync';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Tests that custom LDAP settings are valid, and that the system can use them to search for a user or group 
     * @summary Tests LDAP Connection and Settings
     * @param ldapSettings LDAP Settings to use for testing connection
     * @param username Username to use when testing LDAP search
     */
    public testLdap (ldapSettings: LdapSettings, username?: string) : Promise<{ response: http.ClientResponse; body: LdapTestResult;  }> {
        const localVarPath = this.basePath + '/1.0.0/ldap/test';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ldapSettings' is not null or undefined
        if (ldapSettings === null || ldapSettings === undefined) {
            throw new Error('Required parameter ldapSettings was null or undefined when calling testLdap.');
        }

        if (username !== undefined) {
            queryParameters['username'] = username;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ldapSettings,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LdapTestResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoadBalancerCloudApiApiKeys {
    ApiKeyAuth,
}

export class LoadBalancerCloudApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoadBalancerCloudApiApiKeys, value: string) {
        this.authentications[LoadBalancerCloudApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves a specific Load Balancer Cloud. 
     * @summary Get Load Balancer Cloud.
     * @param loadBalancerCloudId 
     */
    public getLoadBalancerCloud (loadBalancerCloudId: string) : Promise<{ response: http.ClientResponse; body: LoadBalancerCloud;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/clouds/{loadBalancerCloudId}'
            .replace('{' + 'loadBalancerCloudId' + '}', String(loadBalancerCloudId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerCloudId' is not null or undefined
        if (loadBalancerCloudId === null || loadBalancerCloudId === undefined) {
            throw new Error('Required parameter loadBalancerCloudId was null or undefined when calling getLoadBalancerCloud.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LoadBalancerCloud;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unregister an Load Balancer Cloud. 
     * @summary Unregister the specified Load Balancer Cloud.
     * @param loadBalancerCloudId 
     */
    public unregisterLoadBalancerCloud (loadBalancerCloudId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/clouds/{loadBalancerCloudId}'
            .replace('{' + 'loadBalancerCloudId' + '}', String(loadBalancerCloudId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerCloudId' is not null or undefined
        if (loadBalancerCloudId === null || loadBalancerCloudId === undefined) {
            throw new Error('Required parameter loadBalancerCloudId was null or undefined when calling unregisterLoadBalancerCloud.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoadBalancerCloudsApiApiKeys {
    ApiKeyAuth,
}

export class LoadBalancerCloudsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoadBalancerCloudsApiApiKeys, value: string) {
        this.authentications[LoadBalancerCloudsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves all registered Load Balancer Clouds. 
     * @summary Get all registered Load Balancer Clouds in the system.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getLoadBalancerClouds (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: LoadBalancerClouds;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/clouds';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getLoadBalancerClouds.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getLoadBalancerClouds.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LoadBalancerClouds;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Register a new Load Balancer Cloud to be used with vCloud Director. 
     * @summary Register a new Load Balancer Cloud.
     * @param loadBalancerCloud 
     */
    public registerLoadBalancerCloud (loadBalancerCloud: LoadBalancerCloud) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/clouds';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerCloud' is not null or undefined
        if (loadBalancerCloud === null || loadBalancerCloud === undefined) {
            throw new Error('Required parameter loadBalancerCloud was null or undefined when calling registerLoadBalancerCloud.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loadBalancerCloud,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoadBalancerControllerApiApiKeys {
    ApiKeyAuth,
}

export class LoadBalancerControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoadBalancerControllerApiApiKeys, value: string) {
        this.authentications[LoadBalancerControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves a specific Load Balancer Controller. 
     * @summary Get Load Balancer Controller
     * @param loadBalancerControllerId 
     */
    public getLoadBalancerController (loadBalancerControllerId: string) : Promise<{ response: http.ClientResponse; body: LoadBalancerController;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/controllers/{loadBalancerControllerId}'
            .replace('{' + 'loadBalancerControllerId' + '}', String(loadBalancerControllerId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerControllerId' is not null or undefined
        if (loadBalancerControllerId === null || loadBalancerControllerId === undefined) {
            throw new Error('Required parameter loadBalancerControllerId was null or undefined when calling getLoadBalancerController.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LoadBalancerController;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unregister an Load Balancer Controller. 
     * @summary Unregister the specified Load Balancer Controller.
     * @param loadBalancerControllerId 
     */
    public unregisterLoadBalancerController (loadBalancerControllerId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/controllers/{loadBalancerControllerId}'
            .replace('{' + 'loadBalancerControllerId' + '}', String(loadBalancerControllerId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerControllerId' is not null or undefined
        if (loadBalancerControllerId === null || loadBalancerControllerId === undefined) {
            throw new Error('Required parameter loadBalancerControllerId was null or undefined when calling unregisterLoadBalancerController.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an Load Balancer Controller. 
     * @summary Update specified Load Balancer Controller
     * @param loadBalancerController 
     * @param loadBalancerControllerId 
     */
    public updateLoadBalancerController (loadBalancerController: LoadBalancerController, loadBalancerControllerId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/controllers/{loadBalancerControllerId}'
            .replace('{' + 'loadBalancerControllerId' + '}', String(loadBalancerControllerId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerController' is not null or undefined
        if (loadBalancerController === null || loadBalancerController === undefined) {
            throw new Error('Required parameter loadBalancerController was null or undefined when calling updateLoadBalancerController.');
        }

        // verify required parameter 'loadBalancerControllerId' is not null or undefined
        if (loadBalancerControllerId === null || loadBalancerControllerId === undefined) {
            throw new Error('Required parameter loadBalancerControllerId was null or undefined when calling updateLoadBalancerController.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loadBalancerController,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoadBalancerControllersApiApiKeys {
    ApiKeyAuth,
}

export class LoadBalancerControllersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoadBalancerControllersApiApiKeys, value: string) {
        this.authentications[LoadBalancerControllersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves all registered Load Balancer Controllers. 
     * @summary Get all registered Load Balancer Controllers in the system.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getLoadBalancerControllers (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: LoadBalancerControllers;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/controllers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getLoadBalancerControllers.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getLoadBalancerControllers.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LoadBalancerControllers;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Register a new Load Balancer Controller to be used with vCloud Director. 
     * @summary Register a new Load Balancer Controller
     * @param loadBalancerController 
     */
    public registerLoadBalancerController (loadBalancerController: LoadBalancerController) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/controllers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerController' is not null or undefined
        if (loadBalancerController === null || loadBalancerController === undefined) {
            throw new Error('Required parameter loadBalancerController was null or undefined when calling registerLoadBalancerController.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loadBalancerController,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoadBalancerServiceEngineGroupApiApiKeys {
    ApiKeyAuth,
}

export class LoadBalancerServiceEngineGroupApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoadBalancerServiceEngineGroupApiApiKeys, value: string) {
        this.authentications[LoadBalancerServiceEngineGroupApiApiKeys[key]].apiKey = value;
    }
    /**
     * Delete a Load Balancer Service Engine Group. 
     * @summary Delete the specified Load Balancer Service Engine Group.
     * @param loadBalancerServiceEngineGroupId 
     */
    public deleteServiceEngineGroup (loadBalancerServiceEngineGroupId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups/{loadBalancerServiceEngineGroupId}'
            .replace('{' + 'loadBalancerServiceEngineGroupId' + '}', String(loadBalancerServiceEngineGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerServiceEngineGroupId' is not null or undefined
        if (loadBalancerServiceEngineGroupId === null || loadBalancerServiceEngineGroupId === undefined) {
            throw new Error('Required parameter loadBalancerServiceEngineGroupId was null or undefined when calling deleteServiceEngineGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a specific Load Balancer Service Engine Group. 
     * @summary Get Load Balancer Service Engine Group.
     * @param loadBalancerServiceEngineGroupId 
     */
    public getServiceEngineGroup (loadBalancerServiceEngineGroupId: string) : Promise<{ response: http.ClientResponse; body: LoadBalancerServiceEngineGroup;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups/{loadBalancerServiceEngineGroupId}'
            .replace('{' + 'loadBalancerServiceEngineGroupId' + '}', String(loadBalancerServiceEngineGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerServiceEngineGroupId' is not null or undefined
        if (loadBalancerServiceEngineGroupId === null || loadBalancerServiceEngineGroupId === undefined) {
            throw new Error('Required parameter loadBalancerServiceEngineGroupId was null or undefined when calling getServiceEngineGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LoadBalancerServiceEngineGroup;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Syncs a specified Load Balancer Service Engine Group. Requests the HA mode and the maximum number of supported Virtual Services for this Service Engine Group from the Load Balancer, and updates vCD's local record of these properties. 
     * @summary Sync Load Balancer Service Engine Group.
     * @param loadBalancerServiceEngineGroupId 
     */
    public syncServiceEngineGroup (loadBalancerServiceEngineGroupId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups/{loadBalancerServiceEngineGroupId}/sync'
            .replace('{' + 'loadBalancerServiceEngineGroupId' + '}', String(loadBalancerServiceEngineGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerServiceEngineGroupId' is not null or undefined
        if (loadBalancerServiceEngineGroupId === null || loadBalancerServiceEngineGroupId === undefined) {
            throw new Error('Required parameter loadBalancerServiceEngineGroupId was null or undefined when calling syncServiceEngineGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a Load Balancer Service Engine Group. 
     * @summary Update specified Load Balancer Service Engine Group.
     * @param loadBalancerServiceEngineGroup 
     * @param loadBalancerServiceEngineGroupId 
     */
    public updateServiceEngineGroup (loadBalancerServiceEngineGroup: LoadBalancerServiceEngineGroup, loadBalancerServiceEngineGroupId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups/{loadBalancerServiceEngineGroupId}'
            .replace('{' + 'loadBalancerServiceEngineGroupId' + '}', String(loadBalancerServiceEngineGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerServiceEngineGroup' is not null or undefined
        if (loadBalancerServiceEngineGroup === null || loadBalancerServiceEngineGroup === undefined) {
            throw new Error('Required parameter loadBalancerServiceEngineGroup was null or undefined when calling updateServiceEngineGroup.');
        }

        // verify required parameter 'loadBalancerServiceEngineGroupId' is not null or undefined
        if (loadBalancerServiceEngineGroupId === null || loadBalancerServiceEngineGroupId === undefined) {
            throw new Error('Required parameter loadBalancerServiceEngineGroupId was null or undefined when calling updateServiceEngineGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loadBalancerServiceEngineGroup,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoadBalancerServiceEngineGroupAssignmentApiApiKeys {
    ApiKeyAuth,
}

export class LoadBalancerServiceEngineGroupAssignmentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoadBalancerServiceEngineGroupAssignmentApiApiKeys, value: string) {
        this.authentications[LoadBalancerServiceEngineGroupAssignmentApiApiKeys[key]].apiKey = value;
    }
    /**
     * Delete a Load Balancer Service Engine Group Assignment. The Edge Gateway will no longer be able to use the Load Balancer Service Engine Group for load balancing resources. 
     * @summary Delete the specified Load Balancer Service Engine Group Assignment.
     * @param assignmentId 
     */
    public deleteServiceEngineGroupAssignment (assignmentId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups/assignments/{assignmentId}'
            .replace('{' + 'assignmentId' + '}', String(assignmentId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling deleteServiceEngineGroupAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a specific Load Balancer Service Engine Group Assignment. 
     * @summary Get a Load Balancer Service Engine Group Assignment.
     * @param assignmentId 
     */
    public getServiceEngineGroupAssignment (assignmentId: string) : Promise<{ response: http.ClientResponse; body: LoadBalancerServiceEngineGroupAssignment;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups/assignments/{assignmentId}'
            .replace('{' + 'assignmentId' + '}', String(assignmentId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getServiceEngineGroupAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LoadBalancerServiceEngineGroupAssignment;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a Load Balancer Service Engine Group Assignment. Updates are not allowed if the associated Load Balancer Service Engine Group has reservation type 'DEDICATED'. 
     * @summary Update a Load Balancer Service Engine Group Assignment.
     * @param assignment 
     * @param assignmentId 
     */
    public updateServiceEngineGroupAssignment (assignment: LoadBalancerServiceEngineGroupAssignment, assignmentId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups/assignments/{assignmentId}'
            .replace('{' + 'assignmentId' + '}', String(assignmentId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'assignment' is not null or undefined
        if (assignment === null || assignment === undefined) {
            throw new Error('Required parameter assignment was null or undefined when calling updateServiceEngineGroupAssignment.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling updateServiceEngineGroupAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: assignment,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoadBalancerServiceEngineGroupAssignmentsApiApiKeys {
    ApiKeyAuth,
}

export class LoadBalancerServiceEngineGroupAssignmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoadBalancerServiceEngineGroupAssignmentsApiApiKeys, value: string) {
        this.authentications[LoadBalancerServiceEngineGroupAssignmentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new Load Balancer Service Engine Group Assignment. The assignment links a Load Balancer Service Engine Group with an Edge Gateway to provide load balancing resources to the Edge Gateway. 
     * @summary Create a new Load Balancer Service Engine Group Assignment.
     * @param assignment 
     */
    public createServiceEngineGroupAssignment (assignment: LoadBalancerServiceEngineGroupAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups/assignments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'assignment' is not null or undefined
        if (assignment === null || assignment === undefined) {
            throw new Error('Required parameter assignment was null or undefined when calling createServiceEngineGroupAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: assignment,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the service engine group assignments for the Load Balancer Service Engine Group. 
     * @summary Get the assignments for a Load Balancer Service Engine Group.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getServiceEngineGroupAssignments (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: LoadBalancerServiceEngineGroupAssignments;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups/assignments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getServiceEngineGroupAssignments.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getServiceEngineGroupAssignments.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LoadBalancerServiceEngineGroupAssignments;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LoadBalancerServiceEngineGroupsApiApiKeys {
    ApiKeyAuth,
}

export class LoadBalancerServiceEngineGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LoadBalancerServiceEngineGroupsApiApiKeys, value: string) {
        this.authentications[LoadBalancerServiceEngineGroupsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new Load Balancer Service Engine Group to be used with VMware Cloud Director. 
     * @summary Create a new Load Balancer Service Engine Group.
     * @param loadBalancerServiceEngineGroup 
     */
    public createServiceEngineGroup (loadBalancerServiceEngineGroup: LoadBalancerServiceEngineGroup) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loadBalancerServiceEngineGroup' is not null or undefined
        if (loadBalancerServiceEngineGroup === null || loadBalancerServiceEngineGroup === undefined) {
            throw new Error('Required parameter loadBalancerServiceEngineGroup was null or undefined when calling createServiceEngineGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loadBalancerServiceEngineGroup,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all Load Balancer Service Engine Groups. Supported contexts are: Gateway ID <code>(_context==gatewayId)</code> - | Returns all Load Balancer Service Engine Groups that are accessible to the gateway. Assignable Gateway ID <code>(_context=gatewayId;_context==assignable)</code> - | Returns all Load Balancer Service Engine Groups that are assignable to the gateway. This filters out any Load Balancer Service Engine groups that are already assigned to the gateway or assigned to another gateway if the reservation type is 'DEDICATED'. 
     * @summary Get all Load Balancer Service Engine Groups in the system.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getServiceEngineGroups (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: LoadBalancerServiceEngineGroups;  }> {
        const localVarPath = this.basePath + '/1.0.0/loadBalancer/serviceEngineGroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getServiceEngineGroups.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getServiceEngineGroups.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LoadBalancerServiceEngineGroups;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LogicalVmGroupsApiApiKeys {
    ApiKeyAuth,
}

export class LogicalVmGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LogicalVmGroupsApiApiKeys, value: string) {
        this.authentications[LogicalVmGroupsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Assign named vm groups to logical vm group.
     * @param namedVmGroupRefs 
     * @param logicalVmGroupId 
     */
    public addNamedVmGroupsToLogicalVmGroup (namedVmGroupRefs: Array<EntityReference>, logicalVmGroupId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/1.0.0/logicalVmGroups/{logicalVmGroupId}/namedVmGroups'
            .replace('{' + 'logicalVmGroupId' + '}', String(logicalVmGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'namedVmGroupRefs' is not null or undefined
        if (namedVmGroupRefs === null || namedVmGroupRefs === undefined) {
            throw new Error('Required parameter namedVmGroupRefs was null or undefined when calling addNamedVmGroupsToLogicalVmGroup.');
        }

        // verify required parameter 'logicalVmGroupId' is not null or undefined
        if (logicalVmGroupId === null || logicalVmGroupId === undefined) {
            throw new Error('Required parameter logicalVmGroupId was null or undefined when calling addNamedVmGroupsToLogicalVmGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: namedVmGroupRefs,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new logical vm group 
     * @summary Creates a new logical vm group
     * @param newLogicalVmGroupParams 
     */
    public createLogicalVmGroup (newLogicalVmGroupParams: LogicalVmGroup) : Promise<{ response: http.ClientResponse; body: LogicalVmGroup;  }> {
        const localVarPath = this.basePath + '/1.0.0/logicalVmGroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newLogicalVmGroupParams' is not null or undefined
        if (newLogicalVmGroupParams === null || newLogicalVmGroupParams === undefined) {
            throw new Error('Required parameter newLogicalVmGroupParams was null or undefined when calling createLogicalVmGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newLogicalVmGroupParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LogicalVmGroup;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified logical vm group.
     * @param logicalVmGroupId 
     */
    public deleteLogicalVmGroup (logicalVmGroupId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/logicalVmGroups/{logicalVmGroupId}'
            .replace('{' + 'logicalVmGroupId' + '}', String(logicalVmGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'logicalVmGroupId' is not null or undefined
        if (logicalVmGroupId === null || logicalVmGroupId === undefined) {
            throw new Error('Required parameter logicalVmGroupId was null or undefined when calling deleteLogicalVmGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified logical vm group
     * @param logicalVmGroupId 
     */
    public getLogicalVmGroup (logicalVmGroupId: string) : Promise<{ response: http.ClientResponse; body: LogicalVmGroup;  }> {
        const localVarPath = this.basePath + '/1.0.0/logicalVmGroups/{logicalVmGroupId}'
            .replace('{' + 'logicalVmGroupId' + '}', String(logicalVmGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'logicalVmGroupId' is not null or undefined
        if (logicalVmGroupId === null || logicalVmGroupId === undefined) {
            throw new Error('Required parameter logicalVmGroupId was null or undefined when calling getLogicalVmGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LogicalVmGroup;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all named vm groups associated with logical vm group
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param logicalVmGroupId 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getLogicalVmGroupNamedVmGroups (page: number, pageSize: number, logicalVmGroupId: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/logicalVmGroups/{logicalVmGroupId}/namedVmGroups'
            .replace('{' + 'logicalVmGroupId' + '}', String(logicalVmGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getLogicalVmGroupNamedVmGroups.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getLogicalVmGroupNamedVmGroups.');
        }

        // verify required parameter 'logicalVmGroupId' is not null or undefined
        if (logicalVmGroupId === null || logicalVmGroupId === undefined) {
            throw new Error('Required parameter logicalVmGroupId was null or undefined when calling getLogicalVmGroupNamedVmGroups.');
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all pvdc policies associated with logical vm group
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param logicalVmGroupId 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getPvdcPoliciesForLogicalVmGroup (page: number, pageSize: number, logicalVmGroupId: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/logicalVmGroups/{logicalVmGroupId}/pvdcPolicies'
            .replace('{' + 'logicalVmGroupId' + '}', String(logicalVmGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getPvdcPoliciesForLogicalVmGroup.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getPvdcPoliciesForLogicalVmGroup.');
        }

        // verify required parameter 'logicalVmGroupId' is not null or undefined
        if (logicalVmGroupId === null || logicalVmGroupId === undefined) {
            throw new Error('Required parameter logicalVmGroupId was null or undefined when calling getPvdcPoliciesForLogicalVmGroup.');
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of logical vm groups. 
     * @summary Get list of logical vm groups.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryLogicalVmGroups (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: LogicalVmGroups;  }> {
        const localVarPath = this.basePath + '/1.0.0/logicalVmGroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryLogicalVmGroups.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryLogicalVmGroups.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LogicalVmGroups;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified logical vm group
     * @param updateLogicalVmGroupParams 
     * @param logicalVmGroupId 
     */
    public updateLogicalVmGroup (updateLogicalVmGroupParams: LogicalVmGroup, logicalVmGroupId: string) : Promise<{ response: http.ClientResponse; body: LogicalVmGroup;  }> {
        const localVarPath = this.basePath + '/1.0.0/logicalVmGroups/{logicalVmGroupId}'
            .replace('{' + 'logicalVmGroupId' + '}', String(logicalVmGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updateLogicalVmGroupParams' is not null or undefined
        if (updateLogicalVmGroupParams === null || updateLogicalVmGroupParams === undefined) {
            throw new Error('Required parameter updateLogicalVmGroupParams was null or undefined when calling updateLogicalVmGroup.');
        }

        // verify required parameter 'logicalVmGroupId' is not null or undefined
        if (logicalVmGroupId === null || logicalVmGroupId === undefined) {
            throw new Error('Required parameter logicalVmGroupId was null or undefined when calling updateLogicalVmGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateLogicalVmGroupParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LogicalVmGroup;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NetworkContextProfileApiApiKeys {
    ApiKeyAuth,
}

export class NetworkContextProfileApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NetworkContextProfileApiApiKeys, value: string) {
        this.authentications[NetworkContextProfileApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific network context profile, removing the associated firewall rule and permitting the traffic this profile restricts.
     * @param profileId 
     */
    public deleteNetworkContextProfile (profileId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkContextProfiles/{profileId}'
            .replace('{' + 'profileId' + '}', String(profileId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'profileId' is not null or undefined
        if (profileId === null || profileId === undefined) {
            throw new Error('Required parameter profileId was null or undefined when calling deleteNetworkContextProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single network context profile. 
     * @summary Get a specific network context profile.
     * @param profileId 
     */
    public getNetworkContextProfile (profileId: string) : Promise<{ response: http.ClientResponse; body: NetworkContextProfile;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkContextProfiles/{profileId}'
            .replace('{' + 'profileId' + '}', String(profileId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'profileId' is not null or undefined
        if (profileId === null || profileId === undefined) {
            throw new Error('Required parameter profileId was null or undefined when calling getNetworkContextProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NetworkContextProfile;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific user-defined network context profile, changing the associated firewall and modifying the traffic this profile restricts.
     * @param networkContextProfile 
     * @param profileId 
     */
    public updateNetworkContextProfile (networkContextProfile: NetworkContextProfile, profileId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkContextProfiles/{profileId}'
            .replace('{' + 'profileId' + '}', String(profileId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'networkContextProfile' is not null or undefined
        if (networkContextProfile === null || networkContextProfile === undefined) {
            throw new Error('Required parameter networkContextProfile was null or undefined when calling updateNetworkContextProfile.');
        }

        // verify required parameter 'profileId' is not null or undefined
        if (profileId === null || profileId === undefined) {
            throw new Error('Required parameter profileId was null or undefined when calling updateNetworkContextProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: networkContextProfile,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NetworkContextProfileAttributesApiApiKeys {
    ApiKeyAuth,
}

export class NetworkContextProfileAttributesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NetworkContextProfileAttributesApiApiKeys, value: string) {
        this.authentications[NetworkContextProfileAttributesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves all available network context profile attributes and sub-attributes for the given NSX-T manager, based on the filter parameter given in FIQL format (e.g. filter=\"_context==urn:vcloud:nsxtmanager:<some_id>\"). Optionally filter by attribute type by adding a FIQL name parameter to the above filter context (e.g. filter=\"_context==<urn>;name=APP_ID\") 
     * @summary List all supported network context profile attributes and sub-attributes for the given NSX-T manager.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getNetworkContextProfileAttributes (filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: NetworkContextProfileAttributes;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkContextProfiles/attributes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NetworkContextProfileAttributes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NetworkContextProfilesApiApiKeys {
    ApiKeyAuth,
}

export class NetworkContextProfilesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NetworkContextProfilesApiApiKeys, value: string) {
        this.authentications[NetworkContextProfilesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a user-defined network context profile.
     * @param networkContextProfile 
     */
    public createNetworkContextProfile (networkContextProfile: NetworkContextProfile) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkContextProfiles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'networkContextProfile' is not null or undefined
        if (networkContextProfile === null || networkContextProfile === undefined) {
            throw new Error('Required parameter networkContextProfile was null or undefined when calling createNetworkContextProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: networkContextProfile,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all network context profiles defined in the system. Supported contexts are: <ul> <li> Org vDC ID <code>(_context==orgVdcId)</code> - Returns all the network context profiles which are available to a specific Org vDC. <li>Network provider ID (_context==networkProviderId) - | Returns all the network context profiles which are available for a specific network provider. <li>VDC Group Id <code>(_context==vdcGroupId)</code> - | Returns all the network context profiles which are available to a specific vDC Group. </ul> 
     * @summary Get all network context profiles.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getNetworkContextProfiles (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: NetworkContextProfiles;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkContextProfiles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getNetworkContextProfiles.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getNetworkContextProfiles.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NetworkContextProfiles;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sync the network context profiles from the network provider to VCD. The network provider is required to be specified in the filter context. Context example: (_context==networkProviderId). 
     * @summary Sync the network context profiles from the network provider to VCD.
     * @param filter Filter for a query.  FIQL format.
     */
    public syncNetworkContextProfiles (filter?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkContextProfiles/sync';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NetworkPoolApiApiKeys {
    ApiKeyAuth,
}

export class NetworkPoolApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NetworkPoolApiApiKeys, value: string) {
        this.authentications[NetworkPoolApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific network pool.
     * @param networkPoolId 
     */
    public deleteNetworkPool (networkPoolId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkPools/{networkPoolId}'
            .replace('{' + 'networkPoolId' + '}', String(networkPoolId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'networkPoolId' is not null or undefined
        if (networkPoolId === null || networkPoolId === undefined) {
            throw new Error('Required parameter networkPoolId was null or undefined when calling deleteNetworkPool.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific Network Pool.
     * @param networkPoolId 
     */
    public getNetworkPool (networkPoolId: string) : Promise<{ response: http.ClientResponse; body: NetworkPool;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkPools/{networkPoolId}'
            .replace('{' + 'networkPoolId' + '}', String(networkPoolId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'networkPoolId' is not null or undefined
        if (networkPoolId === null || networkPoolId === undefined) {
            throw new Error('Required parameter networkPoolId was null or undefined when calling getNetworkPool.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NetworkPool;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Synchronize the VXLAN network pool. If the user changes a transport zone in NSX by adding or removing clusters, synchronizing the VXLAN network pool ensures that the defined scope of the network pool is reflected in the scope of its corresponding transport zone. 
     * @summary Synchronize the VXLAN network pool.
     * @param networkPoolId 
     */
    public syncNetworkPool (networkPoolId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkPools/{networkPoolId}/sync'
            .replace('{' + 'networkPoolId' + '}', String(networkPoolId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'networkPoolId' is not null or undefined
        if (networkPoolId === null || networkPoolId === undefined) {
            throw new Error('Required parameter networkPoolId was null or undefined when calling syncNetworkPool.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific network pool.
     * @param networkPool 
     * @param networkPoolId 
     */
    public updateNetworkPool (networkPool: NetworkPool, networkPoolId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkPools/{networkPoolId}'
            .replace('{' + 'networkPoolId' + '}', String(networkPoolId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'networkPool' is not null or undefined
        if (networkPool === null || networkPool === undefined) {
            throw new Error('Required parameter networkPool was null or undefined when calling updateNetworkPool.');
        }

        // verify required parameter 'networkPoolId' is not null or undefined
        if (networkPoolId === null || networkPoolId === undefined) {
            throw new Error('Required parameter networkPoolId was null or undefined when calling updateNetworkPool.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: networkPool,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NetworkPoolsApiApiKeys {
    ApiKeyAuth,
}

export class NetworkPoolsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NetworkPoolsApiApiKeys, value: string) {
        this.authentications[NetworkPoolsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a network pool. 
     * @summary Create a new network pool.
     * @param networkPool 
     */
    public createNetworkPool (networkPool: NetworkPool) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkPools';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'networkPool' is not null or undefined
        if (networkPool === null || networkPool === undefined) {
            throw new Error('Required parameter networkPool was null or undefined when calling createNetworkPool.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: networkPool,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves summary of all Network Pools in the system. Results can be filtered by context `(_context)`. Supported contexts are: <ul> <li>Provider vDC ID <code>(_context==providerVdcId)</code> - Returns all the network pools which are available to a specific Provider vDC. <li>Org vDC ID <code>(_context==orgVdcId)</code> - Returns all the network pools which are available to a specific Org vDC. <li>Virtual Center ID <code>(managingOwnerRef.id==vcId)</code> + Resource Pool Moref <code>(_context==moref)</code> - Returns all the network pools which are related to a specific Resoure Pool. </ul> 
     * @summary Get summary of all the Network Pools in the system.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getNetworkPoolsSummary (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: NetworkPoolsSummary;  }> {
        const localVarPath = this.basePath + '/1.0.0/networkPools/networkPoolSummaries';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getNetworkPoolsSummary.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getNetworkPoolsSummary.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NetworkPoolsSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NsxAlbResourcesApiApiKeys {
    ApiKeyAuth,
}

export class NsxAlbResourcesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NsxAlbResourcesApiApiKeys, value: string) {
        this.authentications[NsxAlbResourcesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get all NSX-ALB Clouds that are configured on an NSX-ALB Controller.  Clouds that are already imported are marked appropriately. The \"_context\" filter key must be set with the id of the Load Balancer Controller for which we want to get the NSX-ALB Clouds for. 
     * @summary Get all NSX-ALB Clouds from an NSX-ALB Controller.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getImportableClouds (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: NsxAlbClouds;  }> {
        const localVarPath = this.basePath + '/1.0.0/nsxAlbResources/importableClouds';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getImportableClouds.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getImportableClouds.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NsxAlbClouds;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all importable Service Engine Groups that are configured for an NSX-ALB Cloud. Service Engine Groups that are already imported are filtered out. The \"_context\" filter key must be set with the id of the Load Balancer Cloud for which we want to get the NSX-ALB Service Engine Groups for. Example: (_context==urn:vcloud:loadBalancerCloud:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx) 
     * @summary Get all importable Service Engine Groups from an NSX-ALB Cloud.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param cursor Field used for getting next page of records. The value is supplied by the current result page. If not set, the first page is retrieved. If cursor is set, then all other pagination query parameters such as pageSize, sortDesc, sortAsc, queryFilter are ignored. 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getImportableServiceEngineGroups (pageSize: number, filter?: string, cursor?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: NsxAlbServiceEngineGroups;  }> {
        const localVarPath = this.basePath + '/1.0.0/nsxAlbResources/importableServiceEngineGroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getImportableServiceEngineGroups.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (cursor !== undefined) {
            queryParameters['cursor'] = cursor;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NsxAlbServiceEngineGroups;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NsxTResourcesApiApiKeys {
    ApiKeyAuth,
}

export class NsxTResourcesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NsxTResourcesApiApiKeys, value: string) {
        this.authentications[NsxTResourcesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get all Tier-0 routers that are accessible to an organization vDC. Routers that are already associated with an External Network are filtered out. The \"_context\" filter key must be set with the id of the NSX-T manager for which we want to get the Tier-0 routers for. 
     * @summary Get all importable Tier-0 routers that are accessible to an organization vDC.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param cursor Field used for getting next page of records. The value is supplied by the current result page. If not set, the first page is retrieved. If cursor is set, then all other pagination query parameters such as pageSize, sortDesc, sortAsc, queryFilter are ignored. 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getImportableTier0Routers (pageSize: number, filter?: string, cursor?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Tier0Routers;  }> {
        const localVarPath = this.basePath + '/1.0.0/nsxTResources/importableTier0Routers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getImportableTier0Routers.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (cursor !== undefined) {
            queryParameters['cursor'] = cursor;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Tier0Routers;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all importable overlay transport zones that are configured on an NSX-T manager. Transport zones that are already associated with a network pool are filtered out. The \"_context\" filter key must be set with the id of the NSX-T manager which we want to get the transport zones for. 
     * @summary Get all importable overlay transport zones that are configured on an NSX-T manager.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param cursor Field used for getting next page of records. The value is supplied by the current result page. If not set, the first page is retrieved. If cursor is set, then all other pagination query parameters such as pageSize, sortDesc, sortAsc, queryFilter are ignored. 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getImportableTransportZones (pageSize: number, filter?: string, cursor?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: NsxTTransportZones;  }> {
        const localVarPath = this.basePath + '/1.0.0/nsxTResources/importableTransportZones';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getImportableTransportZones.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (cursor !== undefined) {
            queryParameters['cursor'] = cursor;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NsxTTransportZones;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns all the configured NSX-T edge clusters for an Org vDC. The \"_context\" filter key must be set with the id of the NSX-T backed Org vDC for which we want to get the edge clusters <code>(_context==orgVdcId)</code>. 
     * @summary Get all edge clusters that are configured on an NSX-T manager.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param cursor Field used for getting next page of records. The value is supplied by the current result page. If not set, the first page is retrieved. If cursor is set, then all other pagination query parameters such as pageSize, sortDesc, sortAsc, queryFilter are ignored. 
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getNsxTEdgeClusters (pageSize: number, filter?: string, cursor?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: NsxTEdgeClusters;  }> {
        const localVarPath = this.basePath + '/1.0.0/nsxTResources/edgeClusters';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getNsxTEdgeClusters.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (cursor !== undefined) {
            queryParameters['cursor'] = cursor;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NsxTEdgeClusters;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NsxVResourcesApiApiKeys {
    ApiKeyAuth,
}

export class NsxVResourcesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NsxVResourcesApiApiKeys, value: string) {
        this.authentications[NsxVResourcesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get all importable transport zones that are configured on a vCenter backed by a NSX-V manager. Transport zones that are already associated with a network pool are filtered out. Only \"_context\" filter is supported and \"_context\" filter key must be set with the id of the vCenter which we want to get the transport zones for. 
     * @summary Get all importable vxlan transport zones that are configured on a vCenter backed by a NSX-V manager.
     * @param filter Filter for a query.  FIQL format.
     */
    public getImportableTransportZones (filter?: string) : Promise<{ response: http.ClientResponse; body: NsxVTransportZones;  }> {
        const localVarPath = this.basePath + '/1.0.0/nsxVResources/importableTransportZones';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NsxVTransportZones;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrgApiApiKeys {
    ApiKeyAuth,
}

export class OrgApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrgApiApiKeys, value: string) {
        this.authentications[OrgApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new organization
     * @param newOrg 
     */
    public createOrg (newOrg: Org) : Promise<{ response: http.ClientResponse; body: Org;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newOrg' is not null or undefined
        if (newOrg === null || newOrg === undefined) {
            throw new Error('Required parameter newOrg was null or undefined when calling createOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newOrg,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Org;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the specified org.
     * @param orgUrn orgUrn
     * @param force Value \&quot;true\&quot; means to forcefully delete the object that contains other objects even if those objects are in a state that does not allow removal. The default is \&quot;false\&quot;; therefore, objects are not removed if they are not in a state that normally allows removal. Force also implies recursive delete where other contained objects are removed. Errors may be ignored. Invalid value (not true or false) are ignored. 
     * @param recursive Value \&quot;true\&quot; means to remove an object that contains other objects as long as those objects are in a state that normally allows removal. The default is \&quot;false\&quot;, which means that an exception will be thrown if any of those objects are in a state that does not allow removal. Invalid value (not true or false) are ignored. 
     */
    public deleteOrg (orgUrn: string, force?: boolean, recursive?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgs/{orgUrn}'
            .replace('{' + 'orgUrn' + '}', String(orgUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgUrn' is not null or undefined
        if (orgUrn === null || orgUrn === undefined) {
            throw new Error('Required parameter orgUrn was null or undefined when calling deleteOrg.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        if (recursive !== undefined) {
            queryParameters['recursive'] = recursive;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified organization.
     * @param orgUrn orgUrn
     */
    public getOrg (orgUrn: string) : Promise<{ response: http.ClientResponse; body: Org;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgs/{orgUrn}'
            .replace('{' + 'orgUrn' + '}', String(orgUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgUrn' is not null or undefined
        if (orgUrn === null || orgUrn === undefined) {
            throw new Error('Required parameter orgUrn was null or undefined when calling getOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Org;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of all orgs accessible to the user. 
     * @summary Get list of all orgs accessible to the user.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryOrgs (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Orgs;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryOrgs.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryOrgs.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Orgs;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates an organization. 
     * @summary Updates an organization.
     * @param modifiedOrg 
     * @param orgUrn orgUrn
     */
    public updateOrg (modifiedOrg: Org, orgUrn: string) : Promise<{ response: http.ClientResponse; body: Org;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgs/{orgUrn}'
            .replace('{' + 'orgUrn' + '}', String(orgUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'modifiedOrg' is not null or undefined
        if (modifiedOrg === null || modifiedOrg === undefined) {
            throw new Error('Required parameter modifiedOrg was null or undefined when calling updateOrg.');
        }

        // verify required parameter 'orgUrn' is not null or undefined
        if (orgUrn === null || orgUrn === undefined) {
            throw new Error('Required parameter orgUrn was null or undefined when calling updateOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: modifiedOrg,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Org;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrgVdcNetworkApiApiKeys {
    ApiKeyAuth,
}

export class OrgVdcNetworkApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrgVdcNetworkApiApiKeys, value: string) {
        this.authentications[OrgVdcNetworkApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific Org vDC network.
     * @param vdcNetworkId 
     * @param force Value \&quot;true\&quot; means to forcefully delete the object that contains other objects even if those objects are in a state that does not allow removal. The default is \&quot;false\&quot;; therefore, objects are not removed if they are not in a state that normally allows removal. Force also implies recursive delete where other contained objects are removed. Errors may be ignored. Invalid value (not true or false) are ignored. 
     */
    public deleteNetwork (vdcNetworkId: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling deleteNetwork.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all the allocated IPs for a given Org vDC network. This returns all the IP addresses of network which are allocated to a vApp VM, an edge gateway interface and the addresses being used in a NAT routed environment. Results can be filtered by IP address. 
     * @summary Retrieve the list of IP addresses allocated to the network.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param vdcNetworkId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getAllocatedIpAddresses (page: number, pageSize: number, vdcNetworkId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: AllocatedIpAddresses;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}/allocatedIpAddresses'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getAllocatedIpAddresses.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getAllocatedIpAddresses.');
        }

        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling getAllocatedIpAddresses.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AllocatedIpAddresses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific Org vDC network.
     * @param vdcNetworkId 
     */
    public getOrgVdcNetwork (vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body: VdcNetwork;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling getOrgVdcNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcNetwork;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Reset a specific isolated Org vDC network.  Reset involves redeploying the internal edge gateway of the isolated Org vDC Network if present. An error is returned if the network is not isolated. 
     * @summary Reset a specific isolated Org vDC network.
     * @param vdcNetworkId 
     */
    public resetNetwork (vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}/reset'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling resetNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sync/repair the vDC Group Cross vDC network. An example usage is to realize a network in the participating vDC which was unreachable when the network was created. This operation is only allowed for VIRTUAL_WIRE backed cross vDC networks. 
     * @summary Sync/repair a specific Org vDC network.
     * @param vdcNetworkId 
     */
    public syncOrgVdcNetwork (vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}/sync'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling syncOrgVdcNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * When the IP addresses of the primary or secondary syslog server are updated, this api can synchronize syslog server settings of an Isolated Org VDC Network against the vCD Syslog Settings. An error is returned if network is a direct network. 
     * @summary Synchronize syslog server settings for a Org vDC network.
     * @param vdcNetworkId 
     */
    public syncSyslogSettingsOfNetwork (vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}/syncSyslog'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling syncSyslogSettingsOfNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific Org vDC network.
     * @param vdcNetwork 
     * @param vdcNetworkId 
     */
    public updateNetwork (vdcNetwork: VdcNetwork, vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetwork' is not null or undefined
        if (vdcNetwork === null || vdcNetwork === undefined) {
            throw new Error('Required parameter vdcNetwork was null or undefined when calling updateNetwork.');
        }

        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling updateNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vdcNetwork,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrgVdcNetworkDhcpApiApiKeys {
    ApiKeyAuth,
}

export class OrgVdcNetworkDhcpApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrgVdcNetworkDhcpApiApiKeys, value: string) {
        this.authentications[OrgVdcNetworkDhcpApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Removes Dhcp configuration on a specific Org vDC network.
     * @param vdcNetworkId 
     */
    public deleteNetworkDhcpConfig (vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}/dhcp'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling deleteNetworkDhcpConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves Dhcp configuration of a specific Org vDC network.
     * @param vdcNetworkId 
     */
    public getNetworkDhcpConfig (vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body: VdcNetworkDhcpConfig;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}/dhcp'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling getNetworkDhcpConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcNetworkDhcpConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates Dhcp configuration of a specific Org vDC network.
     * @param dhcpConfig 
     * @param vdcNetworkId 
     */
    public updateNetworkDhcpConfig (dhcpConfig: VdcNetworkDhcpConfig, vdcNetworkId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks/{vdcNetworkId}/dhcp'
            .replace('{' + 'vdcNetworkId' + '}', String(vdcNetworkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dhcpConfig' is not null or undefined
        if (dhcpConfig === null || dhcpConfig === undefined) {
            throw new Error('Required parameter dhcpConfig was null or undefined when calling updateNetworkDhcpConfig.');
        }

        // verify required parameter 'vdcNetworkId' is not null or undefined
        if (vdcNetworkId === null || vdcNetworkId === undefined) {
            throw new Error('Required parameter vdcNetworkId was null or undefined when calling updateNetworkDhcpConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dhcpConfig,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrgVdcNetworksApiApiKeys {
    ApiKeyAuth,
}

export class OrgVdcNetworksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrgVdcNetworksApiApiKeys, value: string) {
        this.authentications[OrgVdcNetworksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create an organization vDC network.
     * @param vdcNetwork 
     */
    public createNetwork (vdcNetwork: VdcNetwork) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetwork' is not null or undefined
        if (vdcNetwork === null || vdcNetwork === undefined) {
            throw new Error('Required parameter vdcNetwork was null or undefined when calling createNetwork.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vdcNetwork,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all Org vDC networks. If \"ownerRef\" property is not specified in the filter, then user must have the rights to view all the vDCs within an organization in order to see all the networks in the organization. Results can be filtered by ownerRef or combination of ownerRef and _context. <code>(_context==includeAccessible)</code> can be used to get all the networks which are available to an Org vDC. 
     * @summary Get all Org vDC networks.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getAllVdcNetworks (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VdcNetworks;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgVdcNetworks';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getAllVdcNetworks.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getAllVdcNetworks.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcNetworks;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PreferencesApiApiKeys {
    ApiKeyAuth,
}

export class PreferencesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PreferencesApiApiKeys, value: string) {
        this.authentications[PreferencesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get specified user preference.
     * @param classifier 
     */
    public getPreference (classifier: string) : Promise<{ response: http.ClientResponse; body: Preference;  }> {
        const localVarPath = this.basePath + '/1.0.0/preferences/{classifier}'
            .replace('{' + 'classifier' + '}', String(classifier));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'classifier' is not null or undefined
        if (classifier === null || classifier === undefined) {
            throw new Error('Required parameter classifier was null or undefined when calling getPreference.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Preference;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified preference definition.
     * @param preferenceDefinitionId 
     */
    public getPreferenceDefinition (preferenceDefinitionId: string) : Promise<{ response: http.ClientResponse; body: PreferenceDefinition;  }> {
        const localVarPath = this.basePath + '/1.0.0/definitions/preferences/{preferenceDefinitionId}'
            .replace('{' + 'preferenceDefinitionId' + '}', String(preferenceDefinitionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'preferenceDefinitionId' is not null or undefined
        if (preferenceDefinitionId === null || preferenceDefinitionId === undefined) {
            throw new Error('Required parameter preferenceDefinitionId was null or undefined when calling getPreferenceDefinition.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PreferenceDefinition;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of preference definitions 
     * @summary Get list of preference definitions.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryPreferenceDefinitions (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: PreferenceDefinitions;  }> {
        const localVarPath = this.basePath + '/1.0.0/definitions/preferences';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryPreferenceDefinitions.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryPreferenceDefinitions.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PreferenceDefinitions;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Query user preferences 
     * @summary Query user preferences.
     * @param filter Filter for a query.  FIQL format.
     */
    public queryPreferences (filter?: string) : Promise<{ response: http.ClientResponse; body: Preferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/preferences';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Preferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified user preference
     * @param updatePreferenceParams 
     * @param classifier 
     */
    public updatePreference (updatePreferenceParams: Preference, classifier: string) : Promise<{ response: http.ClientResponse; body: Preference;  }> {
        const localVarPath = this.basePath + '/1.0.0/preferences/{classifier}'
            .replace('{' + 'classifier' + '}', String(classifier));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatePreferenceParams' is not null or undefined
        if (updatePreferenceParams === null || updatePreferenceParams === undefined) {
            throw new Error('Required parameter updatePreferenceParams was null or undefined when calling updatePreference.');
        }

        // verify required parameter 'classifier' is not null or undefined
        if (classifier === null || classifier === undefined) {
            throw new Error('Required parameter classifier was null or undefined when calling updatePreference.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatePreferenceParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Preference;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProviderVdcApiApiKeys {
    ApiKeyAuth,
}

export class ProviderVdcApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProviderVdcApiApiKeys, value: string) {
        this.authentications[ProviderVdcApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieve a list of all provider VDCs. Results can be filtered by context (_context). Supported contexts are: DVS (_context==dvs-NN;vimServer.id==urn:vcloud:vimserver:uuid) - | Returns all the provider VDCs which are related to the DVS. The VimServer is required for this filtering. External Network (_context==urn:vcloud:network:uuid) - | Returns all the provider VDCs which are related to the external network. Network Pool (_context==urn:vcloud:networkpool:uuid) - | Returns all the provider VDCs which are accessible to the network pool. 
     * @summary Get all provider VDCs.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getAllProviderVDCs (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: ProviderVdcs;  }> {
        const localVarPath = this.basePath + '/1.0.0/providerVdcs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getAllProviderVDCs.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getAllProviderVDCs.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProviderVdcs;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of child resource pools of the specified parent. If a resource pool is ineligible, but is in the response, this means it has children, which are eligible. A resource pool will be ineligible, unless the cluster has an ESXi host on it. The list will be sorted by name, case insensitive. 
     * @summary Browse valid root resource pools hierarchy to back a Provider VDC.
     * @param pvdcUrn 
     * @param moref 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     */
    public getChildResourcePools (pvdcUrn: string, moref: string, page: number, pageSize: number) : Promise<{ response: http.ClientResponse; body: ResourcePools;  }> {
        const localVarPath = this.basePath + '/1.0.0/providerVdcs/{pvdcUrn}/infra/resourcePools/browse/{moref}'
            .replace('{' + 'pvdcUrn' + '}', String(pvdcUrn))
            .replace('{' + 'moref' + '}', String(moref));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcUrn' is not null or undefined
        if (pvdcUrn === null || pvdcUrn === undefined) {
            throw new Error('Required parameter pvdcUrn was null or undefined when calling getChildResourcePools.');
        }

        // verify required parameter 'moref' is not null or undefined
        if (moref === null || moref === undefined) {
            throw new Error('Required parameter moref was null or undefined when calling getChildResourcePools.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getChildResourcePools.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getChildResourcePools.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResourcePools;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all root resource pools. If a resource pool is ineligible, but is in the response, this means it has children, which are eligible. A resource pool will be ineligible, unless the cluster has an ESXi host on it. The list will be sorted by name, case insensitive. 
     * @summary Browse valid root resource pools hierarchy to back a Provider VDC.
     * @param pvdcUrn 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     */
    public getRootResourcePools (pvdcUrn: string, page: number, pageSize: number) : Promise<{ response: http.ClientResponse; body: ResourcePools;  }> {
        const localVarPath = this.basePath + '/1.0.0/providerVdcs/{pvdcUrn}/infra/resourcePools/browse/'
            .replace('{' + 'pvdcUrn' + '}', String(pvdcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcUrn' is not null or undefined
        if (pvdcUrn === null || pvdcUrn === undefined) {
            throw new Error('Required parameter pvdcUrn was null or undefined when calling getRootResourcePools.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getRootResourcePools.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getRootResourcePools.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResourcePools;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProxyApiApiKeys {
    ApiKeyAuth,
}

export class ProxyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProxyApiApiKeys, value: string) {
        this.authentications[ProxyApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a proxy. 
     * @summary Creates a proxy.
     * @param proxy The new proxy model.
     */
    public createProxy (proxy: Proxy) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'proxy' is not null or undefined
        if (proxy === null || proxy === undefined) {
            throw new Error('Required parameter proxy was null or undefined when calling createProxy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: proxy,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a specific proxy. Will not delete an enabled proxy unless force is specified.
     * @param id Proxy ID URN
     * @param force If true, will delete proxy regardless of proxy state.
     */
    public deleteProxy (id: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProxy.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets a paged list of proxies for a tenant. 
     * @summary Gets a paged list of proxies for a tenant.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getProxies (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Proxies;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getProxies.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getProxies.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Proxies;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the tenant-specific .pac file listing proxies accessible to the tenant. 
     * @summary Gets the tenant-specific .pac file listing proxies accessible to the tenant.
     * @param id identifier for the pac file configured for your organization
     */
    public getProxiesPacFileForTenant (id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxiesPac/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProxiesPacFileForTenant.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific proxy.
     * @param id Proxy ID URN
     */
    public getProxy (id: string) : Promise<{ response: http.ClientResponse; body: Proxy;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProxy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Proxy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a proxy certificate revocation list in PEM format.
     * @param id 
     */
    public getProxyCRL (id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies/{id}/crl'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProxyCRL.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a proxy SSL certificate chain in PEM format.
     * @param id Proxy ID URN
     */
    public getProxyCertificate (id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies/{id}/cert'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProxyCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a Proxy SSL certificate thumbprint and algorithm used for calculation.
     * @param id Proxy ID URN
     */
    public getProxyCertificateThumbprint (id: string) : Promise<{ response: http.ClientResponse; body: ThumbprintAndAlgorithm;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies/{id}/thumbprint'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProxyCertificateThumbprint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ThumbprintAndAlgorithm;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a specific proxy.
     * @param updatedProxy The updated proxy model.
     * @param id Proxy ID URN
     */
    public updateProxy (updatedProxy: Proxy, id: string) : Promise<{ response: http.ClientResponse; body: Proxy;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedProxy' is not null or undefined
        if (updatedProxy === null || updatedProxy === undefined) {
            throw new Error('Required parameter updatedProxy was null or undefined when calling updateProxy.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateProxy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedProxy,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Proxy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a proxy certificate revocation list in PEM format.
     * @param proxyCRL 
     * @param id 
     */
    public updateProxyCRL (proxyCRL: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies/{id}/crl'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'proxyCRL' is not null or undefined
        if (proxyCRL === null || proxyCRL === undefined) {
            throw new Error('Required parameter proxyCRL was null or undefined when calling updateProxyCRL.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateProxyCRL.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: proxyCRL,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a proxy certificate chain in PEM format.
     * @param proxyTrustAnchor The updated proxy certificate chain in PEM format.
     * @param id Proxy ID URN
     */
    public updateProxyCertificate (proxyTrustAnchor: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxies/{id}/cert'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'proxyTrustAnchor' is not null or undefined
        if (proxyTrustAnchor === null || proxyTrustAnchor === undefined) {
            throw new Error('Required parameter proxyTrustAnchor was null or undefined when calling updateProxyCertificate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateProxyCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: proxyTrustAnchor,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProxyConfigurationApiApiKeys {
    ApiKeyAuth,
}

export class ProxyConfigurationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProxyConfigurationApiApiKeys, value: string) {
        this.authentications[ProxyConfigurationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a proxy configuration. 
     * @summary Creates a proxy configuration.
     * @param proxyConfiguration The new proxy configuration API model.
     */
    public createProxyConfiguration (proxyConfiguration: ProxyConfiguration) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxyConfigurations';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'proxyConfiguration' is not null or undefined
        if (proxyConfiguration === null || proxyConfiguration === undefined) {
            throw new Error('Required parameter proxyConfiguration was null or undefined when calling createProxyConfiguration.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: proxyConfiguration,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a specific proxy configuration.
     * @param id Proxy Configuration ID URN
     */
    public deleteProxyConfiguration (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxyConfigurations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProxyConfiguration.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific proxy configuration.
     * @param id Proxy Configuration ID URN
     */
    public getProxyConfiguration (id: string) : Promise<{ response: http.ClientResponse; body: ProxyConfiguration;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxyConfigurations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProxyConfiguration.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProxyConfiguration;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets a paged list of proxy configurations. 
     * @summary Gets a paged list of proxy configurations.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryProxyConfigurations (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: ProxyConfigurations;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxyConfigurations';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryProxyConfigurations.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryProxyConfigurations.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProxyConfigurations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a specific proxy configuration.
     * @param updatedProxyConfiguration The updated proxy configuration API model.
     * @param id Proxy Configuration ID URN
     */
    public updateProxyConfiguration (updatedProxyConfiguration: ProxyConfiguration, id: string) : Promise<{ response: http.ClientResponse; body: ProxyConfiguration;  }> {
        const localVarPath = this.basePath + '/1.0.0/proxyConfigurations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedProxyConfiguration' is not null or undefined
        if (updatedProxyConfiguration === null || updatedProxyConfiguration === undefined) {
            throw new Error('Required parameter updatedProxyConfiguration was null or undefined when calling updateProxyConfiguration.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateProxyConfiguration.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedProxyConfiguration,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProxyConfiguration;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PvdcComputePoliciesApiApiKeys {
    ApiKeyAuth,
}

export class PvdcComputePoliciesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PvdcComputePoliciesApiApiKeys, value: string) {
        this.authentications[PvdcComputePoliciesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a new pVDC compute policy 
     * @summary Creates a new provider vDC compute policy
     * @param pvdcComputePolicy 
     */
    public createPvdcComputePolicy (pvdcComputePolicy: PvdcComputePolicy) : Promise<{ response: http.ClientResponse; body: PvdcComputePolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/pvdcComputePolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcComputePolicy' is not null or undefined
        if (pvdcComputePolicy === null || pvdcComputePolicy === undefined) {
            throw new Error('Required parameter pvdcComputePolicy was null or undefined when calling createPvdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pvdcComputePolicy,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PvdcComputePolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified provider vDC compute policy.
     * @param pvdcComputePolicyId ID of provider VDC Compute Policy
     */
    public deletePvdcComputePolicy (pvdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/pvdcComputePolicies/{pvdcComputePolicyId}'
            .replace('{' + 'pvdcComputePolicyId' + '}', String(pvdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcComputePolicyId' is not null or undefined
        if (pvdcComputePolicyId === null || pvdcComputePolicyId === undefined) {
            throw new Error('Required parameter pvdcComputePolicyId was null or undefined when calling deletePvdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified provider vDC compute policy
     * @param pvdcComputePolicyId ID of provider VDC Compute Policy
     */
    public getPvdcComputePolicy (pvdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: PvdcComputePolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/pvdcComputePolicies/{pvdcComputePolicyId}'
            .replace('{' + 'pvdcComputePolicyId' + '}', String(pvdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcComputePolicyId' is not null or undefined
        if (pvdcComputePolicyId === null || pvdcComputePolicyId === undefined) {
            throw new Error('Required parameter pvdcComputePolicyId was null or undefined when calling getPvdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PvdcComputePolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all VMs associated with this pVDC compute policy
     * @param pvdcComputePolicyId ID of provider VDC Compute Policy
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getPvdcComputePolicyVms (pvdcComputePolicyId: string, page: number, pageSize: number, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/pvdcComputePolicies/{pvdcComputePolicyId}/vms'
            .replace('{' + 'pvdcComputePolicyId' + '}', String(pvdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcComputePolicyId' is not null or undefined
        if (pvdcComputePolicyId === null || pvdcComputePolicyId === undefined) {
            throw new Error('Required parameter pvdcComputePolicyId was null or undefined when calling getPvdcComputePolicyVms.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getPvdcComputePolicyVms.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getPvdcComputePolicyVms.');
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of provider vDC compute policies. Only filtering by pvdc compute policy name is supported. 
     * @summary Get list of provider vDC compute policies.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryPvdcComputePolicies (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: PvdcComputePolicies;  }> {
        const localVarPath = this.basePath + '/1.0.0/pvdcComputePolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryPvdcComputePolicies.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryPvdcComputePolicies.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PvdcComputePolicies;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified provider vDC compute policy
     * @param pvdcComputePolicyId ID of provider VDC Compute Policy
     * @param pvdcComputePolicy 
     */
    public updatePvdcComputePolicy (pvdcComputePolicyId: string, pvdcComputePolicy: PvdcComputePolicy) : Promise<{ response: http.ClientResponse; body: PvdcComputePolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/pvdcComputePolicies/{pvdcComputePolicyId}'
            .replace('{' + 'pvdcComputePolicyId' + '}', String(pvdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcComputePolicyId' is not null or undefined
        if (pvdcComputePolicyId === null || pvdcComputePolicyId === undefined) {
            throw new Error('Required parameter pvdcComputePolicyId was null or undefined when calling updatePvdcComputePolicy.');
        }

        // verify required parameter 'pvdcComputePolicy' is not null or undefined
        if (pvdcComputePolicy === null || pvdcComputePolicy === undefined) {
            throw new Error('Required parameter pvdcComputePolicy was null or undefined when calling updatePvdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pvdcComputePolicy,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PvdcComputePolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PvdcComputePolicies2ApiApiKeys {
    ApiKeyAuth,
}

export class PvdcComputePolicies2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PvdcComputePolicies2ApiApiKeys, value: string) {
        this.authentications[PvdcComputePolicies2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a new pVDC compute policy 
     * @summary Creates a new provider vDC compute policy
     * @param pvdcComputePolicy 
     */
    public createPvdcComputePolicy (pvdcComputePolicy: PvdcComputePolicy2) : Promise<{ response: http.ClientResponse; body: PvdcComputePolicy2;  }> {
        const localVarPath = this.basePath + '/2.0.0/pvdcComputePolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcComputePolicy' is not null or undefined
        if (pvdcComputePolicy === null || pvdcComputePolicy === undefined) {
            throw new Error('Required parameter pvdcComputePolicy was null or undefined when calling createPvdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pvdcComputePolicy,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PvdcComputePolicy2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified provider vDC compute policy.
     * @param pvdcComputePolicyId ID of provider vDC Compute Policy
     */
    public deletePvdcComputePolicy (pvdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/2.0.0/pvdcComputePolicies/{pvdcComputePolicyId}'
            .replace('{' + 'pvdcComputePolicyId' + '}', String(pvdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcComputePolicyId' is not null or undefined
        if (pvdcComputePolicyId === null || pvdcComputePolicyId === undefined) {
            throw new Error('Required parameter pvdcComputePolicyId was null or undefined when calling deletePvdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified provider vDC compute policy
     * @param pvdcComputePolicyId ID of provider vDC Compute Policy
     */
    public getPvdcComputePolicy (pvdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: PvdcComputePolicy2;  }> {
        const localVarPath = this.basePath + '/2.0.0/pvdcComputePolicies/{pvdcComputePolicyId}'
            .replace('{' + 'pvdcComputePolicyId' + '}', String(pvdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcComputePolicyId' is not null or undefined
        if (pvdcComputePolicyId === null || pvdcComputePolicyId === undefined) {
            throw new Error('Required parameter pvdcComputePolicyId was null or undefined when calling getPvdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PvdcComputePolicy2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of provider vDC compute policies. Only filtering by provider vDC compute policy name is supported. 
     * @summary Get list of provider vDC compute policies.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryPvdcComputePolicies (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: PvdcComputePolicies2;  }> {
        const localVarPath = this.basePath + '/2.0.0/pvdcComputePolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryPvdcComputePolicies.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryPvdcComputePolicies.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PvdcComputePolicies2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of Virtual Machine Classes associated with this policy. Returns 400 if policy type is anything but PvdcKubernetesPolicy. 
     * @summary Get a list of Virtual Machine Classes associated with this policy.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param pvdcComputePolicyId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryVirtualMachineClasses (page: number, pageSize: number, pvdcComputePolicyId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VirtualMachineClasses;  }> {
        const localVarPath = this.basePath + '/2.0.0/pvdcComputePolicies/{pvdcComputePolicyId}/virtualMachineClasses'
            .replace('{' + 'pvdcComputePolicyId' + '}', String(pvdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryVirtualMachineClasses.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryVirtualMachineClasses.');
        }

        // verify required parameter 'pvdcComputePolicyId' is not null or undefined
        if (pvdcComputePolicyId === null || pvdcComputePolicyId === undefined) {
            throw new Error('Required parameter pvdcComputePolicyId was null or undefined when calling queryVirtualMachineClasses.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VirtualMachineClasses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified provider vDC compute policy
     * @param pvdcComputePolicyId ID of provider vDC Compute Policy
     * @param pvdcComputePolicy 
     */
    public updatePvdcComputePolicy (pvdcComputePolicyId: string, pvdcComputePolicy: PvdcComputePolicy2) : Promise<{ response: http.ClientResponse; body: PvdcComputePolicy2;  }> {
        const localVarPath = this.basePath + '/2.0.0/pvdcComputePolicies/{pvdcComputePolicyId}'
            .replace('{' + 'pvdcComputePolicyId' + '}', String(pvdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pvdcComputePolicyId' is not null or undefined
        if (pvdcComputePolicyId === null || pvdcComputePolicyId === undefined) {
            throw new Error('Required parameter pvdcComputePolicyId was null or undefined when calling updatePvdcComputePolicy.');
        }

        // verify required parameter 'pvdcComputePolicy' is not null or undefined
        if (pvdcComputePolicy === null || pvdcComputePolicy === undefined) {
            throw new Error('Required parameter pvdcComputePolicy was null or undefined when calling updatePvdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pvdcComputePolicy,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PvdcComputePolicy2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PvdcStoragePolicyApiApiKeys {
    ApiKeyAuth,
}

export class PvdcStoragePolicyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PvdcStoragePolicyApiApiKeys, value: string) {
        this.authentications[PvdcStoragePolicyApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves the settings that child Org VDC storage policies of this provider VDC storage policy should inherit. 
     * @summary Retrieves the settings that child Org VDC storage policies of this provider VDC storage policy should inherit. 
     * @param id 
     */
    public getPvdcStoragePolicyInheritableSettings (id: string) : Promise<{ response: http.ClientResponse; body: StoragePolicySettings;  }> {
        const localVarPath = this.basePath + '/1.0.0/pvdcStoragePolicies/{id}/inheritableSettings'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPvdcStoragePolicyInheritableSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoragePolicySettings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the settings that child Org VDC storage policies of this provider VDC storage policy should inherit. 
     * @summary Updates the settings that child Org VDC storage policies of this provider VDC storage policy should inherit. 
     * @param updatedSettings The updated inheritable settings.
     * @param id 
     */
    public updatePvdcStoragePolicyInheritableSettings (updatedSettings: StoragePolicySettings, id: string) : Promise<{ response: http.ClientResponse; body: StoragePolicySettings;  }> {
        const localVarPath = this.basePath + '/1.0.0/pvdcStoragePolicies/{id}/inheritableSettings'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedSettings' is not null or undefined
        if (updatedSettings === null || updatedSettings === undefined) {
            throw new Error('Required parameter updatedSettings was null or undefined when calling updatePvdcStoragePolicyInheritableSettings.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePvdcStoragePolicyInheritableSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedSettings,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StoragePolicySettings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum QuotaPoliciesApiApiKeys {
    ApiKeyAuth,
}

export class QuotaPoliciesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: QuotaPoliciesApiApiKeys, value: string) {
        this.authentications[QuotaPoliciesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a new quota policy 
     * @summary Creates a new quota policy
     * @param quotaPolicyParams 
     */
    public createQuotaPolicy (quotaPolicyParams: QuotaPolicy) : Promise<{ response: http.ClientResponse; body: QuotaPolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/quotaPolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotaPolicyParams' is not null or undefined
        if (quotaPolicyParams === null || quotaPolicyParams === undefined) {
            throw new Error('Required parameter quotaPolicyParams was null or undefined when calling createQuotaPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: quotaPolicyParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuotaPolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the specified quota policy.
     * @param quotaPolicyId 
     */
    public deleteQuotaPolicy (quotaPolicyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/quotaPolicies/{quotaPolicyId}'
            .replace('{' + 'quotaPolicyId' + '}', String(quotaPolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotaPolicyId' is not null or undefined
        if (quotaPolicyId === null || quotaPolicyId === undefined) {
            throw new Error('Required parameter quotaPolicyId was null or undefined when calling deleteQuotaPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the specified quota policy
     * @param quotaPolicyId 
     */
    public getQuotaPolicy (quotaPolicyId: string) : Promise<{ response: http.ClientResponse; body: QuotaPolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/quotaPolicies/{quotaPolicyId}'
            .replace('{' + 'quotaPolicyId' + '}', String(quotaPolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotaPolicyId' is not null or undefined
        if (quotaPolicyId === null || quotaPolicyId === undefined) {
            throw new Error('Required parameter quotaPolicyId was null or undefined when calling getQuotaPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuotaPolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of quota policies. Results can be filtered by id Returns all the quota policies which are available in the system. 
     * @summary Get list of quota policies.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryQuotaPolicies (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: QuotaPolicies;  }> {
        const localVarPath = this.basePath + '/1.0.0/quotaPolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryQuotaPolicies.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryQuotaPolicies.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuotaPolicies;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update the specified quota policy
     * @param updateQuotaPolicyParams 
     * @param quotaPolicyId 
     */
    public updateQuotaPolicy (updateQuotaPolicyParams: QuotaPolicy, quotaPolicyId: string) : Promise<{ response: http.ClientResponse; body: QuotaPolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/quotaPolicies/{quotaPolicyId}'
            .replace('{' + 'quotaPolicyId' + '}', String(quotaPolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updateQuotaPolicyParams' is not null or undefined
        if (updateQuotaPolicyParams === null || updateQuotaPolicyParams === undefined) {
            throw new Error('Required parameter updateQuotaPolicyParams was null or undefined when calling updateQuotaPolicy.');
        }

        // verify required parameter 'quotaPolicyId' is not null or undefined
        if (quotaPolicyId === null || quotaPolicyId === undefined) {
            throw new Error('Required parameter quotaPolicyId was null or undefined when calling updateQuotaPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateQuotaPolicyParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QuotaPolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum QuotaPolicyAssignmentApiApiKeys {
    ApiKeyAuth,
}

export class QuotaPolicyAssignmentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: QuotaPolicyAssignmentApiApiKeys, value: string) {
        this.authentications[QuotaPolicyAssignmentApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Assign quota policy to given target group.
     * @param quotaPolicyReference 
     * @param groupUrn 
     */
    public assignQuotaPolicyToGroup (quotaPolicyReference: AssignedQuotaPolicy, groupUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/groups/{groupUrn}/quotaPolicy'
            .replace('{' + 'groupUrn' + '}', String(groupUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotaPolicyReference' is not null or undefined
        if (quotaPolicyReference === null || quotaPolicyReference === undefined) {
            throw new Error('Required parameter quotaPolicyReference was null or undefined when calling assignQuotaPolicyToGroup.');
        }

        // verify required parameter 'groupUrn' is not null or undefined
        if (groupUrn === null || groupUrn === undefined) {
            throw new Error('Required parameter groupUrn was null or undefined when calling assignQuotaPolicyToGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: quotaPolicyReference,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign quota policy to given target organization.
     * @param quotaPolicyReference 
     * @param orgUrn 
     */
    public assignQuotaPolicyToOrg (quotaPolicyReference: AssignedQuotaPolicy, orgUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgs/{orgUrn}/quotaPolicy'
            .replace('{' + 'orgUrn' + '}', String(orgUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotaPolicyReference' is not null or undefined
        if (quotaPolicyReference === null || quotaPolicyReference === undefined) {
            throw new Error('Required parameter quotaPolicyReference was null or undefined when calling assignQuotaPolicyToOrg.');
        }

        // verify required parameter 'orgUrn' is not null or undefined
        if (orgUrn === null || orgUrn === undefined) {
            throw new Error('Required parameter orgUrn was null or undefined when calling assignQuotaPolicyToOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: quotaPolicyReference,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign quota policy to given target user.
     * @param quotaPolicyReference 
     * @param userUrn 
     */
    public assignQuotaPolicyToUser (quotaPolicyReference: AssignedQuotaPolicy, userUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/users/{userUrn}/quotaPolicy'
            .replace('{' + 'userUrn' + '}', String(userUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotaPolicyReference' is not null or undefined
        if (quotaPolicyReference === null || quotaPolicyReference === undefined) {
            throw new Error('Required parameter quotaPolicyReference was null or undefined when calling assignQuotaPolicyToUser.');
        }

        // verify required parameter 'userUrn' is not null or undefined
        if (userUrn === null || userUrn === undefined) {
            throw new Error('Required parameter userUrn was null or undefined when calling assignQuotaPolicyToUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: quotaPolicyReference,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Assign quota policy to given target vapp.
     * @param quotaPolicyReference 
     * @param vappUrn 
     */
    public assignQuotaPolicyToVApp (quotaPolicyReference: AssignedQuotaPolicy, vappUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vapps/{vappUrn}/quotaPolicy'
            .replace('{' + 'vappUrn' + '}', String(vappUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'quotaPolicyReference' is not null or undefined
        if (quotaPolicyReference === null || quotaPolicyReference === undefined) {
            throw new Error('Required parameter quotaPolicyReference was null or undefined when calling assignQuotaPolicyToVApp.');
        }

        // verify required parameter 'vappUrn' is not null or undefined
        if (vappUrn === null || vappUrn === undefined) {
            throw new Error('Required parameter vappUrn was null or undefined when calling assignQuotaPolicyToVApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: quotaPolicyReference,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the assigned quota policy reference for the given group.
     * @param groupUrn 
     */
    public getGroupAssignedQuotaPolicy (groupUrn: string) : Promise<{ response: http.ClientResponse; body: AssignedQuotaPolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/groups/{groupUrn}/quotaPolicy'
            .replace('{' + 'groupUrn' + '}', String(groupUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'groupUrn' is not null or undefined
        if (groupUrn === null || groupUrn === undefined) {
            throw new Error('Required parameter groupUrn was null or undefined when calling getGroupAssignedQuotaPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AssignedQuotaPolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the assigned quota policy reference for the given organization.
     * @param orgUrn 
     */
    public getOrgAssignedQuotaPolicy (orgUrn: string) : Promise<{ response: http.ClientResponse; body: AssignedQuotaPolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/orgs/{orgUrn}/quotaPolicy'
            .replace('{' + 'orgUrn' + '}', String(orgUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgUrn' is not null or undefined
        if (orgUrn === null || orgUrn === undefined) {
            throw new Error('Required parameter orgUrn was null or undefined when calling getOrgAssignedQuotaPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AssignedQuotaPolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the assigned quota policy reference for the given user.
     * @param userUrn 
     */
    public getUserAssignedQuotaPolicy (userUrn: string) : Promise<{ response: http.ClientResponse; body: AssignedQuotaPolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/users/{userUrn}/quotaPolicy'
            .replace('{' + 'userUrn' + '}', String(userUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userUrn' is not null or undefined
        if (userUrn === null || userUrn === undefined) {
            throw new Error('Required parameter userUrn was null or undefined when calling getUserAssignedQuotaPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AssignedQuotaPolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the assigned quota policy reference for the given vapp.
     * @param vappUrn 
     */
    public getVAppAssignedQuotaPolicy (vappUrn: string) : Promise<{ response: http.ClientResponse; body: AssignedQuotaPolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/vapps/{vappUrn}/quotaPolicy'
            .replace('{' + 'vappUrn' + '}', String(vappUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vappUrn' is not null or undefined
        if (vappUrn === null || vappUrn === undefined) {
            throw new Error('Required parameter vappUrn was null or undefined when calling getVAppAssignedQuotaPolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AssignedQuotaPolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RightsApiApiKeys {
    ApiKeyAuth,
}

export class RightsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RightsApiApiKeys, value: string) {
        this.authentications[RightsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves the requested Right by id.
     * @summary Retrieve an individual right.
     * @param id 
     */
    public getRight (id: string) : Promise<{ response: http.ClientResponse; body: Right;  }> {
        const localVarPath = this.basePath + '/1.0.0/rights/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRight.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Right;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of rights 
     * @summary Get list of rights visible to logged-in user
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryRights (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Rights;  }> {
        const localVarPath = this.basePath + '/1.0.0/rights';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryRights.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryRights.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Rights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RightsBundlesApiApiKeys {
    ApiKeyAuth,
}

export class RightsBundlesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RightsBundlesApiApiKeys, value: string) {
        this.authentications[RightsBundlesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Adds the list of rights (passed as references) to a rights bundle. 
     * @summary Adds the specified rights to a rights bundle.
     * @param rightsReferencesBody 
     * @param id 
     */
    public addRightsToRightsBundle (rightsReferencesBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}/rights'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'rightsReferencesBody' is not null or undefined
        if (rightsReferencesBody === null || rightsReferencesBody === undefined) {
            throw new Error('Required parameter rightsReferencesBody was null or undefined when calling addRightsToRightsBundle.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addRightsToRightsBundle.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rightsReferencesBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new rights bundle 
     * @summary Creates a new rights bundle
     * @param newRightsBundle 
     */
    public createRightsBundle (newRightsBundle: RightsBundle) : Promise<{ response: http.ClientResponse; body: RightsBundle;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newRightsBundle' is not null or undefined
        if (newRightsBundle === null || newRightsBundle === undefined) {
            throw new Error('Required parameter newRightsBundle was null or undefined when calling createRightsBundle.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newRightsBundle,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RightsBundle;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified rights bundle
     * @param id 
     */
    public deleteRightsBundle (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteRightsBundle.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified rights bundle
     * @param id 
     */
    public getRightsBundle (id: string) : Promise<{ response: http.ClientResponse; body: RightsBundle;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRightsBundle.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RightsBundle;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the rights bundle to the specified tenants 
     * @summary Publishes the rights bundle to the specified tenants
     * @param publishTenantsBody 
     * @param id 
     */
    public postRightsBundlePublish (publishTenantsBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}/tenants/publish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling postRightsBundlePublish.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postRightsBundlePublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the rights bundle to all tenants 
     * @summary Publishes the rights bundle to all tenants
     * @param id 
     */
    public postRightsBundlePublishAll (id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}/tenants/publishAll'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postRightsBundlePublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revokes publication of the rights bundle to the specified tenants 
     * @summary Revokes publication of the rights bundle to the specified tenants
     * @param unpublishTenantsBody 
     * @param id 
     */
    public postRightsBundleUnpublish (unpublishTenantsBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}/tenants/unpublish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'unpublishTenantsBody' is not null or undefined
        if (unpublishTenantsBody === null || unpublishTenantsBody === undefined) {
            throw new Error('Required parameter unpublishTenantsBody was null or undefined when calling postRightsBundleUnpublish.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postRightsBundleUnpublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unpublishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unpublishes the rights bundle from all tenants 
     * @summary Unpublishes the rights bundle from all tenants
     * @param id 
     */
    public postRightsBundleUnpublishAll (id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}/tenants/unpublishAll'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postRightsBundleUnpublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of rights (as references) contained by a particular bundle 
     * @summary Gets a paged list of rights (as references) contained by a particular bundle
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryRightsBundleRights (page: number, pageSize: number, id: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}/rights'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryRightsBundleRights.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryRightsBundleRights.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling queryRightsBundleRights.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves list of tenants for whom the rights bundle is explicitly published 
     * @summary Retrieves list of tenants for whom the rights bundle is explicitly published
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryRightsBundleTenants (page: number, pageSize: number, id: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}/tenants'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryRightsBundleTenants.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryRightsBundleTenants.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling queryRightsBundleTenants.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of rights bundles 
     * @summary Get list of rights bundles
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryRightsBundles (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: RightsBundles;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryRightsBundles.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryRightsBundles.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RightsBundles;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replaces the existing set of rights in bundle with the rights (as references) supplied. 
     * @summary Replaces the existing set of rights in bundle with the rights (as references) supplied.
     * @param rightsReferencesBody 
     * @param id 
     */
    public replaceRightsInRightsBundle (rightsReferencesBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}/rights'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'rightsReferencesBody' is not null or undefined
        if (rightsReferencesBody === null || rightsReferencesBody === undefined) {
            throw new Error('Required parameter rightsReferencesBody was null or undefined when calling replaceRightsInRightsBundle.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replaceRightsInRightsBundle.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rightsReferencesBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resets list of tenants for whom the rights bundle is explicitly published 
     * @summary Resets list of tenants for whom the rights bundle is explicitly published
     * @param publishTenantsBody 
     * @param id 
     */
    public setRightsBundleTenants (publishTenantsBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}/tenants'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling setRightsBundleTenants.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setRightsBundleTenants.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified rights bundle
     * @param updatedRightsBundle 
     * @param id 
     */
    public updateRightsBundle (updatedRightsBundle: RightsBundle, id: string) : Promise<{ response: http.ClientResponse; body: RightsBundle;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsBundles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedRightsBundle' is not null or undefined
        if (updatedRightsBundle === null || updatedRightsBundle === undefined) {
            throw new Error('Required parameter updatedRightsBundle was null or undefined when calling updateRightsBundle.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateRightsBundle.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedRightsBundle,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RightsBundle;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RightsCategoriesApiApiKeys {
    ApiKeyAuth,
}

export class RightsCategoriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RightsCategoriesApiApiKeys, value: string) {
        this.authentications[RightsCategoriesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves the requested Rights Category by id.
     * @summary Retrieve an individual Right category.
     * @param id 
     */
    public getRightsCategory (id: string) : Promise<{ response: http.ClientResponse; body: RightsCategoryNode;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRightsCategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RightsCategoryNode;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of Rights Categories 
     * @summary Get a list of Rights Categories visible to the logged in user
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryRightsCategories (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: RightsCategoryNodes;  }> {
        const localVarPath = this.basePath + '/1.0.0/rightsCategories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryRightsCategories.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryRightsCategories.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RightsCategoryNodes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RolesApiApiKeys {
    ApiKeyAuth,
}

export class RolesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RolesApiApiKeys, value: string) {
        this.authentications[RolesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Adds the list of rights (passed as references) to a role. 
     * @summary Adds the specified rights to a role.
     * @param rightsReferencesBody 
     * @param id 
     */
    public addRightsToRole (rightsReferencesBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/roles/{id}/rights'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'rightsReferencesBody' is not null or undefined
        if (rightsReferencesBody === null || rightsReferencesBody === undefined) {
            throw new Error('Required parameter rightsReferencesBody was null or undefined when calling addRightsToRole.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addRightsToRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rightsReferencesBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new role 
     * @summary Creates a new role
     * @param newRole 
     */
    public createRole (newRole: Role) : Promise<{ response: http.ClientResponse; body: Role;  }> {
        const localVarPath = this.basePath + '/1.0.0/roles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newRole' is not null or undefined
        if (newRole === null || newRole === undefined) {
            throw new Error('Required parameter newRole was null or undefined when calling createRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newRole,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Role;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified role
     * @param id 
     */
    public deleteRole (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/roles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified role
     * @param id 
     */
    public getRole (id: string) : Promise<{ response: http.ClientResponse; body: Role;  }> {
        const localVarPath = this.basePath + '/1.0.0/roles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Role;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of rights (as references) contained by a particular role 
     * @summary Gets a paged list of rights (as references) contained by a particular role
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryRoleRights (page: number, pageSize: number, id: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/roles/{id}/rights'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryRoleRights.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryRoleRights.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling queryRoleRights.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of roles for a tenant 
     * @summary Get list of roles for a tenant
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryTenantRoles (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Roles;  }> {
        const localVarPath = this.basePath + '/1.0.0/roles';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryTenantRoles.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryTenantRoles.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Roles;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replaces the existing set of rights in role with the rights (as references) supplied. 
     * @summary Replaces the existing set of rights in role with the rights (as references) supplied.
     * @param rightsReferencesBody 
     * @param id 
     */
    public replaceRightsInRole (rightsReferencesBody: EntityReferences, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/roles/{id}/rights'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'rightsReferencesBody' is not null or undefined
        if (rightsReferencesBody === null || rightsReferencesBody === undefined) {
            throw new Error('Required parameter rightsReferencesBody was null or undefined when calling replaceRightsInRole.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replaceRightsInRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: rightsReferencesBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified role
     * @param updatedRole 
     * @param id 
     */
    public updateRole (updatedRole: Role, id: string) : Promise<{ response: http.ClientResponse; body: Role;  }> {
        const localVarPath = this.basePath + '/1.0.0/roles/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedRole' is not null or undefined
        if (updatedRole === null || updatedRole === undefined) {
            throw new Error('Required parameter updatedRole was null or undefined when calling updateRole.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateRole.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedRole,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Role;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SddcProxyApiApiKeys {
    ApiKeyAuth,
}

export class SddcProxyApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SddcProxyApiApiKeys, value: string) {
        this.authentications[SddcProxyApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates an SDDC proxy. 
     * @summary Creates an SDDC proxy.
     * @param proxy The new SDDC proxy model.
     */
    public createSddcProxy (proxy: SddcProxy) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'proxy' is not null or undefined
        if (proxy === null || proxy === undefined) {
            throw new Error('Required parameter proxy was null or undefined when calling createSddcProxy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: proxy,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a specific SDDC proxy. Will not delete an enabled proxy unless force is specified.
     * @param id SDDC Proxy ID URN
     * @param force If true, will delete proxy regardless of proxy state.
     */
    public deleteSddcProxy (id: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSddcProxy.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets a paged list of SDDC proxies for a tenant. 
     * @summary Gets a paged list of SDDC proxies for a tenant.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getSddcProxies (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: SddcProxies;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getSddcProxies.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getSddcProxies.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SddcProxies;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the .pac file for the user's accessible proxies. 
     * @summary Gets the .pac file for the user's accessible proxies.
     */
    public getSddcProxiesPacFile () : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxiesPac';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific SDDC proxy.
     * @param id SDDC Proxy ID URN
     */
    public getSddcProxy (id: string) : Promise<{ response: http.ClientResponse; body: SddcProxy;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSddcProxy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SddcProxy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a SDDC proxy certificate revocation list in PEM format.
     * @param id 
     */
    public getSddcProxyCRL (id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies/{id}/crl'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSddcProxyCRL.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a SDDC proxy SSL certificate chain in PEM format.
     * @param id SDDC Proxy ID URN
     */
    public getSddcProxyCertificate (id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies/{id}/cert'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSddcProxyCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a SDDC Proxy SSL certificate thumbprint. The thumbprint is the SHA-1 hash of the DER encoding of the certificate.
     * @param id SDDC Proxy ID URN
     */
    public getSddcProxyCertificateThumbprint (id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies/{id}/thumbprint'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSddcProxyCertificateThumbprint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a specific SDDC proxy.
     * @param updatedSddcProxy The updated SDDC proxy model.
     * @param id SDDC Proxy ID URN
     */
    public updateSddcProxy (updatedSddcProxy: SddcProxy, id: string) : Promise<{ response: http.ClientResponse; body: SddcProxy;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedSddcProxy' is not null or undefined
        if (updatedSddcProxy === null || updatedSddcProxy === undefined) {
            throw new Error('Required parameter updatedSddcProxy was null or undefined when calling updateSddcProxy.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSddcProxy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedSddcProxy,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SddcProxy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a SDDC proxy certificate revocation list in PEM format.
     * @param proxyCRL 
     * @param id 
     */
    public updateSddcProxyCRL (proxyCRL: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies/{id}/crl'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'proxyCRL' is not null or undefined
        if (proxyCRL === null || proxyCRL === undefined) {
            throw new Error('Required parameter proxyCRL was null or undefined when calling updateSddcProxyCRL.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSddcProxyCRL.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: proxyCRL,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a SDDC proxy certificate chain in PEM format.
     * @param proxyTrustAnchor The updated SDDC proxy certificate chain in PEM format.
     * @param id SDDC Proxy ID URN
     */
    public updateSddcProxyCertificate (proxyTrustAnchor: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcProxies/{id}/cert'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'proxyTrustAnchor' is not null or undefined
        if (proxyTrustAnchor === null || proxyTrustAnchor === undefined) {
            throw new Error('Required parameter proxyTrustAnchor was null or undefined when calling updateSddcProxyCertificate.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSddcProxyCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: proxyTrustAnchor,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SddcsApiApiKeys {
    ApiKeyAuth,
}

export class SddcsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SddcsApiApiKeys, value: string) {
        this.authentications[SddcsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a Software-Defined Datacenter. 
     * @summary Create a Software-Defined Datacenter.
     * @param newSddc The new SDDC model.
     */
    public createSddc (newSddc: Sddc) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newSddc' is not null or undefined
        if (newSddc === null || newSddc === undefined) {
            throw new Error('Required parameter newSddc was null or undefined when calling createSddc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newSddc,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates an SDDC endpoint. 
     * @summary Creates an SDDC endpoint.
     * @param endpoint The new SDDC endpoint model.
     */
    public createSddcEndpoint (endpoint: SddcEndpoint) : Promise<{ response: http.ClientResponse; body: SddcEndpoint;  }> {
        const localVarPath = this.basePath + '/1.0.0/endpoints';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpoint' is not null or undefined
        if (endpoint === null || endpoint === undefined) {
            throw new Error('Required parameter endpoint was null or undefined when calling createSddcEndpoint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: endpoint,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SddcEndpoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a specific Software-Defined Datacenter. Unless force is specified, SDDC & its proxies must be disabled before they can be deleted. 
     * @param id SDDC ID URN
     * @param force If true, will delete SDDC regardless of the state of the SDDC or any of its proxies. 
     */
    public deleteSddc (id: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSddc.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a specific SDDC endpoint. Will not delete a default endpoint.
     * @param id SDDC Endpoint ID URN
     */
    public deleteSddcEndpoint (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/endpoints/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSddcEndpoint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the endpoints for the SDDC. 
     * @summary Retrieve the endpoints for the SDDC.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getEndpointsForSddc (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: SddcEndpoints;  }> {
        const localVarPath = this.basePath + '/1.0.0/endpoints';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getEndpointsForSddc.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getEndpointsForSddc.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SddcEndpoints;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the proxies for the Software-Defined Datacenter. 
     * @summary Retrieve the proxies for the Software-Defined Datacenter.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id SDDC ID URN
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getProxiesForSddc (page: number, pageSize: number, id: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}/proxies'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getProxiesForSddc.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getProxiesForSddc.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProxiesForSddc.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a specific Software-Defined Datacenter. 
     * @summary Retrieve a specific Software-Defined Datacenter.
     * @param id SDDC ID URN
     */
    public getSddc (id: string) : Promise<{ response: http.ClientResponse; body: Sddc;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSddc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Sddc;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific SDDC endpoint.
     * @param id SDDC Endpoint ID URN
     */
    public getSddcEndpoint (id: string) : Promise<{ response: http.ClientResponse; body: SddcEndpoint;  }> {
        const localVarPath = this.basePath + '/1.0.0/endpoints/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSddcEndpoint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SddcEndpoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the owner of the Software-Defined Datacenter. 
     * @summary Retrieve the owner of the Software-Defined Datacenter.
     * @param id SDDC ID URN
     */
    public getSddcOwner (id: string) : Promise<{ response: http.ClientResponse; body: EntityReference;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}/owner'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSddcOwner.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReference;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the list of Software-Defined Datacenters accessible to the user. 
     * @summary Get the list of Software-Defined Datacenters accessible to the user.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getSddcs (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Sddcs;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getSddcs.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getSddcs.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Sddcs;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the list of tenants a Software-Defined Datacenter is published to. 
     * @summary Retrieve the list of tenants a Software-Defined Datacenter is published to.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param id SDDC ID URN
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public querySddcTenants (page: number, pageSize: number, id: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}/tenants'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling querySddcTenants.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling querySddcTenants.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling querySddcTenants.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publish a Software-Defined Datacenter to the tenants. 
     * @summary Publish a Software-Defined Datacenter to the given tenants.
     * @param publishTenantsBody The list of tenant EntityReferences that a Software-Defined Datacenter should be published to.
     * @param id SDDC ID URN
     */
    public sddcPublishToTenants (publishTenantsBody: Array<EntityReference>, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}/tenants/publish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling sddcPublishToTenants.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling sddcPublishToTenants.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revoke publication of the Software-Defined Datacenter for the tenants. 
     * @summary Revoke publication of the Software-Defined Datacenter for the tenants.
     * @param unpublishTenantsBody The list of tenant EntityReferences that a Software-Defined Datacenter should be unpublished from.
     * @param id SDDC ID URN
     */
    public sddcUnpublishFromTenants (unpublishTenantsBody: Array<EntityReference>, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}/tenants/unpublish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'unpublishTenantsBody' is not null or undefined
        if (unpublishTenantsBody === null || unpublishTenantsBody === undefined) {
            throw new Error('Required parameter unpublishTenantsBody was null or undefined when calling sddcUnpublishFromTenants.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling sddcUnpublishFromTenants.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unpublishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the owner of the Software-Defined Datacenter. 
     * @summary Update the owner of the Software-Defined Datacenter.
     * @param newOwner The EntityReference to the owner of the SDDC.
     * @param id SDDC ID URN
     */
    public setSddcOwner (newOwner: EntityReference, id: string) : Promise<{ response: http.ClientResponse; body: EntityReference;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}/owner'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newOwner' is not null or undefined
        if (newOwner === null || newOwner === undefined) {
            throw new Error('Required parameter newOwner was null or undefined when calling setSddcOwner.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setSddcOwner.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newOwner,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReference;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Reset the list of tenants a Software-Defined Datacenter is published to. 
     * @summary Reset the list of tenants a Software-Defined Datacenter is published to.
     * @param publishTenantsBody The list of tenant EntityReferences that a Software-Defined Datacenter should be published to.
     * @param id SDDC ID URN
     */
    public setSddcTenants (publishTenantsBody: Array<EntityReference>, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}/tenants'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling setSddcTenants.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setSddcTenants.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a specific Software-Defined Datacenter. 
     * @summary Update a specific Software-Defined Datacenter.
     * @param updatedSddc The updated SDDC model.
     * @param id SDDC ID URN
     */
    public updateSddc (updatedSddc: Sddc, id: string) : Promise<{ response: http.ClientResponse; body: Sddc;  }> {
        const localVarPath = this.basePath + '/1.0.0/sddcs/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedSddc' is not null or undefined
        if (updatedSddc === null || updatedSddc === undefined) {
            throw new Error('Required parameter updatedSddc was null or undefined when calling updateSddc.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSddc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedSddc,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Sddc;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a specific SDDC endpoint.
     * @param updatedSddcEndpoint The updated SDDC endpoint model.
     * @param id SDDC Endpoint ID URN
     */
    public updateSddcEndpoint (updatedSddcEndpoint: SddcEndpoint, id: string) : Promise<{ response: http.ClientResponse; body: SddcEndpoint;  }> {
        const localVarPath = this.basePath + '/1.0.0/endpoints/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedSddcEndpoint' is not null or undefined
        if (updatedSddcEndpoint === null || updatedSddcEndpoint === undefined) {
            throw new Error('Required parameter updatedSddcEndpoint was null or undefined when calling updateSddcEndpoint.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSddcEndpoint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedSddcEndpoint,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SddcEndpoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServiceAppApiApiKeys {
    ApiKeyAuth,
}

export class ServiceAppApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ServiceAppApiApiKeys, value: string) {
        this.authentications[ServiceAppApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific VMware service application.
     * @param serviceAppId 
     */
    public deleteServiceApp (serviceAppId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/serviceApps/{serviceAppId}'
            .replace('{' + 'serviceAppId' + '}', String(serviceAppId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'serviceAppId' is not null or undefined
        if (serviceAppId === null || serviceAppId === undefined) {
            throw new Error('Required parameter serviceAppId was null or undefined when calling deleteServiceApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific VMware service application
     * @param serviceAppId 
     */
    public getServiceApp (serviceAppId: string) : Promise<{ response: http.ClientResponse; body: ServiceApp;  }> {
        const localVarPath = this.basePath + '/1.0.0/serviceApps/{serviceAppId}'
            .replace('{' + 'serviceAppId' + '}', String(serviceAppId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'serviceAppId' is not null or undefined
        if (serviceAppId === null || serviceAppId === undefined) {
            throw new Error('Required parameter serviceAppId was null or undefined when calling getServiceApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ServiceApp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific VMware service application.
     * @param serviceApp 
     * @param serviceAppId 
     */
    public updateServiceApp (serviceApp: ServiceApp, serviceAppId: string) : Promise<{ response: http.ClientResponse; body: ServiceApp;  }> {
        const localVarPath = this.basePath + '/1.0.0/serviceApps/{serviceAppId}'
            .replace('{' + 'serviceAppId' + '}', String(serviceAppId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'serviceApp' is not null or undefined
        if (serviceApp === null || serviceApp === undefined) {
            throw new Error('Required parameter serviceApp was null or undefined when calling updateServiceApp.');
        }

        // verify required parameter 'serviceAppId' is not null or undefined
        if (serviceAppId === null || serviceAppId === undefined) {
            throw new Error('Required parameter serviceAppId was null or undefined when calling updateServiceApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: serviceApp,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ServiceApp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServiceAppsApiApiKeys {
    ApiKeyAuth,
}

export class ServiceAppsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ServiceAppsApiApiKeys, value: string) {
        this.authentications[ServiceAppsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a VMware service app
     * @param serviceAppId 
     */
    public createServiceApp (serviceAppId: ServiceApp) : Promise<{ response: http.ClientResponse; body: ServiceApp;  }> {
        const localVarPath = this.basePath + '/1.0.0/serviceApps';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'serviceAppId' is not null or undefined
        if (serviceAppId === null || serviceAppId === undefined) {
            throw new Error('Required parameter serviceAppId was null or undefined when calling createServiceApp.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: serviceAppId,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ServiceApp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all registered VMware service applications
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryServiceApps (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: ServiceApps;  }> {
        const localVarPath = this.basePath + '/1.0.0/serviceApps';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryServiceApps.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryServiceApps.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ServiceApps;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServicesApiApiKeys {
    ApiKeyAuth,
}

export class ServicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ServicesApiApiKeys, value: string) {
        this.authentications[ServicesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a new service 
     * @summary Creates a new service
     * @param newService 
     */
    public createService (newService: Service) : Promise<{ response: http.ClientResponse; body: Service;  }> {
        const localVarPath = this.basePath + '/serviceLibrary';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newService' is not null or undefined
        if (newService === null || newService === undefined) {
            throw new Error('Required parameter newService was null or undefined when calling createService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newService,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Service;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified service
     * @param id 
     * @param recursive If true, the Service and all its service items will be deleted. If false, and there are service items in the service, delete will fail.
     */
    public deleteService (id: string, recursive?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/serviceLibrary/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteService.');
        }

        if (recursive !== undefined) {
            queryParameters['recursive'] = recursive;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes specified service item 
     * @summary Deletes specified service item
     * @param id 
     */
    public deleteServiceItem (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/serviceItem/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteServiceItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified service
     * @param id 
     */
    public getService (id: string) : Promise<{ response: http.ClientResponse; body: Service;  }> {
        const localVarPath = this.basePath + '/serviceLibrary/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Service;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the specified item
     * @param id 
     */
    public getServiceItem (id: string) : Promise<{ response: http.ClientResponse; body: ServiceItem;  }> {
        const localVarPath = this.basePath + '/serviceItem/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getServiceItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ServiceItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves list of item for whom the service item is explicitly published 
     * @summary Retrieves list of tenants for whom the service item is explicitly published
     * @param id 
     */
    public getServiceItemTenants (id: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/serviceItem/{id}/tenants'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getServiceItemTenants.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary This endpoint will not produce results. It is a placeholder to enforce code generation of VroWorkflowServiceItem
     * @param id 
     */
    public getWorkflowServiceItems (id: string) : Promise<{ response: http.ClientResponse; body: Array<VroWorkflowServiceItem>;  }> {
        const localVarPath = this.basePath + '/serviceLibrary/{id}/workflows'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getWorkflowServiceItems.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<VroWorkflowServiceItem>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add VRO remote workflows to this service
     * @param remoteWorkflows 
     * @param id 
     */
    public importVroWorkflows (remoteWorkflows: Array<VroRemoteWorkflowItem>, id: string) : Promise<{ response: http.ClientResponse; body: Array<ServiceItem>;  }> {
        const localVarPath = this.basePath + '/serviceLibrary/{id}/workflows'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'remoteWorkflows' is not null or undefined
        if (remoteWorkflows === null || remoteWorkflows === undefined) {
            throw new Error('Required parameter remoteWorkflows was null or undefined when calling importVroWorkflows.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling importVroWorkflows.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: remoteWorkflows,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ServiceItem>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the service item to the specified tenants 
     * @summary Publishes the service item to the specified tenants
     * @param publishTenantsBody 
     * @param id 
     */
    public postServiceItemPublish (publishTenantsBody: Array<EntityReference>, id: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/serviceItem/{id}/tenants/publish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling postServiceItemPublish.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postServiceItemPublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the service item to all tenants 
     * @summary Publishes the service item to all tenants
     * @param id 
     */
    public postServiceItemPublishAll (id: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/serviceItem/{id}/tenants/publishAll'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postServiceItemPublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revokes publication of the service item to the specified tenants 
     * @summary Revokes publication of the service item to the specified tenants
     * @param unpublishTenantsBody 
     * @param id 
     */
    public postServiceItemUnpublish (unpublishTenantsBody: Array<EntityReference>, id: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/serviceItem/{id}/tenants/unpublish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'unpublishTenantsBody' is not null or undefined
        if (unpublishTenantsBody === null || unpublishTenantsBody === undefined) {
            throw new Error('Required parameter unpublishTenantsBody was null or undefined when calling postServiceItemUnpublish.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postServiceItemUnpublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unpublishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unpublishes the service item from all tenants 
     * @summary Unpublishes the service item from all tenants
     * @param id 
     */
    public postServiceItemUnpublishAll (id: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/serviceItem/{id}/tenants/unpublishAll'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postServiceItemUnpublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all items across all services
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     * @param getExternalData Flag indicating whether data stored outside of vCloud Director should be included in results
     */
    public queryServiceItems (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string, getExternalData?: boolean) : Promise<{ response: http.ClientResponse; body: ServiceItems;  }> {
        const localVarPath = this.basePath + '/serviceItem';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryServiceItems.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryServiceItems.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (getExternalData !== undefined) {
            queryParameters['getExternalData'] = getExternalData;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ServiceItems;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of services 
     * @summary Get list of services
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryServices (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Services;  }> {
        const localVarPath = this.basePath + '/serviceLibrary';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryServices.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryServices.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Services;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resets list of tenants for whom the service item is explicitly published 
     * @summary Resets list of tenants for whom the service item is explicitly published
     * @param publishTenantsBody 
     * @param id 
     */
    public setServiceItemTenants (publishTenantsBody: Array<EntityReference>, id: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/serviceItem/{id}/tenants'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling setServiceItemTenants.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setServiceItemTenants.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified service
     * @param updatedService 
     * @param id 
     */
    public updateService (updatedService: Service, id: string) : Promise<{ response: http.ClientResponse; body: Service;  }> {
        const localVarPath = this.basePath + '/serviceLibrary/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedService' is not null or undefined
        if (updatedService === null || updatedService === undefined) {
            throw new Error('Required parameter updatedService was null or undefined when calling updateService.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedService,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Service;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified service item
     * @param updatedService 
     * @param id 
     */
    public updateServiceItem (updatedService: ServiceItem, id: string) : Promise<{ response: http.ClientResponse; body: ServiceItem;  }> {
        const localVarPath = this.basePath + '/serviceItem/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedService' is not null or undefined
        if (updatedService === null || updatedService === undefined) {
            throw new Error('Required parameter updatedService was null or undefined when calling updateServiceItem.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateServiceItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedService,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ServiceItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SessionsApiApiKeys {
    ApiKeyAuth,
}

export class SessionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SessionsApiApiKeys, value: string) {
        this.authentications[SessionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Gets locations accessible to this session. 
     * @summary Get locations accessible to this session.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     */
    public getAccessibleLocations (page: number, pageSize: number) : Promise<{ response: http.ClientResponse; body: AccessibleLocations;  }> {
        const localVarPath = this.basePath + '/1.0.0/sessions/{id:((?!provider|current).)*}/accessibleLocations';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getAccessibleLocations.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getAccessibleLocations.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccessibleLocations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the specified session for current user 
     * @summary Returns the specified session for current user
     * @param id 
     */
    public getCurrentSession (id: string) : Promise<{ response: http.ClientResponse; body: Session;  }> {
        const localVarPath = this.basePath + '/1.0.0/sessions/{id:((?!provider|current).)*}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCurrentSession.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Session;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the specified session for the authorization token 
     * @summary Returns the session associated with the authorization credential
     */
    public getCurrentSessionForAuthCredential () : Promise<{ response: http.ClientResponse; body: Session;  }> {
        const localVarPath = this.basePath + '/1.0.0/sessions/current';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Session;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all sessions for current user 
     * @summary List all sessions for current user
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     */
    public getCurrentSessions (page: number, pageSize: number) : Promise<{ response: http.ClientResponse; body: Sessions;  }> {
        const localVarPath = this.basePath + '/1.0.0/sessions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getCurrentSessions.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getCurrentSessions.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Sessions;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets token associated with this session. 
     * @summary Get token associated with this session.
     * @param id 
     */
    public getToken (id: string) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/1.0.0/sessions/{id:((?!provider|current).)*}/token'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Logs in a user 
     * @summary Logs in a user
     * @param authorization 
     */
    public login (authorization: string) : Promise<{ response: http.ClientResponse; body: Session;  }> {
        const localVarPath = this.basePath + '/1.0.0/sessions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling login.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Session;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Logs out the current user 
     * @summary Logs out the current user
     * @param id 
     */
    public logout (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/sessions/{id:((?!provider|current).)*}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling logout.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Logs in a user (Provider only) 
     * @summary Logs in a user (Provider only)
     * @param authorization 
     */
    public providerLogin (authorization: string) : Promise<{ response: http.ClientResponse; body: Session;  }> {
        const localVarPath = this.basePath + '/1.0.0/sessions/provider';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling providerLogin.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Session;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SslSettingsApiApiKeys {
    ApiKeyAuth,
}

export class SslSettingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SslSettingsApiApiKeys, value: string) {
        this.authentications[SslSettingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get the current VCD SSL settings 
     * @summary Get the SSL settings
     */
    public getSslSettings () : Promise<{ response: http.ClientResponse; body: SslSettings;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/settings';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SslSettings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TestConnectionApiApiKeys {
    ApiKeyAuth,
}

export class TestConnectionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestConnectionApiApiKeys, value: string) {
        this.authentications[TestConnectionApiApiKeys[key]].apiKey = value;
    }
    /**
     * Tests a connection, including SSL handshake and hostname verification. 
     * @summary Test a connection
     * @param connection 
     */
    public test (connection: Connection) : Promise<{ response: http.ClientResponse; body: TestResult;  }> {
        const localVarPath = this.basePath + '/1.0.0/testConnection';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'connection' is not null or undefined
        if (connection === null || connection === undefined) {
            throw new Error('Required parameter connection was null or undefined when calling test.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: connection,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TestResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TokenApiApiKeys {
    ApiKeyAuth,
}

export class TokenApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TokenApiApiKeys, value: string) {
        this.authentications[TokenApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a new token. Proxy tokens are tied to the current user and can be used to access the set  of proxies available to the user. 
     * @summary Creates a new token of the specified type
     * @param tokenParameters 
     */
    public createToken (tokenParameters?: TokenParameters) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/1.0.0/tokens';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tokenParameters,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a specific token. Use this to revoke the current token in case of a leak. 
     * @param id Token ID URN
     */
    public deleteToken (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/tokens/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific token
     * @param id Token ID URN
     */
    public getToken (id: string) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/1.0.0/tokens/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve tokens
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getTokens (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Tokens;  }> {
        const localVarPath = this.basePath + '/1.0.0/tokens';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getTokens.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getTokens.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Tokens;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TrustedCertificatesApiApiKeys {
    ApiKeyAuth,
}

export class TrustedCertificatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TrustedCertificatesApiApiKeys, value: string) {
        this.authentications[TrustedCertificatesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Revoke trusting specified certificate 
     * @summary Revoke trusting specified certificate
     * @param trustedCertificate 
     */
    public deleteCertificate (trustedCertificate: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/trustedCertificates/{trustedCertificate}'
            .replace('{' + 'trustedCertificate' + '}', String(trustedCertificate));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'trustedCertificate' is not null or undefined
        if (trustedCertificate === null || trustedCertificate === undefined) {
            throw new Error('Required parameter trustedCertificate was null or undefined when calling deleteCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the PEM-encoded certificate with the requested URN 
     * @summary Get specified certificate
     * @param trustedCertificate 
     */
    public getCertificate (trustedCertificate: string) : Promise<{ response: http.ClientResponse; body: TrustedCertificate;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/trustedCertificates/{trustedCertificate}'
            .replace('{' + 'trustedCertificate' + '}', String(trustedCertificate));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'trustedCertificate' is not null or undefined
        if (trustedCertificate === null || trustedCertificate === undefined) {
            throw new Error('Required parameter trustedCertificate was null or undefined when calling getCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TrustedCertificate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get currently trusted certificates 
     * @summary Get currently trusted certificates
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryTrustedCertificates (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: Certificates;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/trustedCertificates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryTrustedCertificates.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryTrustedCertificates.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Certificates;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add to list of currently trusted certificates 
     * @summary Add to list of currently trusted certificates
     * @param newCertificate 
     */
    public trustCertificate (newCertificate: TrustedCertificate) : Promise<{ response: http.ClientResponse; body: TrustedCertificate;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/trustedCertificates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newCertificate' is not null or undefined
        if (newCertificate === null || newCertificate === undefined) {
            throw new Error('Required parameter newCertificate was null or undefined when calling trustCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newCertificate,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TrustedCertificate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates an existing trusted certificate 
     * @summary Updates an existing trusted certificate
     * @param modifiedCertificate 
     * @param trustedCertificate 
     */
    public updateCertificate (modifiedCertificate: TrustedCertificate, trustedCertificate: string) : Promise<{ response: http.ClientResponse; body: TrustedCertificate;  }> {
        const localVarPath = this.basePath + '/1.0.0/ssl/trustedCertificates/{trustedCertificate}'
            .replace('{' + 'trustedCertificate' + '}', String(trustedCertificate));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'modifiedCertificate' is not null or undefined
        if (modifiedCertificate === null || modifiedCertificate === undefined) {
            throw new Error('Required parameter modifiedCertificate was null or undefined when calling updateCertificate.');
        }

        // verify required parameter 'trustedCertificate' is not null or undefined
        if (trustedCertificate === null || trustedCertificate === undefined) {
            throw new Error('Required parameter trustedCertificate was null or undefined when calling updateCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: modifiedCertificate,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TrustedCertificate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UiPluginApiApiKeys {
    ApiKeyAuth,
}

export class UiPluginApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UiPluginApiApiKeys, value: string) {
        this.authentications[UiPluginApiApiKeys[key]].apiKey = value;
    }
    /**
     * Delete the system level logo, forcing the get method to return the vCloud Director default logo. 
     * @summary Delete system level logo
     * @param id 
     */
    public deleteUiPlugin (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteUiPlugin.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a map of extension Points and an ordered list of items registered with that extension point
     * @summary Retrieves a map of extension Points and an ordered list of items registered with that extension point
     */
    public getExtensionPointSummary () : Promise<{ response: http.ClientResponse; body: ExtensionPointSummary;  }> {
        const localVarPath = this.basePath + '/extensions/ui/extensionPoints';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExtensionPointSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the plugin metadata for this extension 
     * @summary Retrieves extension specific plugin metadata
     * @param id 
     */
    public getUiPlugin (id: string) : Promise<{ response: http.ClientResponse; body: UiPluginMetadataResponse;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUiPlugin.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiPluginMetadataResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Customizes the order and enables/disables extension Points 
     * @summary Customizes the order and enables/disables extension Points
     * @param extensionPointSummaryBody 
     */
    public putExtensionPointSummary (extensionPointSummaryBody: ExtensionPointSummary) : Promise<{ response: http.ClientResponse; body: ExtensionPointSummary;  }> {
        const localVarPath = this.basePath + '/extensions/ui/extensionPoints';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'extensionPointSummaryBody' is not null or undefined
        if (extensionPointSummaryBody === null || extensionPointSummaryBody === undefined) {
            throw new Error('Required parameter extensionPointSummaryBody was null or undefined when calling putExtensionPointSummary.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: extensionPointSummaryBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExtensionPointSummary;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the plugin metadata for this extension clobbering existing information and returns the updated plugin metadata 
     * @summary Updates extension specific plugin's metadata
     * @param pluginMetadataBody 
     * @param id 
     */
    public putUiPlugin (pluginMetadataBody: UiPluginMetadata, id: string) : Promise<{ response: http.ClientResponse; body: UiPluginMetadataResponse;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pluginMetadataBody' is not null or undefined
        if (pluginMetadataBody === null || pluginMetadataBody === undefined) {
            throw new Error('Required parameter pluginMetadataBody was null or undefined when calling putUiPlugin.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling putUiPlugin.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pluginMetadataBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiPluginMetadataResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UiPluginResourceApiApiKeys {
    ApiKeyAuth,
}

export class UiPluginResourceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UiPluginResourceApiApiKeys, value: string) {
        this.authentications[UiPluginResourceApiApiKeys[key]].apiKey = value;
    }
    /**
     * Deletes the actual plugin for this extension 
     * @summary Delete the plugin for this extension
     * @param id 
     */
    public deleteUiPluginResource (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}/plugin'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteUiPluginResource.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Initiates an upload for the plugin for this extension using the Transfer service A unique transfer service URL is returned where the plugin may be uploaded. 
     * @summary Upload the plugin for this extension
     * @param pluginUploadSpec 
     * @param id 
     */
    public uploadUiPluginResource (pluginUploadSpec: UploadSpec, id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}/plugin'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'pluginUploadSpec' is not null or undefined
        if (pluginUploadSpec === null || pluginUploadSpec === undefined) {
            throw new Error('Required parameter pluginUploadSpec was null or undefined when calling uploadUiPluginResource.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling uploadUiPluginResource.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pluginUploadSpec,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UiPluginTenantsApiApiKeys {
    ApiKeyAuth,
}

export class UiPluginTenantsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UiPluginTenantsApiApiKeys, value: string) {
        this.authentications[UiPluginTenantsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves list of tenants for whom the plugin is explicitly published 
     * @summary Retrieves list of tenants for whom the plugin is explicitly published
     * @param id 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getUiPluginTenants (id: string, page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}/tenants'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUiPluginTenants.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getUiPluginTenants.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getUiPluginTenants.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the UI plugin to the specified tenants 
     * @summary Publishes the UI plugin to the specified tenants
     * @param publishTenantsBody 
     * @param id 
     */
    public postUiPluginPublish (publishTenantsBody: Array<EntityReference>, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}/tenants/publish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'publishTenantsBody' is not null or undefined
        if (publishTenantsBody === null || publishTenantsBody === undefined) {
            throw new Error('Required parameter publishTenantsBody was null or undefined when calling postUiPluginPublish.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postUiPluginPublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: publishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publishes the UI plugin to all tenants 
     * @summary Publishes the UI plugin to all tenants
     * @param id 
     */
    public postUiPluginPublishAll (id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}/tenants/publishAll'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postUiPluginPublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revokes publication of the UI plugin to the specified tenants 
     * @summary Revokes publication of the UI plugin to the specified tenants
     * @param unpublishTenantsBody 
     * @param id 
     */
    public postUiPluginUnpublish (unpublishTenantsBody: Array<EntityReference>, id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}/tenants/unpublish'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'unpublishTenantsBody' is not null or undefined
        if (unpublishTenantsBody === null || unpublishTenantsBody === undefined) {
            throw new Error('Required parameter unpublishTenantsBody was null or undefined when calling postUiPluginUnpublish.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postUiPluginUnpublish.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unpublishTenantsBody,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unpublishes the UI plugin from all tenants 
     * @summary Unpublishes the UI plugin from all tenants
     * @param id 
     */
    public postUiPluginUnpublishAll (id: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/extensions/ui/{id}/tenants/unpublishAll'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postUiPluginUnpublishAll.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UiPluginsApiApiKeys {
    ApiKeyAuth,
}

export class UiPluginsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UiPluginsApiApiKeys, value: string) {
        this.authentications[UiPluginsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Creates a new UI extension and sets the provided plugin metadata for it. 
     * @summary Adds plugin metadata for a new UI Extension
     * @param body 
     */
    public addUiPlugin (body: UiPluginMetadata) : Promise<{ response: http.ClientResponse; body: UiPluginMetadataResponse;  }> {
        const localVarPath = this.basePath + '/extensions/ui';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addUiPlugin.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UiPluginMetadataResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all UI Extensions
     */
    public getUiPlugins () : Promise<{ response: http.ClientResponse; body: Array<UiPluginMetadataResponse>;  }> {
        const localVarPath = this.basePath + '/extensions/ui';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<UiPluginMetadataResponse>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UniversalRouterApiApiKeys {
    ApiKeyAuth,
}

export class UniversalRouterApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UniversalRouterApiApiKeys, value: string) {
        this.authentications[UniversalRouterApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a specific Universal Router
     * @param universalRouterId 
     * @param force Value \&quot;true\&quot; means to forcefully delete the object that contains other objects even if those objects are in a state that does not allow removal. The default is \&quot;false\&quot;; therefore, objects are not removed if they are not in a state that normally allows removal. Force also implies recursive delete where other contained objects are removed. Errors may be ignored. Invalid value (not true or false) are ignored. 
     */
    public deleteUniversalRouter (universalRouterId: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling deleteUniversalRouter.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific Universal Router
     * @param universalRouterId 
     */
    public getUniversalRouter (universalRouterId: string) : Promise<{ response: http.ClientResponse; body: UniversalRouter;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling getUniversalRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UniversalRouter;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sync/repair the Universal Router 
     * @summary Sync/repair the Universal Router
     * @param universalRouterId 
     */
    public syncUniversalRouter (universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/sync'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling syncUniversalRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific Universal Router
     * @param router 
     * @param universalRouterId 
     */
    public updateUniversalRouter (router: UniversalRouter, universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'router' is not null or undefined
        if (router === null || router === undefined) {
            throw new Error('Required parameter router was null or undefined when calling updateUniversalRouter.');
        }

        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling updateUniversalRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: router,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UniversalRouterDhcpApiApiKeys {
    ApiKeyAuth,
}

export class UniversalRouterDhcpApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UniversalRouterDhcpApiApiKeys, value: string) {
        this.authentications[UniversalRouterDhcpApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes Dhcp configuration of a specific Universal Router
     * @param universalRouterId 
     */
    public deleteDhcpConfigForUniversalRouter (universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/dhcp'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling deleteDhcpConfigForUniversalRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves Dhcp configuration of a specific Universal Router
     * @param universalRouterId 
     */
    public getDhcpConfigForUniversalRouter (universalRouterId: string) : Promise<{ response: http.ClientResponse; body: UniversalRouterDhcpConfig;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/dhcp'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling getDhcpConfigForUniversalRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UniversalRouterDhcpConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates Dhcp configuration for a specific Universal Router
     * @param dhcpConfig 
     * @param universalRouterId 
     */
    public updateDhcpConfigForUniversalRouter (dhcpConfig: UniversalRouterDhcpConfig, universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/dhcp'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dhcpConfig' is not null or undefined
        if (dhcpConfig === null || dhcpConfig === undefined) {
            throw new Error('Required parameter dhcpConfig was null or undefined when calling updateDhcpConfigForUniversalRouter.');
        }

        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling updateDhcpConfigForUniversalRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dhcpConfig,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UniversalRouterDnsApiApiKeys {
    ApiKeyAuth,
}

export class UniversalRouterDnsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UniversalRouterDnsApiApiKeys, value: string) {
        this.authentications[UniversalRouterDnsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes dns configuration of a universal router
     * @param universalRouterId 
     */
    public deleteDnsConfigForRouter (universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/dns'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling deleteDnsConfigForRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves dns configuration of a universal router
     * @param universalRouterId 
     */
    public getDnsConfigForRouter (universalRouterId: string) : Promise<{ response: http.ClientResponse; body: RouterDnsConfig;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/dns'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling getDnsConfigForRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouterDnsConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates dns configuration of a universal Router
     * @param dnsConfig 
     * @param universalRouterId 
     */
    public updateDnsConfigForRouter (dnsConfig: RouterDnsConfig, universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/dns'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'dnsConfig' is not null or undefined
        if (dnsConfig === null || dnsConfig === undefined) {
            throw new Error('Required parameter dnsConfig was null or undefined when calling updateDnsConfigForRouter.');
        }

        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling updateDnsConfigForRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: dnsConfig,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UniversalRouterHealthApiApiKeys {
    ApiKeyAuth,
}

export class UniversalRouterHealthApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UniversalRouterHealthApiApiKeys, value: string) {
        this.authentications[UniversalRouterHealthApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get Health information of a universal router and its associated entities such as egress points and routing. It includes information about reachability status of all the participating vDC's of referenced vDC group and it also includes information about all the nsx managers covered by this universal router along with associated nsx controller cluster. 
     * @summary Get Health information of a universal router
     * @param universalRouterId 
     */
    public getUniversalRouterHealth (universalRouterId: string) : Promise<{ response: http.ClientResponse; body: RouterHealthReport;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/health'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling getUniversalRouterHealth.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouterHealthReport;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UniversalRoutersApiApiKeys {
    ApiKeyAuth,
}

export class UniversalRoutersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UniversalRoutersApiApiKeys, value: string) {
        this.authentications[UniversalRoutersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new universal router for a vDC group 
     * @summary Create a new universal router
     * @param universalRouter 
     */
    public createUniversalRouter (universalRouter: UniversalRouter) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouter' is not null or undefined
        if (universalRouter === null || universalRouter === undefined) {
            throw new Error('Required parameter universalRouter was null or undefined when calling createUniversalRouter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: universalRouter,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all the universal routers defined for a vDC group in the system. 
     * @summary Get all the universal routers defined for a vDC group
     * @param vdcGroupId 
     */
    public getAllUniversalRoutersForVdcGroup (vdcGroupId: string) : Promise<{ response: http.ClientResponse; body: UniversalRouters;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/universalRouters'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling getAllUniversalRoutersForVdcGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UniversalRouters;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UniversalRoutingApiApiKeys {
    ApiKeyAuth,
}

export class UniversalRoutingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UniversalRoutingApiApiKeys, value: string) {
        this.authentications[UniversalRoutingApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves Universal Egress Points and routing configuration for a Universal Router.
     * @param universalRouterId 
     */
    public getUniversalEgressRouting (universalRouterId: string) : Promise<{ response: http.ClientResponse; body: UniversalEgressRoutes;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling getUniversalEgressRouting.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UniversalEgressRoutes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves routing configuration for a Universal Router.
     * @param universalRouterId 
     */
    public getUniversalRoutes (universalRouterId: string) : Promise<{ response: http.ClientResponse; body: UniversalRoutes;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing/routes'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling getUniversalRoutes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UniversalRoutes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sync/repair the universal routes 
     * @summary Sync/repair the routing configuration for a Universal Router.
     * @param universalRouterId 
     */
    public syncUniversalRoutes (universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing/routes/sync'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling syncUniversalRoutes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the routing configuration using the specified egress points in the universal routes. Any egress point that does not exist will be created before updating routing. Any egress point that currently exists and is not in use by any of the specified routes will be deleted. If the new egress points for routing fail to create, routing will not be updated. 
     * @param universalEgressRoutes 
     * @param universalRouterId 
     */
    public updateUniversalEgressRouting (universalEgressRoutes: UniversalEgressRoutes, universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'universalEgressRoutes' is not null or undefined
        if (universalEgressRoutes === null || universalEgressRoutes === undefined) {
            throw new Error('Required parameter universalEgressRoutes was null or undefined when calling updateUniversalEgressRouting.');
        }

        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling updateUniversalEgressRouting.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: universalEgressRoutes,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates routing configuration for a Universal Router.
     * @param routes 
     * @param universalRouterId 
     */
    public updateUniversalRoutes (routes: UniversalRoutes, universalRouterId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/universalRouters/{universalRouterId}/routing/routes'
            .replace('{' + 'universalRouterId' + '}', String(universalRouterId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'routes' is not null or undefined
        if (routes === null || routes === undefined) {
            throw new Error('Required parameter routes was null or undefined when calling updateUniversalRoutes.');
        }

        // verify required parameter 'universalRouterId' is not null or undefined
        if (universalRouterId === null || universalRouterId === undefined) {
            throw new Error('Required parameter universalRouterId was null or undefined when calling updateUniversalRoutes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: routes,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
    ApiKeyAuth,
}

export class UserApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        this.authentications[UserApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new user.
     * @param newUser 
     */
    public createUser (newUser: VcdUser) : Promise<{ response: http.ClientResponse; body: VcdUser;  }> {
        const localVarPath = this.basePath + '/1.0.0/users';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newUser' is not null or undefined
        if (newUser === null || newUser === undefined) {
            throw new Error('Required parameter newUser was null or undefined when calling createUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newUser,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VcdUser;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the specified user.
     * @param userUrn userUrn
     */
    public deleteUser (userUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/users/{userUrn}'
            .replace('{' + 'userUrn' + '}', String(userUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userUrn' is not null or undefined
        if (userUrn === null || userUrn === undefined) {
            throw new Error('Required parameter userUrn was null or undefined when calling deleteUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a specified user by id. 
     * @summary Get a specified user by id.
     * @param userUrn userUrn
     */
    public getUser (userUrn: string) : Promise<{ response: http.ClientResponse; body: VcdUser;  }> {
        const localVarPath = this.basePath + '/1.0.0/users/{userUrn}'
            .replace('{' + 'userUrn' + '}', String(userUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userUrn' is not null or undefined
        if (userUrn === null || userUrn === undefined) {
            throw new Error('Required parameter userUrn was null or undefined when calling getUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VcdUser;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of references of groups that the user with the given id belongs to. 
     * @summary Get a list of groups that the user with the given id belongs to.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param userUrn userUrn
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryUserGroups (page: number, pageSize: number, userUrn: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/users/{userUrn}/groups'
            .replace('{' + 'userUrn' + '}', String(userUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryUserGroups.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryUserGroups.');
        }

        // verify required parameter 'userUrn' is not null or undefined
        if (userUrn === null || userUrn === undefined) {
            throw new Error('Required parameter userUrn was null or undefined when calling queryUserGroups.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of users. 
     * @summary Get a list of users.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryUsers (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VcdUsers;  }> {
        const localVarPath = this.basePath + '/1.0.0/users';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryUsers.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryUsers.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VcdUsers;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modify basic details of the specified user. 
     * @summary Modify the details of a user. A non-administrator user may only modify their own password. An administrator can edit any user.
     * @param updatedUser 
     * @param userUrn userUrn
     */
    public updateUser (updatedUser: VcdUser, userUrn: string) : Promise<{ response: http.ClientResponse; body: VcdUser;  }> {
        const localVarPath = this.basePath + '/1.0.0/users/{userUrn}'
            .replace('{' + 'userUrn' + '}', String(userUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updatedUser' is not null or undefined
        if (updatedUser === null || updatedUser === undefined) {
            throw new Error('Required parameter updatedUser was null or undefined when calling updateUser.');
        }

        // verify required parameter 'userUrn' is not null or undefined
        if (userUrn === null || userUrn === undefined) {
            throw new Error('Required parameter userUrn was null or undefined when calling updateUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updatedUser,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VcdUser;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VCenterResourcesApiApiKeys {
    ApiKeyAuth,
}

export class VCenterResourcesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VCenterResourcesApiApiKeys, value: string) {
        this.authentications[VCenterResourcesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves all distributed virtual switches.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getDvSwitches (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: DvSwitches;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/resources/dvSwitches';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getDvSwitches.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getDvSwitches.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DvSwitches;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all DVPG network backings that are available. The \"_context\" filter key is optional and can be set with the id of the vCenter from which to obtain the DVPG network backings. 
     * @summary Get all DVPG network backings that are available.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getImportableDvpgs (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: DistributedPortGroups;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/resources/importableDvpgs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getImportableDvpgs.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getImportableDvpgs.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DistributedPortGroups;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all standard portgroups that are available as backings. The \"_context\" filter key is optional and can be set with the id of the vCenter from which to obtain the standard porgroup backings. 
     * @summary Get all standard porgroups available as backings.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getImportablePortgroups (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: PortGroups;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/resources/importablePortgroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getImportablePortgroups.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getImportablePortgroups.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortGroups;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VRealizeOrchestratorApiApiKeys {
    ApiKeyAuth,
}

export class VRealizeOrchestratorApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VRealizeOrchestratorApiApiKeys, value: string) {
        this.authentications[VRealizeOrchestratorApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves service specific metadata for a vRealize Orchestrator
     * @param id 
     */
    public getRegisteredVRO (id: string) : Promise<{ response: http.ClientResponse; body: VROServiceInfo;  }> {
        const localVarPath = this.basePath + '/vro/servers/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRegisteredVRO.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VROServiceInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates service specific metadata for a vRealize Orchestrator
     * @param body 
     * @param id 
     */
    public patchService (body: VROServiceInfo, id: string) : Promise<{ response: http.ClientResponse; body: VROServiceInfo;  }> {
        const localVarPath = this.basePath + '/vro/servers/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchService.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling patchService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VROServiceInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unregisters a vRealize Orchestrator endpoint from vCloud Director
     * @param id 
     */
    public unregister (id: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/vro/servers/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling unregister.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates service specific metadata for a vRealize Orchestrator
     * @param body 
     * @param id 
     */
    public updateService (body: VROServiceInfo, id: string) : Promise<{ response: http.ClientResponse; body: VROServiceInfo;  }> {
        const localVarPath = this.basePath + '/vro/servers/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateService.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateService.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VROServiceInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VRealizeOrchestratorsApiApiKeys {
    ApiKeyAuth,
}

export class VRealizeOrchestratorsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VRealizeOrchestratorsApiApiKeys, value: string) {
        this.authentications[VRealizeOrchestratorsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Discover vCenter to work with the provided vRealize Orchestrator service
     * @param body 
     */
    public discoverVroVcenter (body: VROServiceInfo) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/vro/servers/discovery';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling discoverVroVcenter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of registered vRealize Orchestrator services
     */
    public getRegisteredVROs () : Promise<{ response: http.ClientResponse; body: Array<VROServiceInfo>;  }> {
        const localVarPath = this.basePath + '/vro/servers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<VROServiceInfo>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Register a vRealize Orchestrator endpoint with vCloud Director
     * @param body 
     */
    public register (body: VROServiceInfo) : Promise<{ response: http.ClientResponse; body: VROServiceInfo;  }> {
        const localVarPath = this.basePath + '/vro/servers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling register.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VROServiceInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VdcApiApiKeys {
    ApiKeyAuth,
}

export class VdcApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VdcApiApiKeys, value: string) {
        this.authentications[VdcApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves all compute policies of a vDC 
     * @summary Retrieves all compute policies of a vDC
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param orgVdcId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getComputePolicies (page: number, pageSize: number, orgVdcId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicies;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcs/{orgVdcId}/computePolicies'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getComputePolicies.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getComputePolicies.');
        }

        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling getComputePolicies.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicies;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific vDC via URN.
     * @param orgVdcId 
     */
    public getVdc (orgVdcId: string) : Promise<{ response: http.ClientResponse; body: OrgVdc;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcs/{orgVdcId}'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling getVdc.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrgVdc;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves Max Compute Policy of the vDC. 
     * @summary Retrieves Max Compute Policy of the vDC.
     * @param orgVdcId 
     */
    public getVdcMaxComputePolicy (orgVdcId: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcs/{orgVdcId}/maxComputePolicy'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling getVdcMaxComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a list of Org-scoped (if applicable) vDCs. Results can be filtered by id, name, allocationType, and computePolicyType.  Supported filters for computePolicyType are:   (computePolicyType==VdcKubernetesPolicy) - |     Returns a list of all vDCs that have a VdcKubernetesPolicy compute policy. 
     * @summary Retrieves a list of vDCs
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryVdcs (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: OrgVdcs;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryVdcs.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryVdcs.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrgVdcs;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates Max Compute Policy of the vDC. 
     * @summary Updates Max Compute Policy of the vDC.
     * @param newVdcComputePolicyParams 
     * @param orgVdcId 
     */
    public updateVdcMaxComputePolicy (newVdcComputePolicyParams: VdcComputePolicy, orgVdcId: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcs/{orgVdcId}/maxComputePolicy'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newVdcComputePolicyParams' is not null or undefined
        if (newVdcComputePolicyParams === null || newVdcComputePolicyParams === undefined) {
            throw new Error('Required parameter newVdcComputePolicyParams was null or undefined when calling updateVdcMaxComputePolicy.');
        }

        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling updateVdcMaxComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newVdcComputePolicyParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum Vdc2ApiApiKeys {
    ApiKeyAuth,
}

export class Vdc2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: Vdc2ApiApiKeys, value: string) {
        this.authentications[Vdc2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves all compute policies of a vDC 
     * @summary Retrieves all compute policies of a vDC
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param orgVdcId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getComputePolicies (page: number, pageSize: number, orgVdcId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicies2;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcs/{orgVdcId}/computePolicies'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getComputePolicies.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getComputePolicies.');
        }

        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling getComputePolicies.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicies2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves Max Compute Policy of the vDC. 
     * @summary Retrieves Max Compute Policy of the vDC.
     * @param orgVdcId 
     */
    public getVdcMaxComputePolicy (orgVdcId: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcs/{orgVdcId}/maxComputePolicy'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling getVdcMaxComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates Max Compute Policy of the vDC. Returns 400 if policy type is not VdcVmPolicy. 
     * @summary Updates Max Compute Policy of the vDC.
     * @param newVdcComputePolicy2Params 
     * @param orgVdcId 
     */
    public updateVdcMaxComputePolicy (newVdcComputePolicy2Params: VdcComputePolicy2, orgVdcId: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcs/{orgVdcId}/maxComputePolicy'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newVdcComputePolicy2Params' is not null or undefined
        if (newVdcComputePolicy2Params === null || newVdcComputePolicy2Params === undefined) {
            throw new Error('Required parameter newVdcComputePolicy2Params was null or undefined when calling updateVdcMaxComputePolicy.');
        }

        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling updateVdcMaxComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newVdcComputePolicy2Params,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VdcComputePoliciesApiApiKeys {
    ApiKeyAuth,
}

export class VdcComputePoliciesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VdcComputePoliciesApiApiKeys, value: string) {
        this.authentications[VdcComputePoliciesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Assign this organization vDC compute policy to list of vDCs.
     * @param vdcRefs 
     * @param vdcComputePolicyId 
     */
    public addVdcComputePolicyToVdcs (vdcRefs: Array<EntityReference>, vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcComputePolicies/{vdcComputePolicyId}/vdcs'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcRefs' is not null or undefined
        if (vdcRefs === null || vdcRefs === undefined) {
            throw new Error('Required parameter vdcRefs was null or undefined when calling addVdcComputePolicyToVdcs.');
        }

        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling addVdcComputePolicyToVdcs.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vdcRefs,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new vDC compute policy 
     * @summary Creates a new organization vDC compute policy
     * @param newVdcComputePolicyParams 
     */
    public createVdcComputePolicy (newVdcComputePolicyParams: VdcComputePolicy) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcComputePolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newVdcComputePolicyParams' is not null or undefined
        if (newVdcComputePolicyParams === null || newVdcComputePolicyParams === undefined) {
            throw new Error('Required parameter newVdcComputePolicyParams was null or undefined when calling createVdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newVdcComputePolicyParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specified organization vDC compute policy.
     * @param vdcComputePolicyId 
     */
    public deleteVdcComputePolicy (vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcComputePolicies/{vdcComputePolicyId}'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling deleteVdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified organization vDC compute policy
     * @param vdcComputePolicyId 
     */
    public getVdcComputePolicy (vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcComputePolicies/{vdcComputePolicyId}'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling getVdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get organization vDCs associated with this vDC compute policy
     * @param vdcComputePolicyId 
     */
    public getVdcComputePolicyVdcs (vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcComputePolicies/{vdcComputePolicyId}/vdcs'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling getVdcComputePolicyVdcs.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all VMs associated with this vDC compute policy
     * @param vdcComputePolicyId 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getVdcComputePolicyVms (vdcComputePolicyId: string, page: number, pageSize: number, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: EntityReferences;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcComputePolicies/{vdcComputePolicyId}/vms'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling getVdcComputePolicyVms.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getVdcComputePolicyVms.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getVdcComputePolicyVms.');
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EntityReferences;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of organization vDC compute policy. Results can be filtered by id, pvdcId, isSizingOnly and _context. Supported contexts are: Org vDC Urn ID (_context==orgVdcUrn) - | Returns all the vDC compute policies which are available to a specific Org vDC. 
     * @summary Get list of organization vDC compute policies.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryVdcComputePolicies (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicies;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcComputePolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryVdcComputePolicies.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryVdcComputePolicies.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicies;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update specified organization vDC compute policy
     * @param updateVdcComputePolicyParams 
     * @param vdcComputePolicyId 
     */
    public updateVdcComputePolicy (updateVdcComputePolicyParams: VdcComputePolicy, vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcComputePolicies/{vdcComputePolicyId}'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updateVdcComputePolicyParams' is not null or undefined
        if (updateVdcComputePolicyParams === null || updateVdcComputePolicyParams === undefined) {
            throw new Error('Required parameter updateVdcComputePolicyParams was null or undefined when calling updateVdcComputePolicy.');
        }

        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling updateVdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateVdcComputePolicyParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VdcComputePolicies2ApiApiKeys {
    ApiKeyAuth,
}

export class VdcComputePolicies2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VdcComputePolicies2ApiApiKeys, value: string) {
        this.authentications[VdcComputePolicies2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Assign this organization VDC compute policy to list of VDCs.
     * @param vdcRefs 
     * @param vdcComputePolicyId 
     */
    public addVdcComputePolicyToVdcs (vdcRefs: Array<EntityReference>, vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcComputePolicies/{vdcComputePolicyId}/vdcs'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcRefs' is not null or undefined
        if (vdcRefs === null || vdcRefs === undefined) {
            throw new Error('Required parameter vdcRefs was null or undefined when calling addVdcComputePolicyToVdcs.');
        }

        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling addVdcComputePolicyToVdcs.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vdcRefs,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new VDC compute policy. if PolicyType is VdcKubernetesPolicy, then the response is a 202 with task URL in location header. For VdcVmPolicy type, the response is 201 with created policy in response body. 
     * @summary Creates a new organization VDC compute policy
     * @param newVdcComputePolicyParams 
     */
    public createVdcComputePolicy (newVdcComputePolicyParams: VdcComputePolicy2) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcComputePolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'newVdcComputePolicyParams' is not null or undefined
        if (newVdcComputePolicyParams === null || newVdcComputePolicyParams === undefined) {
            throw new Error('Required parameter newVdcComputePolicyParams was null or undefined when calling createVdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: newVdcComputePolicyParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes vDC compute policy. if PolicyType is VdcKubernetesPolicy, then the response is a 202 with task URL in location header, else 204 is returned. 
     * @summary Delete specified organization VDC compute policy.
     * @param vdcComputePolicyId 
     */
    public deleteVdcComputePolicy (vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcComputePolicies/{vdcComputePolicyId}'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling deleteVdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified organization VDC compute policy
     * @param vdcComputePolicyId 
     */
    public getVdcComputePolicy (vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcComputePolicies/{vdcComputePolicyId}'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling getVdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns metrics for the given compute policy. Returns 400 if the policyType does not support metrics. For example, if type of the policy is VdcVmPolicy, then this API returns a 400 BadRequest response. 
     * @summary Get specified organization VDC compute policy metrics.
     * @param vdcComputePolicyId 
     */
    public getVdcComputePolicyMetrics (vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicyMetrics;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcComputePolicies/{vdcComputePolicyId}/metrics'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling getVdcComputePolicyMetrics.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicyMetrics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get orgatization VDCs this VDC compute policy has been assigned/published to
     * @param vdcComputePolicyId 
     */
    public getVdcComputePolicyVdcs (vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcComputePolicies/{vdcComputePolicyId}/vdcs'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling getVdcComputePolicyVdcs.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EntityReference>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of organization VDC compute policy. <br> Results can be filtered by: <ul>   <li> id   <li> pvdcId   <li> isSizingOnly   <li> _context  <ul> <br> Supported contexts are: Org VDC Urn ID (_context==orgVdcUrn) - | <br> Returns all the VDC compute policies which are available to a specific Org VDC. 
     * @summary Get list of organization VDC compute policies.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryVdcComputePolicies (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicies2;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcComputePolicies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryVdcComputePolicies.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryVdcComputePolicies.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicies2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of Virtual Machine Classes associated with this policy. Returns 400 if policy type is anything but VdcKubernetesPolicy. 
     * @summary Get a list of Virtual Machine Classes associated with this policy.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param vdcComputePolicyId 
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryVirtualMachineClasses (page: number, pageSize: number, vdcComputePolicyId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VirtualMachineClasses;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcComputePolicies/{vdcComputePolicyId}/virtualMachineClasses'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryVirtualMachineClasses.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryVirtualMachineClasses.');
        }

        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling queryVirtualMachineClasses.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VirtualMachineClasses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates vDC compute policy. if PolicyType is VdcKubernetesPolicy, then the response is a 202 with task URL in location header. For VdcVmPolicy type, the response is 200 with updated policy in response body. 
     * @summary Update specified organization VDC compute policy
     * @param updateVdcComputePolicyParams 
     * @param vdcComputePolicyId 
     */
    public updateVdcComputePolicy (updateVdcComputePolicyParams: VdcComputePolicy2, vdcComputePolicyId: string) : Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }> {
        const localVarPath = this.basePath + '/2.0.0/vdcComputePolicies/{vdcComputePolicyId}'
            .replace('{' + 'vdcComputePolicyId' + '}', String(vdcComputePolicyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'updateVdcComputePolicyParams' is not null or undefined
        if (updateVdcComputePolicyParams === null || updateVdcComputePolicyParams === undefined) {
            throw new Error('Required parameter updateVdcComputePolicyParams was null or undefined when calling updateVdcComputePolicy.');
        }

        // verify required parameter 'vdcComputePolicyId' is not null or undefined
        if (vdcComputePolicyId === null || vdcComputePolicyId === undefined) {
            throw new Error('Required parameter vdcComputePolicyId was null or undefined when calling updateVdcComputePolicy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateVdcComputePolicyParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcComputePolicy2;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VdcGroupApiApiKeys {
    ApiKeyAuth,
}

export class VdcGroupApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VdcGroupApiApiKeys, value: string) {
        this.authentications[VdcGroupApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a vDC Group
     * @param vdcGroupId 
     * @param force Value \&quot;true\&quot; means to forcefully delete the object that contains other objects even if those objects are in a state that does not allow removal. The default is \&quot;false\&quot;; therefore, objects are not removed if they are not in a state that normally allows removal. Force also implies recursive delete where other contained objects are removed. Errors may be ignored. Invalid value (not true or false) are ignored. 
     */
    public deleteVdcGroup (vdcGroupId: string, force?: boolean) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling deleteVdcGroup.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific vDC Group.
     * @param vdcGroupId 
     */
    public getVdcGroup (vdcGroupId: string) : Promise<{ response: http.ClientResponse; body: VdcGroup;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling getVdcGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcGroup;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sync/repair the vDC group. An example usage is to detect if a vDC still exists/is valid. If an Organization vDC referenced by the VDC group is deleted or if it is not participating in universal networking, it's status will be updated to OBJECT_NOT_FOUND and the vdc group will be marked as NOT_REALIZED. This will also initiate a sync of associated router, if any. The router entities like egress points and universal routes will also be marked as NOT_REALIZED if they reference the removed Organization vDC. 
     * @param vdcGroupId 
     */
    public syncVdcGroup (vdcGroupId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}/sync'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling syncVdcGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific vDC Group.  Example is to add/remove a participarting vDC.
     * @param vdcGroup 
     * @param vdcGroupId 
     */
    public updateVdcGroup (vdcGroup: VdcGroup, vdcGroupId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/{vdcGroupId}'
            .replace('{' + 'vdcGroupId' + '}', String(vdcGroupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroup' is not null or undefined
        if (vdcGroup === null || vdcGroup === undefined) {
            throw new Error('Required parameter vdcGroup was null or undefined when calling updateVdcGroup.');
        }

        // verify required parameter 'vdcGroupId' is not null or undefined
        if (vdcGroupId === null || vdcGroupId === undefined) {
            throw new Error('Required parameter vdcGroupId was null or undefined when calling updateVdcGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vdcGroup,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VdcGroupCandidatesApiApiKeys {
    ApiKeyAuth,
}

export class VdcGroupCandidatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VdcGroupCandidatesApiApiKeys, value: string) {
        this.authentications[VdcGroupCandidatesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get a list of candidate vDCs. Results can be filtered by the type of vDC group and contexts of vDC ID or network pool ID. Below are the supported contexts: <ul> <li>Local vDC Group<code>(_context==LOCAL;_context==orgVdcId)</code> - Returns all vDCs that have the same network pool assigned to the org vDC. <li>Universal vDC Group backed by NSX-V network provider <code>(_context==UNIVERSAL;_context==orgVdcId;_context==networkPoolUniversalId)</code> - If the orgVdc is specified, returns all vDCs that have the same assigned universal network pool as that of the org vDC. A universal network pool is backed by a broadcast domain that can stretch to multiple VMware Cloud Director sites. If the org vDC is not specified or not found and the universal network pool is specified, return all vDCs whose network pool are backed by that universal network pool. This case supports multisite/associated organization queries where user wants to retrieve remote vDCs on different sites/associated organizations with same backing universal network pool. <li>Existing vDC Group<code>(_context==vdcGroupId;_context==networkPoolUniversalId)</code> - If vDC Group is specified, return all vDCs that have the same assigned network pool as that of the vDC Group and also all vDCs that are currently participating in the vDC Group. The assigned network pool can also be universal if the vDC Group type is UNIVERSAL. If vDC Group is not specified or not found and the universal network pool is specified, return all vDCs whose network pool are backed by that universal network pool. This case supports multisite/associated organization queries where user wants to retrieve remote vDCs on different sites/associated organizations with same backing universal network pool. </ul> Note that multisite calls to get the candidate vDCs for a local vDC Group will only return the vDCs of the local site's associated organizations. Remote site's vDCs are not returned since the org vDC or the vDC group is not found there. 
     * @summary Get a list of candidate vDCs that can be added to a single vDC Group in the networking context.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getNetworkingVdcGroupCandidates (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: NetworkingCandidateVdcs;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/networkingCandidateVdcs';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getNetworkingVdcGroupCandidates.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getNetworkingVdcGroupCandidates.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NetworkingCandidateVdcs;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VdcGroupsApiApiKeys {
    ApiKeyAuth,
}

export class VdcGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VdcGroupsApiApiKeys, value: string) {
        this.authentications[VdcGroupsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a vDC Group. A universal router will also be created if universalNetworkingEnabled is set to true.
     * @param vdcGroup 
     */
    public createVdcGroup (vdcGroup: VdcGroup) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroup' is not null or undefined
        if (vdcGroup === null || vdcGroup === undefined) {
            throw new Error('Required parameter vdcGroup was null or undefined when calling createVdcGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vdcGroup,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of vDC Groups. To find all vDC Groups that contains a specific Organization vDC, user can use the filter \"participatingOrgVdcs.vdcRef.id\" key. 
     * @summary Get a list of vDC Groups.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getVdcGroups (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VdcGroups;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getVdcGroups.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getVdcGroups.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcGroups;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VdcGroupsSettingsApiApiKeys {
    ApiKeyAuth,
}

export class VdcGroupsSettingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VdcGroupsSettingsApiApiKeys, value: string) {
        this.authentications[VdcGroupsSettingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves the global vDC groups settings. These settings apply to all vDC Groups in the system and can only be retrieved by the provider.
     */
    public getVdcGroupSettings () : Promise<{ response: http.ClientResponse; body: VdcGroupSettings;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/settings';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcGroupSettings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the global vDC groups settings. These settings apply to all vDC Groups in the system and can only be updated by the provider.
     * @param vdcGroupSettings 
     */
    public updateVdcGroupSettings (vdcGroupSettings: VdcGroupSettings) : Promise<{ response: http.ClientResponse; body: VdcGroupSettings;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcGroups/settings';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcGroupSettings' is not null or undefined
        if (vdcGroupSettings === null || vdcGroupSettings === undefined) {
            throw new Error('Required parameter vdcGroupSettings was null or undefined when calling updateVdcGroupSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vdcGroupSettings,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcGroupSettings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VdcNetworkProfileApiApiKeys {
    ApiKeyAuth,
}

export class VdcNetworkProfileApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VdcNetworkProfileApiApiKeys, value: string) {
        this.authentications[VdcNetworkProfileApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes/Reset a vDC Network Profile.
     * @param orgVdcId 
     */
    public deleteVdcNetworkProfile (orgVdcId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcs/{orgVdcId}/networkProfile'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling deleteVdcNetworkProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the vDC Network Profile.
     * @param orgVdcId 
     */
    public getVdcNetworkProfile (orgVdcId: string) : Promise<{ response: http.ClientResponse; body: VdcNetworkProfile;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcs/{orgVdcId}/networkProfile'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling getVdcNetworkProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VdcNetworkProfile;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the vDC Network Profile.
     * @param vdcNetworkProfile 
     * @param orgVdcId 
     */
    public updateVdcNetworkProfile (vdcNetworkProfile: VdcNetworkProfile, orgVdcId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/vdcs/{orgVdcId}/networkProfile'
            .replace('{' + 'orgVdcId' + '}', String(orgVdcId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vdcNetworkProfile' is not null or undefined
        if (vdcNetworkProfile === null || vdcNetworkProfile === undefined) {
            throw new Error('Required parameter vdcNetworkProfile was null or undefined when calling updateVdcNetworkProfile.');
        }

        // verify required parameter 'orgVdcId' is not null or undefined
        if (orgVdcId === null || orgVdcId === undefined) {
            throw new Error('Required parameter orgVdcId was null or undefined when calling updateVdcNetworkProfile.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vdcNetworkProfile,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VirtualCenterApiApiKeys {
    ApiKeyAuth,
}

export class VirtualCenterApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VirtualCenterApiApiKeys, value: string) {
        this.authentications[VirtualCenterApiApiKeys[key]].apiKey = value;
    }
    /**
     * Attach a Virtual Center server.
     * @summary Attach a Virtual Center server
     * @param vimserver 
     */
    public attachVirtualCenter (vimserver: VCenterServer) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vimserver' is not null or undefined
        if (vimserver === null || vimserver === undefined) {
            throw new Error('Required parameter vimserver was null or undefined when calling attachVirtualCenter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: vimserver,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unregister a vCenter server. This operation is asynchronous and returns a task that you can monitor to track the progress of the request. 
     * @summary Detach the specified Virtual Center server
     * @param vcUrn 
     */
    public deleteVirtualCenter (vcUrn: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}'
            .replace('{' + 'vcUrn' + '}', String(vcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling deleteVirtualCenter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of child resource pools of the specified parent. If a resource pool is ineligible, but is in the response, this means it has children, which are eligible. A resource pool will be ineligible, unless the cluster has an ESXi host on it. The list will be sorted by name, case insensitive. 
     * @summary Get resource pools of a VC
     * @param vcUrn 
     * @param moref 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     */
    public getChildResourcePools (vcUrn: string, moref: string, page: number, pageSize: number) : Promise<{ response: http.ClientResponse; body: ResourcePools;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/resourcePools/browse/{moref}'
            .replace('{' + 'vcUrn' + '}', String(vcUrn))
            .replace('{' + 'moref' + '}', String(moref));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getChildResourcePools.');
        }

        // verify required parameter 'moref' is not null or undefined
        if (moref === null || moref === undefined) {
            throw new Error('Required parameter moref was null or undefined when calling getChildResourcePools.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getChildResourcePools.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getChildResourcePools.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResourcePools;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the networking configuration of a registered vCenter server. 
     * @summary Get Virtual Center server network settings
     * @param vcUrn 
     */
    public getNsxVManagerSettings (vcUrn: string) : Promise<{ response: http.ClientResponse; body: NsxVManagerSettings;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/nsxVSettings'
            .replace('{' + 'vcUrn' + '}', String(vcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getNsxVManagerSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NsxVManagerSettings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get kubernetes configuration for a resource pool which is backed by a kubernetes enabled cluster. 
     * @summary Get kubernetes configuration for a resource pool.
     * @param vcUrn 
     * @param moref 
     */
    public getResourcePoolKubernetesConfig (vcUrn: string, moref: string) : Promise<{ response: http.ClientResponse; body: ResourcePoolKubernetesConfig;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/resourcePools/{moref}/kubernetesConfig'
            .replace('{' + 'vcUrn' + '}', String(vcUrn))
            .replace('{' + 'moref' + '}', String(moref));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getResourcePoolKubernetesConfig.');
        }

        // verify required parameter 'moref' is not null or undefined
        if (moref === null || moref === undefined) {
            throw new Error('Required parameter moref was null or undefined when calling getResourcePoolKubernetesConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResourcePoolKubernetesConfig;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all root resource pools. If a resource pool is ineligible, but is in the response, this means it has children, which are eligible. A resource pool will be ineligible, unless the cluster has an ESXi host on it. The list will be sorted by name, case insensitive. 
     * @summary Get resource pools of a VC
     * @param vcUrn 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     */
    public getRootResourcePools (vcUrn: string, page: number, pageSize: number) : Promise<{ response: http.ClientResponse; body: ResourcePools;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/resourcePools/browse'
            .replace('{' + 'vcUrn' + '}', String(vcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getRootResourcePools.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getRootResourcePools.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getRootResourcePools.');
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResourcePools;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all storage profiles for a VC. Supported contexts are: Resource Pool Moref (_context==moref) - | Returns all the storage profiles which are related to a specific Resoure Pool. Example: /cloudapi/{ver}/virtualCenters/{urn}/storageProfiles?filter=_context==resgroup-N 
     * @summary Get storage profiles of a VC
     * @param vcUrn 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getStorageProfiles (vcUrn: string, page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: StorageProfiles;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/storageProfiles'
            .replace('{' + 'vcUrn' + '}', String(vcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getStorageProfiles.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getStorageProfiles.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getStorageProfiles.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StorageProfiles;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a set of all supported hardware versions by the ESXi hosts in the resource pool. 
     * @summary Get supported hardware versions of a resource pool
     * @param vcUrn 
     * @param moref 
     */
    public getSupportedHardwareVersions (vcUrn: string, moref: string) : Promise<{ response: http.ClientResponse; body: HardwareVersions;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/resourcePools/{moref}/hwv'
            .replace('{' + 'vcUrn' + '}', String(vcUrn))
            .replace('{' + 'moref' + '}', String(moref));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getSupportedHardwareVersions.');
        }

        // verify required parameter 'moref' is not null or undefined
        if (moref === null || moref === undefined) {
            throw new Error('Required parameter moref was null or undefined when calling getSupportedHardwareVersions.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: HardwareVersions;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of unmanaged virtual machines from vCenter Server 
     * @summary Get a list of unmanaged virtual machines from vCenter Server
     * @param vcUrn 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getUnmanagedVirtualMachines (vcUrn: string, page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: UnmanagedVirtualMachines;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/unmanagedVirtualMachines'
            .replace('{' + 'vcUrn' + '}', String(vcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getUnmanagedVirtualMachines.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getUnmanagedVirtualMachines.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getUnmanagedVirtualMachines.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UnmanagedVirtualMachines;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the current capabilities configured on a specific Virtual Center storage policy. These cannot be edited. 
     * @summary Retrieves capabilities of a specific Virtual Center storage policy.
     * @param vcUrn 
     * @param moref 
     */
    public getVcStoragePolicyCapabilities (vcUrn: string, moref: string) : Promise<{ response: http.ClientResponse; body: Capabilities;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/storageProfiles/{moref}/capabilities'
            .replace('{' + 'vcUrn' + '}', String(vcUrn))
            .replace('{' + 'moref' + '}', String(moref));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getVcStoragePolicyCapabilities.');
        }

        // verify required parameter 'moref' is not null or undefined
        if (moref === null || moref === undefined) {
            throw new Error('Required parameter moref was null or undefined when calling getVcStoragePolicyCapabilities.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Capabilities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the representation of a vCenter server registered and managed by vCD. 
     * @summary Get Virtual Center server
     * @param vcUrn 
     */
    public getVirtualCenter (vcUrn: string) : Promise<{ response: http.ClientResponse; body: VCenterServer;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}'
            .replace('{' + 'vcUrn' + '}', String(vcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getVirtualCenter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VCenterServer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the metrics of a registered vCenter server. 
     * @summary Get Virtual Center server metrics
     * @param vcUrn 
     */
    public getVirtualCenterMetrics (vcUrn: string) : Promise<{ response: http.ClientResponse; body: VCenterServerMetrics;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/metrics'
            .replace('{' + 'vcUrn' + '}', String(vcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling getVirtualCenterMetrics.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VCenterServerMetrics;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a paged list of all Virtual Center servers in the system. 
     * @summary Gets a paged list of Virtual Center servers.
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryVirtualCenters (page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VCenterServers;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryVirtualCenters.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryVirtualCenters.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VCenterServers;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of Virtual Machine Classes associated with this resource pool. This API throws 400 BadRequestException if called against a resource pool which is not Kubernetes enabled. 
     * @summary Get a list of Virtual Machine Classes associated with this resource pool.
     * @param vcUrn 
     * @param moref 
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public queryVirtualMachineClasses (vcUrn: string, moref: string, page: number, pageSize: number, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VirtualMachineClasses;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/resourcePools/{moref}/virtualMachineClasses'
            .replace('{' + 'vcUrn' + '}', String(vcUrn))
            .replace('{' + 'moref' + '}', String(moref));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling queryVirtualMachineClasses.');
        }

        // verify required parameter 'moref' is not null or undefined
        if (moref === null || moref === undefined) {
            throw new Error('Required parameter moref was null or undefined when calling queryVirtualMachineClasses.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling queryVirtualMachineClasses.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling queryVirtualMachineClasses.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VirtualMachineClasses;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the network settings of a registered vCenter server. This operation is asynchronous and returns a task that you can monitor to track the progress of the request. 
     * @summary Update specified Virtual Center server network settings
     * @param vcUrn 
     * @param updateVCenterServerParams 
     */
    public updateNsxVManagerSettings (vcUrn: string, updateVCenterServerParams: NsxVManagerSettings) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}/nsxVSettings'
            .replace('{' + 'vcUrn' + '}', String(vcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling updateNsxVManagerSettings.');
        }

        // verify required parameter 'updateVCenterServerParams' is not null or undefined
        if (updateVCenterServerParams === null || updateVCenterServerParams === undefined) {
            throw new Error('Required parameter updateVCenterServerParams was null or undefined when calling updateNsxVManagerSettings.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateVCenterServerParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the representation of a registered vCenter server. This operation is asynchronous and returns a task that you can monitor to track the progress of the request. 
     * @summary Update specified Virtual Center server
     * @param vcUrn 
     * @param updateVCenterServerParams 
     */
    public updateVirtualCenter (vcUrn: string, updateVCenterServerParams: VCenterServer) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/virtualCenters/{vcUrn}'
            .replace('{' + 'vcUrn' + '}', String(vcUrn));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vcUrn' is not null or undefined
        if (vcUrn === null || vcUrn === undefined) {
            throw new Error('Required parameter vcUrn was null or undefined when calling updateVirtualCenter.');
        }

        // verify required parameter 'updateVCenterServerParams' is not null or undefined
        if (updateVCenterServerParams === null || updateVCenterServerParams === undefined) {
            throw new Error('Required parameter updateVCenterServerParams was null or undefined when calling updateVirtualCenter.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: updateVCenterServerParams,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VmcSddcsApiApiKeys {
    ApiKeyAuth,
}

export class VmcSddcsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VmcSddcsApiApiKeys, value: string) {
        this.authentications[VmcSddcsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Retrieves a list of SDDCs for a specific VMware service application that are available
     * @param serviceAppId 
     */
    public getVmcSddcs (serviceAppId: string) : Promise<{ response: http.ClientResponse; body: VmcSddcs;  }> {
        const localVarPath = this.basePath + '/1.0.0/serviceApps/{serviceAppId}/sddcs'
            .replace('{' + 'serviceAppId' + '}', String(serviceAppId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'serviceAppId' is not null or undefined
        if (serviceAppId === null || serviceAppId === undefined) {
            throw new Error('Required parameter serviceAppId was null or undefined when calling getVmcSddcs.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VmcSddcs;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Register a VMware service application SDDC's components
     * @param serviceAppSddc 
     * @param serviceAppId 
     */
    public registerVmcSDDC (serviceAppSddc: VmcSddc, serviceAppId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/1.0.0/serviceApps/{serviceAppId}/sddcs'
            .replace('{' + 'serviceAppId' + '}', String(serviceAppId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'serviceAppSddc' is not null or undefined
        if (serviceAppSddc === null || serviceAppSddc === undefined) {
            throw new Error('Required parameter serviceAppSddc was null or undefined when calling registerVmcSDDC.');
        }

        // verify required parameter 'serviceAppId' is not null or undefined
        if (serviceAppId === null || serviceAppId === undefined) {
            throw new Error('Required parameter serviceAppId was null or undefined when calling registerVmcSDDC.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: serviceAppSddc,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VrealizeBrowseApiApiKeys {
    ApiKeyAuth,
}

export class VrealizeBrowseApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VrealizeBrowseApiApiKeys, value: string) {
        this.authentications[VrealizeBrowseApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Browse remote vRealize Orchestrator inventory
     * @param vroId The ID of the server to browse inventory items on
     * @param target The &#39;plugin[:type]&#39; to serve as the starting point for the browsing
     * @param browsePaths Inventory search path to identify the VRO inventory node to get contents of
     */
    public browseSdkObjects (vroId: string, target: string, browsePaths: string) : Promise<{ response: http.ClientResponse; body: VroRemoteItems;  }> {
        const localVarPath = this.basePath + '/vro/servers/{vroId}/sdkObjects/{target}/{browsePaths:.+}'
            .replace('{' + 'vroId' + '}', String(vroId))
            .replace('{' + 'target' + '}', String(target))
            .replace('{' + 'browsePaths' + '}', String(browsePaths));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vroId' is not null or undefined
        if (vroId === null || vroId === undefined) {
            throw new Error('Required parameter vroId was null or undefined when calling browseSdkObjects.');
        }

        // verify required parameter 'target' is not null or undefined
        if (target === null || target === undefined) {
            throw new Error('Required parameter target was null or undefined when calling browseSdkObjects.');
        }

        // verify required parameter 'browsePaths' is not null or undefined
        if (browsePaths === null || browsePaths === undefined) {
            throw new Error('Required parameter browsePaths was null or undefined when calling browseSdkObjects.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VroRemoteItems;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Browse remote vRealize Orchestrator inventory
     * @param vroId The ID of the server to browse inventory items on
     */
    public getPluginList (vroId: string) : Promise<{ response: http.ClientResponse; body: VroRemotePluginItems;  }> {
        const localVarPath = this.basePath + '/vro/servers/{vroId}/entityTypes'
            .replace('{' + 'vroId' + '}', String(vroId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vroId' is not null or undefined
        if (vroId === null || vroId === undefined) {
            throw new Error('Required parameter vroId was null or undefined when calling getPluginList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VroRemotePluginItems;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Browse remote vRealize Orchestrator inventory
     * @param vroId The ID of the server to browse inventory items on
     * @param pluginName Inventory search path to identify the VRO inventory node to get contents of
     */
    public getPluginTypeList (vroId: string, pluginName: string) : Promise<{ response: http.ClientResponse; body: VroRemotePluginTypes;  }> {
        const localVarPath = this.basePath + '/vro/servers/{vroId}/entityTypes/{pluginName}'
            .replace('{' + 'vroId' + '}', String(vroId))
            .replace('{' + 'pluginName' + '}', String(pluginName));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vroId' is not null or undefined
        if (vroId === null || vroId === undefined) {
            throw new Error('Required parameter vroId was null or undefined when calling getPluginTypeList.');
        }

        // verify required parameter 'pluginName' is not null or undefined
        if (pluginName === null || pluginName === undefined) {
            throw new Error('Required parameter pluginName was null or undefined when calling getPluginTypeList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VroRemotePluginTypes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Browse remote vRealize Orchestrator inventory
     * @param vroId The ID of the server to browse inventory items on
     * @param any Inventory search path to identify the VRO inventory node to get contents of
     */
    public getRemoteInventory (vroId: string, any: string) : Promise<{ response: http.ClientResponse; body: VroRemoteInventoryItem;  }> {
        const localVarPath = this.basePath + '/vro/servers/{vroId}/inventory{any:.*}'
            .replace('{' + 'vroId' + '}', String(vroId))
            .replace('{' + 'any' + '}', String(any));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vroId' is not null or undefined
        if (vroId === null || vroId === undefined) {
            throw new Error('Required parameter vroId was null or undefined when calling getRemoteInventory.');
        }

        // verify required parameter 'any' is not null or undefined
        if (any === null || any === undefined) {
            throw new Error('Required parameter any was null or undefined when calling getRemoteInventory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VroRemoteInventoryItem;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Browse remote vRealize Orchestrator inventory
     * @param vroId The ID of the server to browse inventory items on
     * @param target The &#39;plugin[:type]&#39; to serve as the starting point for the browsing
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public searchSdkObjects (vroId: string, target: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VroRemoteItems;  }> {
        const localVarPath = this.basePath + '/vro/servers/{vroId}/sdkObjects/{target}'
            .replace('{' + 'vroId' + '}', String(vroId))
            .replace('{' + 'target' + '}', String(target));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'vroId' is not null or undefined
        if (vroId === null || vroId === undefined) {
            throw new Error('Required parameter vroId was null or undefined when calling searchSdkObjects.');
        }

        // verify required parameter 'target' is not null or undefined
        if (target === null || target === undefined) {
            throw new Error('Required parameter target was null or undefined when calling searchSdkObjects.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VroRemoteItems;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VrealizeWorkflowsApiApiKeys {
    ApiKeyAuth,
}

export class VrealizeWorkflowsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VrealizeWorkflowsApiApiKeys, value: string) {
        this.authentications[VrealizeWorkflowsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Browse remote vRealize Orchestrator workflows
     * @param page Page to fetch, zero offset.
     * @param pageSize Results per page to fetch.
     * @param vroServerId The ID of the server to browse workflows on
     * @param filter Filter for a query.  FIQL format.
     * @param sortAsc Field to use for ascending sort
     * @param sortDesc Field to use for descending sort
     */
    public getRemoteWorkflows (page: number, pageSize: number, vroServerId: string, filter?: string, sortAsc?: string, sortDesc?: string) : Promise<{ response: http.ClientResponse; body: VroRemoteWorkflowItems;  }> {
        const localVarPath = this.basePath + '/vro/servers/{vroServerId}/workflows'
            .replace('{' + 'vroServerId' + '}', String(vroServerId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling getRemoteWorkflows.');
        }

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling getRemoteWorkflows.');
        }

        // verify required parameter 'vroServerId' is not null or undefined
        if (vroServerId === null || vroServerId === undefined) {
            throw new Error('Required parameter vroServerId was null or undefined when calling getRemoteWorkflows.');
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (sortAsc !== undefined) {
            queryParameters['sortAsc'] = sortAsc;
        }

        if (sortDesc !== undefined) {
            queryParameters['sortDesc'] = sortDesc;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VroRemoteWorkflowItems;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VroWorkflowExecutionApiApiKeys {
    ApiKeyAuth,
}

export class VroWorkflowExecutionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VroWorkflowExecutionApiApiKeys, value: string) {
        this.authentications[VroWorkflowExecutionApiApiKeys[key]].apiKey = value;
    }
    /**
     * Cancels a workflow run
     * @summary Cancel workflow run
     * @param workflowId workflowId
     * @param executionId executionId
     */
    public cancelWorkflowExecution (workflowId: string, executionId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/executions/{executionId}/state'
            .replace('{' + 'workflowId' + '}', String(workflowId))
            .replace('{' + 'executionId' + '}', String(executionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling cancelWorkflowExecution.');
        }

        // verify required parameter 'executionId' is not null or undefined
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling cancelWorkflowExecution.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a specific workflow run
     * @summary Delete workflow run
     * @param workflowId workflowId
     * @param executionId executionId
     */
    public deleteWorkflowExecution (workflowId: string, executionId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/executions/{executionId}'
            .replace('{' + 'workflowId' + '}', String(workflowId))
            .replace('{' + 'executionId' + '}', String(executionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling deleteWorkflowExecution.');
        }

        // verify required parameter 'executionId' is not null or undefined
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling deleteWorkflowExecution.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves all workflow runs for a given workflow
     * @summary Get all executions
     * @param workflowId workflowId
     */
    public getAllWorkflowExecutions (workflowId: string) : Promise<{ response: http.ClientResponse; body: PresentationExecutionsList;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/executions'
            .replace('{' + 'workflowId' + '}', String(workflowId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling getAllWorkflowExecutions.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PresentationExecutionsList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint will not produce results. It is a placeholder to enforce code generation of ParameterTypes.
     * @summary This endpoint will not produce results. It is a placeholder to enforce code generation of ParameterTypes.
     */
    public getParameterTypes () : Promise<{ response: http.ClientResponse; body: ParameterTypes;  }> {
        const localVarPath = this.basePath + '/workflows/parameterTypes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ParameterTypes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint will not produce results. It is a placeholder to enforce code generation of SupportedDecorators.
     * @summary This endpoint will not produce results. It is a placeholder to enforce code generation of SupportedDecorators.
     */
    public getSupportedDecorators () : Promise<{ response: http.ClientResponse; body: SupportedDecorators;  }> {
        const localVarPath = this.basePath + '/workflows/decorators';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SupportedDecorators;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint will not produce results. It is a placeholder to enforce code generation of SupportedPresentationElements.
     * @summary This endpoint will not produce results. It is a placeholder to enforce code generation of SupportedPresentationElements.
     */
    public getSupportedPresentationElements () : Promise<{ response: http.ClientResponse; body: SupportedPresentationElements;  }> {
        const localVarPath = this.basePath + '/workflows/presentationElements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SupportedPresentationElements;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint will not produce results. It is a placeholder to enforce code generation of SupportedConstraints.
     * @summary This endpoint will not produce results. It is a placeholder to enforce code generation of SupportedConstraints.
     */
    public getSupportedconstraints () : Promise<{ response: http.ClientResponse; body: SupportedConstraints;  }> {
        const localVarPath = this.basePath + '/workflows/constraints';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SupportedConstraints;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a workflow run for a given workflow.
     * @summary Get workflow execution
     * @param workflowId workflowId
     * @param executionId executionId
     */
    public getWorkflowExecution (workflowId: string, executionId: string) : Promise<{ response: http.ClientResponse; body: WsWorkflowExecution;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/executions/{executionId}'
            .replace('{' + 'workflowId' + '}', String(workflowId))
            .replace('{' + 'executionId' + '}', String(executionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling getWorkflowExecution.');
        }

        // verify required parameter 'executionId' is not null or undefined
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling getWorkflowExecution.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WsWorkflowExecution;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the current state for a requested workflow run
     * @summary Get workflow execution state
     * @param workflowId workflowId
     * @param executionId executionId
     */
    public getWorkflowExecutionState (workflowId: string, executionId: string) : Promise<{ response: http.ClientResponse; body: ExecutionState;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/executions/{executionId}/state'
            .replace('{' + 'workflowId' + '}', String(workflowId))
            .replace('{' + 'executionId' + '}', String(executionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling getWorkflowExecutionState.');
        }

        // verify required parameter 'executionId' is not null or undefined
        if (executionId === null || executionId === undefined) {
            throw new Error('Required parameter executionId was null or undefined when calling getWorkflowExecutionState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExecutionState;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Instantiates a workflow run, by using the passed parameters. The workflow run is asynchronous, so the call returns a pointer to a task that can be used to track the workflow run. 
     * @summary Start workflow execution
     * @param workflowId workflowId
     * @param executionContext executionContext
     */
    public startWorkflowExecution (workflowId: string, executionContext: ExecutionContext) : Promise<{ response: http.ClientResponse; body: WsWorkflowExecution;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/executions'
            .replace('{' + 'workflowId' + '}', String(workflowId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling startWorkflowExecution.');
        }

        // verify required parameter 'executionContext' is not null or undefined
        if (executionContext === null || executionContext === undefined) {
            throw new Error('Required parameter executionContext was null or undefined when calling startWorkflowExecution.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: executionContext,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WsWorkflowExecution;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VroWorkflowPresentationApiApiKeys {
    ApiKeyAuth,
}

export class VroWorkflowPresentationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ApiKeyAuth': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VroWorkflowPresentationApiApiKeys, value: string) {
        this.authentications[VroWorkflowPresentationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Cancels the execution of a workflow presentation instance. This API call cancels only the workflow presentation execution. To cancel the workflow execution, use APIs under <b>/cloudapi/workflows/{workflowId}/instances</b>.
     * @summary Delete workflow presentation execution
     * @param workflowId workflowId
     * @param presentationExecutionId presentationExecutionId
     */
    public deleteWorkflowPresenationInstance (workflowId: string, presentationExecutionId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/presentation/instances/{presentationExecutionId}'
            .replace('{' + 'workflowId' + '}', String(workflowId))
            .replace('{' + 'presentationExecutionId' + '}', String(presentationExecutionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling deleteWorkflowPresenationInstance.');
        }

        // verify required parameter 'presentationExecutionId' is not null or undefined
        if (presentationExecutionId === null || presentationExecutionId === undefined) {
            throw new Error('Required parameter presentationExecutionId was null or undefined when calling deleteWorkflowPresenationInstance.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a list of the presentation instances for a workflow that you specify. To retrieve the list of workflow presentations, make an HTTP GET request at the workflow presentations list URL. The returned list contains all of the currently running workflow presentation instances, and all completed instances based on the data from the workflow executions. If the user has admin rights, all presentation instances for all users are returned.
     * @summary Get all presentations
     * @param workflowId workflowId
     */
    public getAllWorkflowPresentationInstances (workflowId: string) : Promise<{ response: http.ClientResponse; body: PresentationExecutionsList;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/presentation/instances'
            .replace('{' + 'workflowId' + '}', String(workflowId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling getAllWorkflowPresentationInstances.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PresentationExecutionsList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the definition of a workflow presentation. To retrieve the workflow presentation definition localized, add Accept-Language header, with the appropriate locale. In advance, localization resource should be present for the workflow, otherwise it defaults to the standard workflow presentation definition.
     * @summary Get presentation
     * @param workflowId workflowId
     */
    public getWorkflowPresentation (workflowId: string) : Promise<{ response: http.ClientResponse; body: Presentation;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/presentation'
            .replace('{' + 'workflowId' + '}', String(workflowId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling getWorkflowPresentation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Presentation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a specific workflow presentation instance. Presentation instances are removed after the workflow starts. If the presentation instance under requested <b>executionId</b> does not exists, a new presentation instance is created by using the parameters from the workflow execution with the same ID. To retrieve the workflow presentation localized, add Accept-Language header, with the appropriate locale. In advance, localization resource should be present for the workflow, otherwise it defaults to the standard workflow presentation.
     * @summary Load Execution
     * @param workflowId workflowId
     * @param presentationExecutionId presentationExecutionId
     */
    public getWorkflowPresentationInstance (workflowId: string, presentationExecutionId: string) : Promise<{ response: http.ClientResponse; body: PresentationExecution;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/presentation/instances/{presentationExecutionId}'
            .replace('{' + 'workflowId' + '}', String(workflowId))
            .replace('{' + 'presentationExecutionId' + '}', String(presentationExecutionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling getWorkflowPresentationInstance.');
        }

        // verify required parameter 'presentationExecutionId' is not null or undefined
        if (presentationExecutionId === null || presentationExecutionId === undefined) {
            throw new Error('Required parameter presentationExecutionId was null or undefined when calling getWorkflowPresentationInstance.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PresentationExecution;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *  Creates a new instance of the presentation of a workflow, by using the passed parameters. To create a new instance of a workflow presentation, make an HTTP GET request at the URL that contains the instances of the workflow presentation. Presentation's fields are populated with input parameter values and are validated. If there are any validation errors, they are collected and attached to each field. The presentation is marked as invalid. In order the returned workflow presentation to be localized, add Accept-Language header, with the appropriate locale. In advance, localization resource should be present for the workflow, otherwise it defaults to the standard workflow presentation.
     * @summary Start presentation
     * @param workflowId workflowId
     * @param executionContext executionContext
     */
    public startWorkflowPresentation (workflowId: string, executionContext: ExecutionContext) : Promise<{ response: http.ClientResponse; body: PresentationExecution;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/presentation/instances'
            .replace('{' + 'workflowId' + '}', String(workflowId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling startWorkflowPresentation.');
        }

        // verify required parameter 'executionContext' is not null or undefined
        if (executionContext === null || executionContext === undefined) {
            throw new Error('Required parameter executionContext was null or undefined when calling startWorkflowPresentation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: executionContext,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PresentationExecution;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a specific workflow presentation instance. Presentation fields are populated with input parameter values and are validated. If there are any validation errors, they are collected and attached to each field. The presentation is marked as invalid. If the parameter's 'updated' flag is set to true, the dependent field values are recalculated.
     * @summary Update presentation
     * @param workflowId workflowId
     * @param presentationExecutionId presentationExecutionId
     * @param executionContext executionContext
     */
    public updateWorkflowPresentationInstance (workflowId: string, presentationExecutionId: string, executionContext: ExecutionContext) : Promise<{ response: http.ClientResponse; body: PresentationExecution;  }> {
        const localVarPath = this.basePath + '/workflows/{workflowId}/presentation/instances/{presentationExecutionId}'
            .replace('{' + 'workflowId' + '}', String(workflowId))
            .replace('{' + 'presentationExecutionId' + '}', String(presentationExecutionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'workflowId' is not null or undefined
        if (workflowId === null || workflowId === undefined) {
            throw new Error('Required parameter workflowId was null or undefined when calling updateWorkflowPresentationInstance.');
        }

        // verify required parameter 'presentationExecutionId' is not null or undefined
        if (presentationExecutionId === null || presentationExecutionId === undefined) {
            throw new Error('Required parameter presentationExecutionId was null or undefined when calling updateWorkflowPresentationInstance.');
        }

        // verify required parameter 'executionContext' is not null or undefined
        if (executionContext === null || executionContext === undefined) {
            throw new Error('Required parameter executionContext was null or undefined when calling updateWorkflowPresentationInstance.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: executionContext,
        };

        this.authentications.ApiKeyAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PresentationExecution;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
